var N0=Object.defineProperty;var I0=(n,e,t)=>e in n?N0(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var ue=(n,e,t)=>(I0(n,typeof e!="symbol"?e+"":e,t),t);import{C as _0,S as tc,i as nc,s as rc,k as wt,l as Ct,m as Qe,h as $e,n as Pe,b as an,F as Qi,T as $o,V as R0,o as _h,q as sc,r as oc,E as rt,u as ic,I as ms,e as Mu,O as Eo,a as vs,P as ko,c as ws,w as O0,x as A0,y as D0,f as P0,t as F0,z as L0,G as M0,$ as B0,_ as V0,D as Rh}from"./paths-34b7d8a7.js";import{I as U0}from"./Icon-e5a3e5d7.js";function Oh(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in n)){const o=Object.getOwnPropertyDescriptor(r,s);o&&Object.defineProperty(n,s,o.get?o:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}const z0=!1;function cn(n,e){return n.then(function(t){return[null,t]}).catch(function(t){return e&&Object.assign(t,e),[t,void 0]})}const W0={camera:{width:1920,height:1792,paths:[{d:"M960 672q119 0 203.5 84.5t84.5 203.5-84.5 203.5-203.5 84.5-203.5-84.5-84.5-203.5 84.5-203.5 203.5-84.5zM1664 256q106 0 181 75t75 181v896q0 106-75 181t-181 75h-1408q-106 0-181-75t-75-181v-896q0-106 75-181t181-75h224l51-136q19-49 69.5-84.5t103.5-35.5h512q53 0 103.5 35.5t69.5 84.5l51 136h224zM960 1408q185 0 316.5-131.5t131.5-316.5-131.5-316.5-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5z"}]}},Bu=_0(0);function Vu(n,e,t){const r=n.slice();return r[4]=e[t].text,r[5]=e[t].value,r[7]=t,r}function Uu(n){let e,t=n[4]+"",r,s;return{c(){e=wt("option"),r=sc(t),this.h()},l(o){e=Ct(o,"OPTION",{});var i=Qe(e);r=oc(i,t),i.forEach($e),this.h()},h(){e.__value=s=n[5],e.value=e.__value},m(o,i){an(o,e,i),rt(e,r)},p(o,i){i&1&&t!==(t=o[4]+"")&&ic(r,t),i&1&&s!==(s=o[5])&&(e.__value=s,e.value=e.__value)},d(o){o&&$e(e)}}}function G0(n){let e,t,r,s=n[0],o=[];for(let i=0;i<s.length;i+=1)o[i]=Uu(Vu(n,s,i));return{c(){e=wt("select");for(let i=0;i<o.length;i+=1)o[i].c();this.h()},l(i){e=Ct(i,"SELECT",{class:!0});var a=Qe(e);for(let c=0;c<o.length;c+=1)o[c].l(a);a.forEach($e),this.h()},h(){Pe(e,"class","select select-primary select-sm fixed left-8 bottom-16 z-20")},m(i,a){an(i,e,a);for(let c=0;c<o.length;c+=1)o[c].m(e,null);n[2](e),t||(r=Qi(e,"change",n[3]),t=!0)},p(i,[a]){if(a&1){s=i[0];let c;for(c=0;c<s.length;c+=1){const u=Vu(i,s,c);o[c]?o[c].p(u,a):(o[c]=Uu(u),o[c].c(),o[c].m(e,null))}for(;c<o.length;c+=1)o[c].d(1);o.length=s.length}},i:$o,o:$o,d(i){i&&$e(e),R0(o,i),n[2](null),t=!1,r()}}}function j0(n,e,t){let r,{modes:s}=e;_h(()=>{t(1,r.value=0 .toString(),r),Bu.set(0)});function o(a){ms[a?"unshift":"push"](()=>{r=a,t(1,r),t(0,s)})}const i=()=>Bu.set(parseInt(r.value));return n.$$set=a=>{"modes"in a&&t(0,s=a.modes)},[s,r,o,i]}class _V extends tc{constructor(e){super(),nc(this,e,j0,G0,rc,{modes:0})}}function H0(n){let e,t,r,s,o,i,a;return{c(){e=wt("div"),t=wt("div"),r=Eo("svg"),s=Eo("path"),o=vs(),i=wt("span"),a=sc(n[3]),this.h()},l(c){e=Ct(c,"DIV",{class:!0});var u=Qe(e);t=Ct(u,"DIV",{});var l=Qe(t);r=ko(l,"svg",{xmlns:!0,class:!0,fill:!0,viewBox:!0});var h=Qe(r);s=ko(h,"path",{"stroke-linecap":!0,"stroke-linejoin":!0,"stroke-width":!0,d:!0}),Qe(s).forEach($e),h.forEach($e),o=ws(l),i=Ct(l,"SPAN",{});var p=Qe(i);a=oc(p,n[3]),p.forEach($e),l.forEach($e),u.forEach($e),this.h()},h(){Pe(s,"stroke-linecap","round"),Pe(s,"stroke-linejoin","round"),Pe(s,"stroke-width","2"),Pe(s,"d","M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"),Pe(r,"xmlns","http://www.w3.org/2000/svg"),Pe(r,"class","stroke-current flex-shrink-0 h-6 w-6"),Pe(r,"fill","none"),Pe(r,"viewBox","0 0 24 24"),Pe(e,"class","alert alert-warning shadow-lg absolute z-50 top-1")},m(c,u){an(c,e,u),rt(e,t),rt(t,r),rt(r,s),rt(t,o),rt(t,i),rt(i,a)},p(c,u){u&8&&ic(a,c[3])},d(c){c&&$e(e)}}}function K0(n){let e,t,r,s,o,i,a;return{c(){e=wt("div"),t=wt("div"),r=Eo("svg"),s=Eo("path"),o=vs(),i=wt("span"),a=sc(n[2]),this.h()},l(c){e=Ct(c,"DIV",{class:!0});var u=Qe(e);t=Ct(u,"DIV",{});var l=Qe(t);r=ko(l,"svg",{xmlns:!0,class:!0,fill:!0,viewBox:!0});var h=Qe(r);s=ko(h,"path",{"stroke-linecap":!0,"stroke-linejoin":!0,"stroke-width":!0,d:!0}),Qe(s).forEach($e),h.forEach($e),o=ws(l),i=Ct(l,"SPAN",{});var p=Qe(i);a=oc(p,n[2]),p.forEach($e),l.forEach($e),u.forEach($e),this.h()},h(){Pe(s,"stroke-linecap","round"),Pe(s,"stroke-linejoin","round"),Pe(s,"stroke-width","2"),Pe(s,"d","M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"),Pe(r,"xmlns","http://www.w3.org/2000/svg"),Pe(r,"class","stroke-current flex-shrink-0 h-6 w-6"),Pe(r,"fill","none"),Pe(r,"viewBox","0 0 24 24"),Pe(e,"class","alert alert-warning shadow-lg absolute z-50 top-1")},m(c,u){an(c,e,u),rt(e,t),rt(t,r),rt(r,s),rt(t,o),rt(t,i),rt(i,a)},p(c,u){u&4&&ic(a,c[2])},d(c){c&&$e(e)}}}function q0(n){let e;function t(o,i){if(o[0])return K0;if(o[1])return H0}let r=t(n),s=r&&r(n);return{c(){s&&s.c(),e=Mu()},l(o){s&&s.l(o),e=Mu()},m(o,i){s&&s.m(o,i),an(o,e,i)},p(o,[i]){r===(r=t(o))&&s?s.p(o,i):(s&&s.d(1),s=r&&r(o),s&&(s.c(),s.m(e.parentNode,e)))},i:$o,o:$o,d(o){s&&s.d(o),o&&$e(e)}}}function X0(n,e,t){let{firstCond:r}=e,{secondCond:s}=e,{firstText:o="Model loading"}=e,{secondText:i="Waiting for detection"}=e;return n.$$set=a=>{"firstCond"in a&&t(0,r=a.firstCond),"secondCond"in a&&t(1,s=a.secondCond),"firstText"in a&&t(2,o=a.firstText),"secondText"in a&&t(3,i=a.secondText)},[r,s,o,i]}class RV extends tc{constructor(e){super(),nc(this,e,X0,q0,rc,{firstCond:0,secondCond:1,firstText:2,secondText:3})}}var un=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function OV(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Y0(n){var e=n.default;if(typeof e=="function"){var t=function(){return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}),t}var Q0={};(function(){var n;function e(f){var v=0;return function(){return v<f.length?{done:!1,value:f[v++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(f,v,C){return f==Array.prototype||f==Object.prototype||(f[v]=C.value),f};function r(f){f=[typeof globalThis=="object"&&globalThis,f,typeof window=="object"&&window,typeof self=="object"&&self,typeof un=="object"&&un];for(var v=0;v<f.length;++v){var C=f[v];if(C&&C.Math==Math)return C}throw Error("Cannot find global object")}var s=r(this);function o(f,v){if(v)e:{var C=s;f=f.split(".");for(var E=0;E<f.length-1;E++){var R=f[E];if(!(R in C))break e;C=C[R]}f=f[f.length-1],E=C[f],v=v(E),v!=E&&v!=null&&t(C,f,{configurable:!0,writable:!0,value:v})}}o("Symbol",function(f){function v(B){if(this instanceof v)throw new TypeError("Symbol is not a constructor");return new C(E+(B||"")+"_"+R++,B)}function C(B,P){this.g=B,t(this,"description",{configurable:!0,writable:!0,value:P})}if(f)return f;C.prototype.toString=function(){return this.g};var E="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",R=0;return v}),o("Symbol.iterator",function(f){if(f)return f;f=Symbol("Symbol.iterator");for(var v="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),C=0;C<v.length;C++){var E=s[v[C]];typeof E=="function"&&typeof E.prototype[f]!="function"&&t(E.prototype,f,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return f});function i(f){return f={next:f},f[Symbol.iterator]=function(){return this},f}function a(f){var v=typeof Symbol<"u"&&Symbol.iterator&&f[Symbol.iterator];return v?v.call(f):{next:e(f)}}function c(f){if(!(f instanceof Array)){f=a(f);for(var v,C=[];!(v=f.next()).done;)C.push(v.value);f=C}return f}var u=typeof Object.create=="function"?Object.create:function(f){function v(){}return v.prototype=f,new v},l;if(typeof Object.setPrototypeOf=="function")l=Object.setPrototypeOf;else{var h;e:{var p={a:!0},d={};try{d.__proto__=p,h=d.a;break e}catch{}h=!1}l=h?function(f,v){if(f.__proto__=v,f.__proto__!==v)throw new TypeError(f+" is not extensible");return f}:null}var m=l;function g(f,v){if(f.prototype=u(v.prototype),f.prototype.constructor=f,m)m(f,v);else for(var C in v)if(C!="prototype")if(Object.defineProperties){var E=Object.getOwnPropertyDescriptor(v,C);E&&Object.defineProperty(f,C,E)}else f[C]=v[C];f.ea=v.prototype}function y(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function x(f){if(f.l)throw new TypeError("Generator is already running");f.l=!0}y.prototype.o=function(f){this.h=f};function w(f,v){f.j={U:v,V:!0},f.g=f.m||f.s}y.prototype.return=function(f){this.j={return:f},this.g=this.s};function S(f,v,C){return f.g=C,{value:v}}function $(f){this.g=new y,this.h=f}function N(f,v){x(f.g);var C=f.g.i;return C?_(f,"return"in C?C.return:function(E){return{value:E,done:!0}},v,f.g.return):(f.g.return(v),O(f))}function _(f,v,C,E){try{var R=v.call(f.g.i,C);if(!(R instanceof Object))throw new TypeError("Iterator result "+R+" is not an object");if(!R.done)return f.g.l=!1,R;var B=R.value}catch(P){return f.g.i=null,w(f.g,P),O(f)}return f.g.i=null,E.call(f.g,B),O(f)}function O(f){for(;f.g.g;)try{var v=f.h(f.g);if(v)return f.g.l=!1,{value:v.value,done:!1}}catch(C){f.g.h=void 0,w(f.g,C)}if(f.g.l=!1,f.g.j){if(v=f.g.j,f.g.j=null,v.V)throw v.U;return{value:v.return,done:!0}}return{value:void 0,done:!0}}function D(f){this.next=function(v){return x(f.g),f.g.i?v=_(f,f.g.i.next,v,f.g.o):(f.g.o(v),v=O(f)),v},this.throw=function(v){return x(f.g),f.g.i?v=_(f,f.g.i.throw,v,f.g.o):(w(f.g,v),v=O(f)),v},this.return=function(v){return N(f,v)},this[Symbol.iterator]=function(){return this}}function F(f){function v(E){return f.next(E)}function C(E){return f.throw(E)}return new Promise(function(E,R){function B(P){P.done?E(P.value):Promise.resolve(P.value).then(v,C).then(B,R)}B(f.next())})}function L(f){return F(new D(new $(f)))}o("Promise",function(f){function v(P){this.h=0,this.i=void 0,this.g=[],this.o=!1;var W=this.j();try{P(W.resolve,W.reject)}catch(U){W.reject(U)}}function C(){this.g=null}function E(P){return P instanceof v?P:new v(function(W){W(P)})}if(f)return f;C.prototype.h=function(P){if(this.g==null){this.g=[];var W=this;this.i(function(){W.l()})}this.g.push(P)};var R=s.setTimeout;C.prototype.i=function(P){R(P,0)},C.prototype.l=function(){for(;this.g&&this.g.length;){var P=this.g;this.g=[];for(var W=0;W<P.length;++W){var U=P[W];P[W]=null;try{U()}catch(X){this.j(X)}}}this.g=null},C.prototype.j=function(P){this.i(function(){throw P})},v.prototype.j=function(){function P(X){return function(ne){U||(U=!0,X.call(W,ne))}}var W=this,U=!1;return{resolve:P(this.C),reject:P(this.l)}},v.prototype.C=function(P){if(P===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(P instanceof v)this.F(P);else{e:switch(typeof P){case"object":var W=P!=null;break e;case"function":W=!0;break e;default:W=!1}W?this.v(P):this.m(P)}},v.prototype.v=function(P){var W=void 0;try{W=P.then}catch(U){this.l(U);return}typeof W=="function"?this.G(W,P):this.m(P)},v.prototype.l=function(P){this.s(2,P)},v.prototype.m=function(P){this.s(1,P)},v.prototype.s=function(P,W){if(this.h!=0)throw Error("Cannot settle("+P+", "+W+"): Promise already settled in state"+this.h);this.h=P,this.i=W,this.h===2&&this.D(),this.A()},v.prototype.D=function(){var P=this;R(function(){if(P.B()){var W=s.console;typeof W<"u"&&W.error(P.i)}},1)},v.prototype.B=function(){if(this.o)return!1;var P=s.CustomEvent,W=s.Event,U=s.dispatchEvent;return typeof U>"u"?!0:(typeof P=="function"?P=new P("unhandledrejection",{cancelable:!0}):typeof W=="function"?P=new W("unhandledrejection",{cancelable:!0}):(P=s.document.createEvent("CustomEvent"),P.initCustomEvent("unhandledrejection",!1,!0,P)),P.promise=this,P.reason=this.i,U(P))},v.prototype.A=function(){if(this.g!=null){for(var P=0;P<this.g.length;++P)B.h(this.g[P]);this.g=null}};var B=new C;return v.prototype.F=function(P){var W=this.j();P.J(W.resolve,W.reject)},v.prototype.G=function(P,W){var U=this.j();try{P.call(W,U.resolve,U.reject)}catch(X){U.reject(X)}},v.prototype.then=function(P,W){function U(se,J){return typeof se=="function"?function(ie){try{X(se(ie))}catch(ge){ne(ge)}}:J}var X,ne,le=new v(function(se,J){X=se,ne=J});return this.J(U(P,X),U(W,ne)),le},v.prototype.catch=function(P){return this.then(void 0,P)},v.prototype.J=function(P,W){function U(){switch(X.h){case 1:P(X.i);break;case 2:W(X.i);break;default:throw Error("Unexpected state: "+X.h)}}var X=this;this.g==null?B.h(U):this.g.push(U),this.o=!0},v.resolve=E,v.reject=function(P){return new v(function(W,U){U(P)})},v.race=function(P){return new v(function(W,U){for(var X=a(P),ne=X.next();!ne.done;ne=X.next())E(ne.value).J(W,U)})},v.all=function(P){var W=a(P),U=W.next();return U.done?E([]):new v(function(X,ne){function le(ie){return function(ge){se[ie]=ge,J--,J==0&&X(se)}}var se=[],J=0;do se.push(void 0),J++,E(U.value).J(le(se.length-1),ne),U=W.next();while(!U.done)})},v});function z(f,v){f instanceof String&&(f+="");var C=0,E=!1,R={next:function(){if(!E&&C<f.length){var B=C++;return{value:v(B,f[B]),done:!1}}return E=!0,{done:!0,value:void 0}}};return R[Symbol.iterator]=function(){return R},R}var j=typeof Object.assign=="function"?Object.assign:function(f,v){for(var C=1;C<arguments.length;C++){var E=arguments[C];if(E)for(var R in E)Object.prototype.hasOwnProperty.call(E,R)&&(f[R]=E[R])}return f};o("Object.assign",function(f){return f||j}),o("Object.is",function(f){return f||function(v,C){return v===C?v!==0||1/v===1/C:v!==v&&C!==C}}),o("Array.prototype.includes",function(f){return f||function(v,C){var E=this;E instanceof String&&(E=String(E));var R=E.length;for(C=C||0,0>C&&(C=Math.max(C+R,0));C<R;C++){var B=E[C];if(B===v||Object.is(B,v))return!0}return!1}}),o("String.prototype.includes",function(f){return f||function(v,C){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(v instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(v,C||0)!==-1}}),o("Array.prototype.keys",function(f){return f||function(){return z(this,function(v){return v})}});var K=this||self;function Y(f,v){f=f.split(".");var C=K;f[0]in C||typeof C.execScript>"u"||C.execScript("var "+f[0]);for(var E;f.length&&(E=f.shift());)f.length||v===void 0?C[E]&&C[E]!==Object.prototype[E]?C=C[E]:C=C[E]={}:C[E]=v}function te(f){K.setTimeout(function(){throw f},0)}function re(f){te(f)}function ae(f,v){re(Error("Invalid wire type: "+f+" (at position "+v+")"))}function be(){re(Error("Failed to read varint, encoding is invalid."))}function Ve(f,v){return v=String.fromCharCode.apply(null,v),f==null?v:f+v}var Kt,Nn=typeof TextDecoder<"u",Kn,os=typeof TextEncoder<"u";function Xs(f){if(os)f=(Kn||(Kn=new TextEncoder)).encode(f);else{var v=void 0;v=v===void 0?!1:v;for(var C=0,E=new Uint8Array(3*f.length),R=0;R<f.length;R++){var B=f.charCodeAt(R);if(128>B)E[C++]=B;else{if(2048>B)E[C++]=B>>6|192;else{if(55296<=B&&57343>=B){if(56319>=B&&R<f.length){var P=f.charCodeAt(++R);if(56320<=P&&57343>=P){B=1024*(B-55296)+P-56320+65536,E[C++]=B>>18|240,E[C++]=B>>12&63|128,E[C++]=B>>6&63|128,E[C++]=B&63|128;continue}else R--}if(v)throw Error("Found an unpaired surrogate");B=65533}E[C++]=B>>12|224,E[C++]=B>>6&63|128}E[C++]=B&63|128}}f=E.subarray(0,C)}return f}var vr={},In=null;function ru(f){var v;v===void 0&&(v=0),ou(),v=vr[v];for(var C=Array(Math.floor(f.length/3)),E=v[64]||"",R=0,B=0;R<f.length-2;R+=3){var P=f[R],W=f[R+1],U=f[R+2],X=v[P>>2];P=v[(P&3)<<4|W>>4],W=v[(W&15)<<2|U>>6],U=v[U&63],C[B++]=X+P+W+U}switch(X=0,U=E,f.length-R){case 2:X=f[R+1],U=v[(X&15)<<2]||E;case 1:f=f[R],C[B]=v[f>>2]+v[(f&3)<<4|X>>4]+U+E}return C.join("")}function su(f){var v=f.length,C=3*v/4;C%3?C=Math.floor(C):"=.".indexOf(f[v-1])!=-1&&(C="=.".indexOf(f[v-2])!=-1?C-2:C-1);var E=new Uint8Array(C),R=0;return Yx(f,function(B){E[R++]=B}),E.subarray(0,R)}function Yx(f,v){function C(U){for(;E<f.length;){var X=f.charAt(E++),ne=In[X];if(ne!=null)return ne;if(!/^[\s\xa0]*$/.test(X))throw Error("Unknown base64 encoding at char: "+X)}return U}ou();for(var E=0;;){var R=C(-1),B=C(0),P=C(64),W=C(64);if(W===64&&R===-1)break;v(R<<2|B>>4),P!=64&&(v(B<<4&240|P>>2),W!=64&&v(P<<6&192|W))}}function ou(){if(!In){In={};for(var f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),v=["+/=","+/","-_=","-_.","-_"],C=0;5>C;C++){var E=f.concat(v[C].split(""));vr[C]=E;for(var R=0;R<E.length;R++){var B=E[R];In[B]===void 0&&(In[B]=R)}}}}var mi=typeof Uint8Array=="function",Ys;function iu(f){if(this.g=f,f!==null&&f.length===0)throw Error("ByteString should be constructed with non-empty values")}iu.prototype.toJSON=function(){if(this.g==null)var f="";else f=this.g,f=this.g=f==null||typeof f=="string"?f:mi&&f instanceof Uint8Array?ru(f):null;return f};var Qx=typeof Uint8Array.prototype.slice=="function";function au(f,v,C){return v===C?Ys||(Ys=new Uint8Array(0)):Qx?f.slice(v,C):new Uint8Array(f.subarray(v,C))}var mn=0,_n=0;function Zx(f){if(f.constructor===Uint8Array)return f;if(f.constructor===ArrayBuffer)return new Uint8Array(f);if(f.constructor===Array)return new Uint8Array(f);if(f.constructor===String)return su(f);if(f.constructor===iu){if(f.g==null)var v=Ys||(Ys=new Uint8Array(0));else{v=Uint8Array;var C=f.g;C=C==null||mi&&C!=null&&C instanceof Uint8Array?C:typeof C=="string"?su(C):null,f=f.g=C,v=new v(f)}return v}if(f instanceof Uint8Array)return new Uint8Array(f.buffer,f.byteOffset,f.byteLength);throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers")}function cu(f,v){v=v===void 0?{}:v,v=v.u===void 0?!1:v.u,this.h=null,this.g=this.i=this.l=0,this.j=!1,this.u=v,f&&gi(this,f)}function gi(f,v){f.h=Zx(v),f.l=0,f.i=f.h.length,f.g=f.l}cu.prototype.reset=function(){this.g=this.l};function Nt(f){f.g>f.i&&(f.j=!0,re(Error("Tried to read past the end of the data "+f.g+" > "+f.i)))}function is(f){var v=f.h,C=v[f.g],E=C&127;return 128>C?(f.g+=1,Nt(f),E):(C=v[f.g+1],E|=(C&127)<<7,128>C?(f.g+=2,Nt(f),E):(C=v[f.g+2],E|=(C&127)<<14,128>C?(f.g+=3,Nt(f),E):(C=v[f.g+3],E|=(C&127)<<21,128>C?(f.g+=4,Nt(f),E):(C=v[f.g+4],E|=(C&15)<<28,128>C?(f.g+=5,Nt(f),E>>>0):(f.g+=5,128<=v[f.g++]&&128<=v[f.g++]&&128<=v[f.g++]&&128<=v[f.g++]&&128<=v[f.g++]?(f.j=!0,be(),E):(Nt(f),E))))))}var uu=[];function yi(){this.g=new Uint8Array(64),this.h=0}function rn(f,v){if(!(f.h+1<f.g.length)){var C=f.g;f.g=new Uint8Array(Math.ceil(1+2*f.g.length)),f.g.set(C)}f.g[f.h++]=v}yi.prototype.length=function(){return this.h},yi.prototype.end=function(){var f=this.g,v=this.h;return this.h=0,au(f,0,v)};function wr(f,v){for(;127<v;)rn(f,v&127|128),v>>>=7;rn(f,v)}function lu(f){var v={},C=v.N===void 0?!1:v.N;this.m={u:v.u===void 0?!1:v.u},this.N=C,v=this.m,uu.length?(C=uu.pop(),v&&(C.u=v.u),f&&gi(C,f),f=C):f=new cu(f,v),this.g=f,this.l=this.g.g,this.h=this.i=-1,this.j=!1}lu.prototype.reset=function(){this.g.reset(),this.h=this.i=-1};function hu(f){var v=f.g;if((v=v.g==v.i)||(v=f.j)||(v=f.g,v=v.j||0>v.g||v.g>v.i),v)return!1;f.l=f.g.g;var C=is(f.g);return v=C>>>3,C&=7,0<=C&&5>=C?(f.i=v,f.h=C,!0):(f.j=!0,ae(C,f.l),!1)}function as(f){switch(f.h){case 0:if(f.h!=0)as(f);else e:{f=f.g;for(var v=f.g,C=0;10>C;C++){if((f.h[v]&128)===0){f.g=v+1,Nt(f);break e}v++}f.j=!0,be()}break;case 1:f=f.g,f.g+=8,Nt(f);break;case 2:f.h!=2?as(f):(v=is(f.g),f=f.g,f.g+=v,Nt(f));break;case 5:f=f.g,f.g+=4,Nt(f);break;case 3:v=f.i;do{if(!hu(f)){f.j=!0,re(Error("Unmatched start-group tag: stream EOF"));break}if(f.h==4){f.i!=v&&(f.j=!0,re(Error("Unmatched end-group tag")));break}as(f)}while(1);break;default:f.j=!0,ae(f.h,f.l)}}function pu(f,v,C){f.N||(f=au(f.g.h,C,f.g.g),(C=v.m)?C.push(f):v.m=[f])}var Qs=[];function Jx(){this.h=[],this.i=0,this.g=new yi}function Zs(f,v){v.length!==0&&(f.h.push(v),f.i+=v.length)}function du(f,v,C){wr(f.g,8*v+2),wr(f.g,C.length),Zs(f,f.g.end()),Zs(f,C)}var Js=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol(void 0):void 0;function fu(f,v){Object.isFrozen(f)||(Js?f[Js]|=v:f.g!==void 0?f.g|=v:Object.defineProperties(f,{g:{value:v,configurable:!0,writable:!0,enumerable:!1}}))}function xi(f){if(!f)return 0;var v;return Js?v=f[Js]:v=f.g,v==null?0:v}function cs(f){return Array.isArray(f)&&fu(f,1),f}function mu(f){if(!Array.isArray(f))throw Error("cannot mark non-array as immutable");fu(f,2)}function gu(f){return f!==null&&typeof f=="object"&&f.constructor===Object}function e0(f){switch(typeof f){case"number":return isFinite(f)?f:String(f);case"object":return mi&&f!=null&&f instanceof Uint8Array?ru(f):f;default:return f}}function yu(f,v){if(f!=null)return Array.isArray(f)||gu(f)?xu(f,v):v(f)}function xu(f,v){if(Array.isArray(f)){for(var C=Array(f.length),E=0;E<f.length;E++)C[E]=yu(f[E],v);return xi(f)&1&&cs(C),C}C={};for(E in f)C[E]=yu(f[E],v);return C}var bu;function It(f,v,C){var E=bu;bu=null,f||(f=E),E=this.constructor.ca,f||(f=E?[E]:[]),this.j=(E?0:-1)-(this.constructor.aa||0),this.i=null,this.g=f;e:{if(E=this.g.length,f=E-1,E&&(E=this.g[f],gu(E))){this.l=f-this.j,this.h=E;break e}v!==void 0&&-1<v?(this.l=Math.max(v,f+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(C)for(v=0;v<C.length;v++)f=C[v],f<this.l?(f+=this.j,(E=this.g[f])?cs(E):this.g[f]=eo):(vu(this),(E=this.h[f])?cs(E):this.h[f]=eo)}var eo=Object.freeze(cs([]));function vu(f){var v=f.l+f.j;f.g[v]||(f.h=f.g[v]={})}function _t(f,v,C){return v===-1?null:(C===void 0?0:C)||v>=f.l?f.h?f.h[v]:void 0:f.g[v+f.j]}function wu(f,v,C){C=C===void 0?!0:C;var E=E===void 0?!1:E,R=_t(f,v,E);return R==null&&(R=eo),R===eo?(R=cs([]),Ue(f,v,R,E)):C&&Array.isArray(R)&&xi(R)&2&&(R=R.slice(),Ue(f,v,R,E)),R}function sn(f,v,C){return f=_t(f,v),f=f==null?f:+f,f==null?C===void 0?0:C:f}function Ue(f,v,C,E){(E===void 0?0:E)||v>=f.l?(vu(f),f.h[v]=C):f.g[v+f.j]=C}function bi(f,v,C){f.i||(f.i={});var E=f.i[C];if(!E){var R=wu(f,C,!1);E=[];for(var B=Array.isArray(R)?!!(xi(R)&2):!1,P=0;P<R.length;P++)E[P]=new v(R[P]),B&&mu(E[P].g);B&&(mu(E),Object.freeze(E)),f.i[C]=E}return E}function Cu(f,v,C,E,R){var B=bi(f,E,v);C=C||new E,f=wu(f,v),R!=null?(B.splice(R,0,C),f.splice(R,0,Cr(C))):(B.push(C),f.push(Cr(C)))}It.prototype.toJSON=function(){var f=Cr(this);return xu(f,e0)};function Cr(f){if(f.i)for(var v in f.i){var C=f.i[v];if(Array.isArray(C))for(var E=0;E<C.length;E++)C[E]&&Cr(C[E]);else C&&Cr(C)}return f.g}It.prototype.toString=function(){return Cr(this).toString()};function Su(f,v){return f=_t(f,v),f==null?0:f}function Tu(f,v){return f=_t(f,v),f==null?"":f}function vi(f,v){if(f=f.m){Zs(v,v.g.end());for(var C=0;C<f.length;C++)Zs(v,f[C])}}function t0(f){var v=f[0];switch(f.length){case 2:var C=f[1];return function(U,X,ne){return v(U,X,ne,C)};case 3:var E=f[1],R=f[2];return function(U,X,ne){return v(U,X,ne,E,R)};case 4:var B=f[1],P=f[2],W=f[3];return function(U,X,ne){return v(U,X,ne,B,P,W)};default:throw Error("unsupported number of parameters, expected [2-4], got "+f.length)}}function us(f,v,C){for(;hu(v)&&v.h!=4;){var E=v.i,R=C[E];if(R){if(Array.isArray(R)&&(R=C[E]=t0(R)),!R(v,f,E)){E=v,R=f;var B=E.l;as(E),pu(E,R,B)}}else E=v,R=f,B=E.l,as(E),pu(E,R,B)}return f}function wi(f,v){var C=new Jx;if(v(f,C),f=C.i+C.g.length(),f===0)C=new Uint8Array(0);else{f=new Uint8Array(f);for(var E=C.h,R=E.length,B=v=0;B<R;B++){var P=E[B];P.length!==0&&(f.set(P,v),v+=P.length)}E=C.g,R=E.h,R!==0&&(f.set(E.g.subarray(0,R),v),E.h=0),C.h=[f],C=f}return C}function Ci(f,v,C){if(Qs.length){var E=Qs.pop();f&&(gi(E.g,f),E.i=-1,E.h=-1),f=E}else f=new lu(f);try{return C(new v,f)}finally{v=f.g,v.h=null,v.l=0,v.i=0,v.g=0,v.j=!1,v.u=!1,f.i=-1,f.h=-1,f.j=!1,100>Qs.length&&Qs.push(f)}}function qt(f,v,C){if(v=_t(v,C),v!=null){wr(f.g,8*C+5),f=f.g;var E=v;E=(C=0>E?1:0)?-E:E,E===0?0<1/E?mn=_n=0:(_n=0,mn=2147483648):isNaN(E)?(_n=0,mn=2147483647):34028234663852886e22<E?(_n=0,mn=(C<<31|2139095040)>>>0):11754943508222875e-54>E?(E=Math.round(E/Math.pow(2,-149)),_n=0,mn=(C<<31|E)>>>0):(v=Math.floor(Math.log(E)/Math.LN2),E*=Math.pow(2,-v),E=Math.round(8388608*E),16777216<=E&&++v,_n=0,mn=(C<<31|v+127<<23|E&8388607)>>>0),C=mn,rn(f,C>>>0&255),rn(f,C>>>8&255),rn(f,C>>>16&255),rn(f,C>>>24&255)}}function Xt(f,v,C){if(f.h!==5)return!1;f=f.g;var E=f.h[f.g],R=f.h[f.g+1],B=f.h[f.g+2],P=f.h[f.g+3];return f.g+=4,Nt(f),R=(E<<0|R<<8|B<<16|P<<24)>>>0,f=2*(R>>31)+1,E=R>>>23&255,R&=8388607,Ue(v,C,E==255?R?NaN:1/0*f:E==0?f*Math.pow(2,-149)*R:f*Math.pow(2,E-150)*(R+Math.pow(2,23))),!0}function n0(f,v,C){if(f.h!==0)return!1;for(var E=f.g,R=128,B=0,P=f=0;4>P&&128<=R;P++)R=E.h[E.g++],B|=(R&127)<<7*P;if(128<=R&&(R=E.h[E.g++],B|=(R&127)<<28,f|=(R&127)>>4),128<=R)for(P=0;5>P&&128<=R;P++)R=E.h[E.g++],f|=(R&127)<<7*P+3;return 128>R?(E=B>>>0,R=f>>>0,(f=R&2147483648)&&(E=~E+1>>>0,R=~R>>>0,E==0&&(R=R+1>>>0)),E=4294967296*R+(E>>>0),f=f?-E:E):(E.j=!0,be(),f=void 0),Ue(v,C,f),!0}function r0(f,v,C){return f.h!==0?!1:(Ue(v,C,is(f.g)),!0)}function $u(f,v,C){if(f.h!==2)return!1;var E=is(f.g);f=f.g;var R=f.g;f.g+=E,Nt(f),f=f.h;var B;if(Nn)(B=Kt)||(B=Kt=new TextDecoder("utf-8",{fatal:!1})),B=B.decode(f.subarray(R,R+E));else{E=R+E;for(var P=[],W=null,U,X,ne;R<E;)U=f[R++],128>U?P.push(U):224>U?R>=E?P.push(65533):(X=f[R++],194>U||(X&192)!==128?(R--,P.push(65533)):P.push((U&31)<<6|X&63)):240>U?R>=E-1?P.push(65533):(X=f[R++],(X&192)!==128||U===224&&160>X||U===237&&160<=X||((B=f[R++])&192)!==128?(R--,P.push(65533)):P.push((U&15)<<12|(X&63)<<6|B&63)):244>=U?R>=E-2?P.push(65533):(X=f[R++],(X&192)!==128||(U<<28)+(X-144)>>30!==0||((B=f[R++])&192)!==128||((ne=f[R++])&192)!==128?(R--,P.push(65533)):(U=(U&7)<<18|(X&63)<<12|(B&63)<<6|ne&63,U-=65536,P.push((U>>10&1023)+55296,(U&1023)+56320))):P.push(65533),8192<=P.length&&(W=Ve(W,P),P.length=0);B=Ve(W,P)}return Ue(v,C,B),!0}function Eu(f,v,C,E,R){if(f.h!==2)return!1;var B=new E,P=f.g.i,W=is(f.g),U=f.g.g+W;if(f.g.i=U,R(B,f),R=U-f.g.g,R!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+(W+" bytes, instead read "+(W-R)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return f.g.g=U,f.g.i=P,Cu(v,C,B,E,void 0),!0}function ls(f){It.call(this,f)}var ku;g(ls,It);function s0(f,v){var C=_t(f,1);if(C!=null&&C!=null){wr(v.g,8);var E=v.g;if(0<=C)wr(E,C);else{for(var R=0;9>R;R++)rn(E,C&127|128),C>>=7;rn(E,1)}}qt(v,f,2),E=_t(f,3),E!=null&&du(v,3,Xs(E)),E=_t(f,4),E!=null&&du(v,4,Xs(E)),vi(f,v)}function o0(f,v){return us(f,v,ku||(ku={1:r0,2:Xt,3:$u,4:$u}))}function Si(f){It.call(this,f,-1,a0)}var Nu;g(Si,It),Si.prototype.addClassification=function(f,v){return Cu(this,1,f,ls,v),this};function i0(f,v){return us(f,v,Nu||(Nu={1:[Eu,ls,o0]}))}var a0=[1];function to(f){It.call(this,f)}var Iu;g(to,It);function c0(f,v){qt(v,f,1),qt(v,f,2),qt(v,f,3),qt(v,f,4),qt(v,f,5),vi(f,v)}function u0(f,v){return us(f,v,Iu||(Iu={1:Xt,2:Xt,3:Xt,4:Xt,5:Xt}))}function _u(f){It.call(this,f,-1,h0)}var Ru;g(_u,It);function l0(f,v){return us(f,v,Ru||(Ru={1:[Eu,to,u0]}))}var h0=[1];function Ti(f){It.call(this,f)}var Ou;g(Ti,It);function p0(f,v){qt(v,f,1),qt(v,f,2),qt(v,f,3),qt(v,f,4),qt(v,f,5);var C=_t(f,6);if(C!=null&&C!=null){wr(v.g,48);var E=v.g,R=C;C=0>R,R=Math.abs(R);var B=R>>>0;for(R=Math.floor((R-B)/4294967296),R>>>=0,C&&(R=~R>>>0,B=(~B>>>0)+1,4294967295<B&&(B=0,R++,4294967295<R&&(R=0))),mn=B,_n=R,C=mn,B=_n;0<B||127<C;)rn(E,C&127|128),C=(C>>>7|B<<25)>>>0,B>>>=7;rn(E,C)}vi(f,v)}function d0(f,v){return us(f,v,Ou||(Ou={1:Xt,2:Xt,3:Xt,4:Xt,5:Xt,6:n0}))}function Au(f,v,C){if(C=f.createShader(C===0?f.VERTEX_SHADER:f.FRAGMENT_SHADER),f.shaderSource(C,v),f.compileShader(C),!f.getShaderParameter(C,f.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+f.getShaderInfoLog(C));return C}function f0(f){return bi(f,ls,1).map(function(v){return{index:Su(v,1),X:sn(v,2),label:_t(v,3)!=null?Tu(v,3):void 0,displayName:_t(v,4)!=null?Tu(v,4):void 0}})}function m0(f){return{x:sn(f,1),y:sn(f,2),z:sn(f,3),visibility:_t(f,4)!=null?sn(f,4):void 0}}function $i(f){return bi(Ci(f,_u,l0),to,1).map(m0)}function Ei(f,v){this.h=f,this.g=v,this.l=0}function Du(f,v,C){return g0(f,v),typeof f.g.canvas.transferToImageBitmap=="function"?Promise.resolve(f.g.canvas.transferToImageBitmap()):C?Promise.resolve(f.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(f.g.canvas):(f.i===void 0&&(f.i=document.createElement("canvas")),new Promise(function(E){f.i.height=f.g.canvas.height,f.i.width=f.g.canvas.width,f.i.getContext("2d",{}).drawImage(f.g.canvas,0,0,f.g.canvas.width,f.g.canvas.height),E(f.i)}))}function g0(f,v){var C=f.g;if(f.m===void 0){var E=Au(C,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),R=Au(C,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),B=C.createProgram();if(C.attachShader(B,E),C.attachShader(B,R),C.linkProgram(B),!C.getProgramParameter(B,C.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+C.getProgramInfoLog(B));E=f.m=B,C.useProgram(E),R=C.getUniformLocation(E,"sampler0"),f.j={I:C.getAttribLocation(E,"aVertex"),H:C.getAttribLocation(E,"aTex"),da:R},f.s=C.createBuffer(),C.bindBuffer(C.ARRAY_BUFFER,f.s),C.enableVertexAttribArray(f.j.I),C.vertexAttribPointer(f.j.I,2,C.FLOAT,!1,0,0),C.bufferData(C.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),C.STATIC_DRAW),C.bindBuffer(C.ARRAY_BUFFER,null),f.o=C.createBuffer(),C.bindBuffer(C.ARRAY_BUFFER,f.o),C.enableVertexAttribArray(f.j.H),C.vertexAttribPointer(f.j.H,2,C.FLOAT,!1,0,0),C.bufferData(C.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),C.STATIC_DRAW),C.bindBuffer(C.ARRAY_BUFFER,null),C.uniform1i(R,0)}E=f.j,C.useProgram(f.m),C.canvas.width=v.width,C.canvas.height=v.height,C.viewport(0,0,v.width,v.height),C.activeTexture(C.TEXTURE0),f.h.bindTexture2d(v.glName),C.enableVertexAttribArray(E.I),C.bindBuffer(C.ARRAY_BUFFER,f.s),C.vertexAttribPointer(E.I,2,C.FLOAT,!1,0,0),C.enableVertexAttribArray(E.H),C.bindBuffer(C.ARRAY_BUFFER,f.o),C.vertexAttribPointer(E.H,2,C.FLOAT,!1,0,0),C.bindFramebuffer(C.DRAW_FRAMEBUFFER?C.DRAW_FRAMEBUFFER:C.FRAMEBUFFER,null),C.clearColor(0,0,0,0),C.clear(C.COLOR_BUFFER_BIT),C.colorMask(!0,!0,!0,!0),C.drawArrays(C.TRIANGLE_FAN,0,4),C.disableVertexAttribArray(E.I),C.disableVertexAttribArray(E.H),C.bindBuffer(C.ARRAY_BUFFER,null),f.h.bindTexture2d(0)}function y0(f){this.g=f}var x0=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function b0(f,v){return v+f}function Pu(f,v){window[f]=v}function v0(f){var v=document.createElement("script");return v.setAttribute("src",f),v.setAttribute("crossorigin","anonymous"),new Promise(function(C){v.addEventListener("load",function(){C()},!1),v.addEventListener("error",function(){C()},!1),document.body.appendChild(v)})}function w0(){return L(function(f){switch(f.g){case 1:return f.m=2,S(f,WebAssembly.instantiate(x0),4);case 4:f.g=3,f.m=0;break;case 2:return f.m=0,f.j=null,f.return(!1);case 3:return f.return(!0)}})}function ki(f){if(this.g=f,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=f&&f.locateFile||b0,typeof window=="object")var v=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")v=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=v,f.options){v=a(Object.keys(f.options));for(var C=v.next();!C.done;C=v.next()){C=C.value;var E=f.options[C].default;E!==void 0&&(this.j[C]=typeof E=="function"?E():E)}}}n=ki.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function C0(f){var v,C,E,R,B,P,W,U,X,ne,le;return L(function(se){switch(se.g){case 1:return f.R?(v=f.g.files===void 0?[]:typeof f.g.files=="function"?f.g.files(f.j):f.g.files,S(se,w0(),2)):se.return();case 2:if(C=se.h,typeof window=="object")return Pu("createMediapipeSolutionsWasm",{locateFile:f.locateFile}),Pu("createMediapipeSolutionsPackedAssets",{locateFile:f.locateFile}),P=v.filter(function(J){return J.data!==void 0}),W=v.filter(function(J){return J.data===void 0}),U=Promise.all(P.map(function(J){var ie=no(f,J.url);if(J.path!==void 0){var ge=J.path;ie=ie.then(function(Oe){return f.overrideFile(ge,Oe),Promise.resolve(Oe)})}return ie})),X=Promise.all(W.map(function(J){return J.simd===void 0||J.simd&&C||!J.simd&&!C?v0(f.locateFile(J.url,f.S)):Promise.resolve()})).then(function(){var J,ie,ge;return L(function(Oe){if(Oe.g==1)return J=window.createMediapipeSolutionsWasm,ie=window.createMediapipeSolutionsPackedAssets,ge=f,S(Oe,J(ie),2);ge.h=Oe.h,Oe.g=0})}),ne=function(){return L(function(J){return f.g.graph&&f.g.graph.url?J=S(J,no(f,f.g.graph.url),0):(J.g=0,J=void 0),J})}(),S(se,Promise.all([X,U,ne]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return E=v.filter(function(J){return J.simd===void 0||J.simd&&C||!J.simd&&!C}).map(function(J){return f.locateFile(J.url,f.S)}),importScripts.apply(null,c(E)),R=f,S(se,createMediapipeSolutionsWasm(Module),6);case 6:R.h=se.h,f.l=new OffscreenCanvas(1,1),f.h.canvas=f.l,B=f.h.GL.createContext(f.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),f.h.GL.makeContextCurrent(B),se.g=4;break;case 7:if(f.l=document.createElement("canvas"),le=f.l.getContext("webgl2",{}),!le&&(le=f.l.getContext("webgl",{}),!le))return alert("Failed to create WebGL canvas context when passing video frame."),se.return();f.D=le,f.h.canvas=f.l,f.h.createContext(f.l,!0,!0,{});case 4:f.i=new f.h.SolutionWasm,f.R=!1,se.g=0}})}function S0(f){var v,C,E,R,B,P,W,U;return L(function(X){if(X.g==1){if(f.g.graph&&f.g.graph.url&&f.P===f.g.graph.url)return X.return();if(f.o=!0,!f.g.graph||!f.g.graph.url){X.g=2;return}return f.P=f.g.graph.url,S(X,no(f,f.g.graph.url),3)}for(X.g!=2&&(v=X.h,f.i.loadGraph(v)),C=a(Object.keys(f.B)),E=C.next();!E.done;E=C.next())R=E.value,f.i.overrideFile(R,f.B[R]);if(f.B={},f.g.listeners)for(B=a(f.g.listeners),P=B.next();!P.done;P=B.next())W=P.value,k0(f,W);U=f.j,f.j={},f.setOptions(U),X.g=0})}n.reset=function(){var f=this;return L(function(v){f.i&&(f.i.reset(),f.m={},f.s={}),v.g=0})},n.setOptions=function(f,v){var C=this;if(v=v||this.g.options){for(var E=[],R=[],B={},P=a(Object.keys(f)),W=P.next();!W.done;B={K:B.K,L:B.L},W=P.next()){var U=W.value;U in this.j&&this.j[U]===f[U]||(this.j[U]=f[U],W=v[U],W!==void 0&&(W.onChange&&(B.K=W.onChange,B.L=f[U],E.push(function(X){return function(){var ne;return L(function(le){if(le.g==1)return S(le,X.K(X.L),2);ne=le.h,ne===!0&&(C.o=!0),le.g=0})}}(B))),W.graphOptionXref&&(U={valueNumber:W.type===1?f[U]:0,valueBoolean:W.type===0?f[U]:!1,valueString:W.type===2?f[U]:""},W=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),W.graphOptionXref),U),R.push(W))))}(E.length!==0||R.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(R),this.v=(this.v===void 0?[]:this.v).concat(E))}};function T0(f){var v,C,E,R,B,P,W;return L(function(U){switch(U.g){case 1:if(!f.o)return U.return();if(!f.v){U.g=2;break}v=a(f.v),C=v.next();case 3:if(C.done){U.g=5;break}return E=C.value,S(U,E(),4);case 4:C=v.next(),U.g=3;break;case 5:f.v=void 0;case 2:if(f.A){for(R=new f.h.GraphOptionChangeRequestList,B=a(f.A),P=B.next();!P.done;P=B.next())W=P.value,R.push_back(W);f.i.changeOptions(R),R.delete(),f.A=void 0}f.o=!1,U.g=0}})}n.initialize=function(){var f=this;return L(function(v){return v.g==1?S(v,C0(f),2):v.g!=3?S(v,S0(f),3):S(v,T0(f),0)})};function no(f,v){var C,E;return L(function(R){return v in f.F?R.return(f.F[v]):(C=f.locateFile(v,""),E=fetch(C).then(function(B){return B.arrayBuffer()}),f.F[v]=E,R.return(E))})}n.overrideFile=function(f,v){this.i?this.i.overrideFile(f,v):this.B[f]=v},n.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},n.send=function(f,v){var C=this,E,R,B,P,W,U,X,ne,le;return L(function(se){switch(se.g){case 1:return C.g.inputs?(E=1e3*(v==null?performance.now():v),S(se,C.C,2)):se.return();case 2:return S(se,C.initialize(),3);case 3:for(R=new C.h.PacketDataList,B=a(Object.keys(f)),P=B.next();!P.done;P=B.next())if(W=P.value,U=C.g.inputs[W]){e:{var J=f[W];switch(U.type){case"video":var ie=C.m[U.stream];if(ie||(ie=new Ei(C.h,C.D),C.m[U.stream]=ie),ie.l===0&&(ie.l=ie.h.createTexture()),typeof HTMLVideoElement<"u"&&J instanceof HTMLVideoElement)var ge=J.videoWidth,Oe=J.videoHeight;else typeof HTMLImageElement<"u"&&J instanceof HTMLImageElement?(ge=J.naturalWidth,Oe=J.naturalHeight):(ge=J.width,Oe=J.height);Oe={glName:ie.l,width:ge,height:Oe},ge=ie.g,ge.canvas.width=Oe.width,ge.canvas.height=Oe.height,ge.activeTexture(ge.TEXTURE0),ie.h.bindTexture2d(ie.l),ge.texImage2D(ge.TEXTURE_2D,0,ge.RGBA,ge.RGBA,ge.UNSIGNED_BYTE,J),ie.h.bindTexture2d(0),ie=Oe;break e;case"detections":for(ie=C.m[U.stream],ie||(ie=new y0(C.h),C.m[U.stream]=ie),ie.data||(ie.data=new ie.g.DetectionListData),ie.data.reset(J.length),Oe=0;Oe<J.length;++Oe){ge=J[Oe];var Ne=ie.data,Ye=Ne.setBoundingBox,Rt=Oe,dt=ge.T,xe=new Ti;if(Ue(xe,1,dt.Y),Ue(xe,2,dt.Z),Ue(xe,3,dt.height),Ue(xe,4,dt.width),Ue(xe,5,dt.rotation),Ue(xe,6,dt.W),dt=wi(xe,p0),Ye.call(Ne,Rt,dt),ge.O)for(Ne=0;Ne<ge.O.length;++Ne){xe=ge.O[Ne];var ze=!!xe.visibility;Ye=ie.data,Rt=Ye.addNormalizedLandmark,dt=Oe,xe=Object.assign(Object.assign({},xe),{visibility:ze?xe.visibility:0}),ze=new to,Ue(ze,1,xe.x),Ue(ze,2,xe.y),Ue(ze,3,xe.z),xe.visibility&&Ue(ze,4,xe.visibility),xe=wi(ze,c0),Rt.call(Ye,dt,xe)}if(ge.M)for(Ne=0;Ne<ge.M.length;++Ne)Ye=ie.data,Rt=Ye.addClassification,dt=Oe,xe=ge.M[Ne],ze=new ls,Ue(ze,2,xe.X),xe.index&&Ue(ze,1,xe.index),xe.label&&Ue(ze,3,xe.label),xe.displayName&&Ue(ze,4,xe.displayName),xe=wi(ze,s0),Rt.call(Ye,dt,xe)}ie=ie.data;break e;default:ie={}}}switch(X=ie,ne=U.stream,U.type){case"video":R.pushTexture2d(Object.assign(Object.assign({},X),{stream:ne,timestamp:E}));break;case"detections":le=X,le.stream=ne,le.timestamp=E,R.pushDetectionList(le);break;default:throw Error("Unknown input config type: '"+U.type+"'")}}return C.i.send(R),S(se,C.C,4);case 4:R.delete(),se.g=0}})};function $0(f,v,C){var E,R,B,P,W,U,X,ne,le,se,J,ie,ge,Oe;return L(function(Ne){switch(Ne.g){case 1:if(!C)return Ne.return(v);for(E={},R=0,B=a(Object.keys(C)),P=B.next();!P.done;P=B.next())W=P.value,U=C[W],typeof U!="string"&&U.type==="texture"&&v[U.stream]!==void 0&&++R;1<R&&(f.G=!1),X=a(Object.keys(C)),P=X.next();case 2:if(P.done){Ne.g=4;break}if(ne=P.value,le=C[ne],typeof le=="string")return ge=E,Oe=ne,S(Ne,E0(f,ne,v[le]),14);if(se=v[le.stream],le.type==="detection_list"){if(se){for(var Ye=se.getRectList(),Rt=se.getLandmarksList(),dt=se.getClassificationsList(),xe=[],ze=0;ze<Ye.size();++ze){var Rn=Ci(Ye.get(ze),Ti,d0);Rn={T:{Y:sn(Rn,1),Z:sn(Rn,2),height:sn(Rn,3),width:sn(Rn,4),rotation:sn(Rn,5,0),W:Su(Rn,6)},O:$i(Rt.get(ze)),M:f0(Ci(dt.get(ze),Si,i0))},xe.push(Rn)}Ye=xe}else Ye=[];E[ne]=Ye,Ne.g=7;break}if(le.type==="proto_list"){if(se){for(Ye=Array(se.size()),Rt=0;Rt<se.size();Rt++)Ye[Rt]=se.get(Rt);se.delete()}else Ye=[];E[ne]=Ye,Ne.g=7;break}if(se===void 0){Ne.g=3;break}if(le.type==="float_list"){E[ne]=se,Ne.g=7;break}if(le.type==="proto"){E[ne]=se,Ne.g=7;break}if(le.type!=="texture")throw Error("Unknown output config type: '"+le.type+"'");return J=f.s[ne],J||(J=new Ei(f.h,f.D),f.s[ne]=J),S(Ne,Du(J,se,f.G),13);case 13:ie=Ne.h,E[ne]=ie;case 7:le.transform&&E[ne]&&(E[ne]=le.transform(E[ne])),Ne.g=3;break;case 14:ge[Oe]=Ne.h;case 3:P=X.next(),Ne.g=2;break;case 4:return Ne.return(E)}})}function E0(f,v,C){var E;return L(function(R){return typeof C=="number"||C instanceof Uint8Array||C instanceof f.h.Uint8BlobList?R.return(C):C instanceof f.h.Texture2dDataOut?(E=f.s[v],E||(E=new Ei(f.h,f.D),f.s[v]=E),R.return(Du(E,C,f.G))):R.return(void 0)})}function k0(f,v){for(var C=v.name||"$",E=[].concat(c(v.wants)),R=new f.h.StringList,B=a(v.wants),P=B.next();!P.done;P=B.next())R.push_back(P.value);B=f.h.PacketListener.implement({onResults:function(W){for(var U={},X=0;X<v.wants.length;++X)U[E[X]]=W.get(X);var ne=f.listeners[C];ne&&(f.C=$0(f,U,v.outs).then(function(le){le=ne(le);for(var se=0;se<v.wants.length;++se){var J=U[E[se]];typeof J=="object"&&J.hasOwnProperty&&J.hasOwnProperty("delete")&&J.delete()}le&&(f.C=le)}))}}),f.i.attachMultiListener(R,B),R.delete()}n.onResults=function(f,v){this.listeners[v||"$"]=f},Y("Solution",ki),Y("OptionType",{BOOL:0,NUMBER:1,$:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Fu(f){switch(f===void 0&&(f=0),f){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Lu(f){var v=this;f=f||{},this.g=new ki({locateFile:f.locateFile,files:function(C){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Fu(C.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:$i},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:$i},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(C){var E,R,B;return L(function(P){return P.g==1?(E=Fu(C),R="third_party/mediapipe/modules/pose_landmark/"+E,S(P,no(v.g,E),2)):(B=P.h,v.g.overrideFile(R,B),P.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Lu.prototype,n.reset=function(){this.g.reset()},n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(f){this.g.onResults(f)},n.initialize=function(){var f=this;return L(function(v){return S(v,f.g.initialize(),0)})},n.send=function(f,v){var C=this;return L(function(E){return S(E,C.g.send(f,v),0)})},n.setOptions=function(f){this.g.setOptions(f)},Y("Pose",Lu),Y("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),Y("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),Y("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),Y("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),Y("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),Y("VERSION","0.5.1635988162")}).call(un);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0=1e-7,J0=1e-4;class e1{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Ah{refCount(e){return vt("refCount")}incRef(e){return vt("incRef")}timerAvailable(){return!0}time(e){return vt("time")}read(e){return vt("read")}readSync(e){return vt("readSync")}readToGPU(e,t){return vt("readToGPU")}numDataIds(){return vt("numDataIds")}disposeData(e,t){return vt("disposeData")}write(e,t,r){return vt("write")}move(e,t,r,s,o){return vt("move")}memory(){return vt("memory")}floatPrecision(){return vt("floatPrecision")}epsilon(){return this.floatPrecision()===32?Z0:J0}dispose(){return vt("dispose")}}function vt(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function No(n,e,t){return Math.max(n,Math.min(e,t))}function ac(n){return n%2===0?n:n+1}function hs(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function t1(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function k(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Tt(n,e,t=""){k(Me(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Kr(n){k(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Pr(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||hn(n)&&!t)for(let r=0;r<n.length;++r)Pr(n[r],e,t);else e.push(n);return e}function G(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Me(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Fr(n){return n%1===0}function Zi(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function _r(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function zu(n,e=s=>0,t,r=setTimeout){return new Promise((s,o)=>{let i=0;const a=()=>{if(n()){s();return}i++;const c=e(i);if(t!=null&&i>=t){o();return}r(a,c)};a()})}function n1(n,e){let t=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function je(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),k(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),k(n.every(r=>Fr(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function zn(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:je(e,n).sort();let i=0;for(let a=0;a<n.length;++a){if(o!=null){if(o[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(o[i]==null||o[i]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),o[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function Cn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function pt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function r1(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function s1(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function o1(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function hn(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function Ji(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function i1(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function qo(n){return typeof n=="string"||n instanceof String}function a1(n){return typeof n=="boolean"}function c1(n){return typeof n=="number"}function Xo(n){return Array.isArray(n)?Xo(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":c1(n)?"float32":qo(n)?"string":a1(n)?"bool":"float32"}function Wu(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ea(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function qe(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function Dh(n,e,t,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=t[n+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((c,u)=>c*u)*(r?2:1);for(let c=0;c<o;c++)s[c]=Dh(n+c*a,i,t,r)}return s}function ta(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,o)=>s*o)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Dh(0,n,e,t)}function Ph(n,e){const t=Mn(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Mn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Fh(n){n.forEach(e=>{k(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function na(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function cc(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function Lr(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gu="tfjsflags";class u1{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=l1,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Lr(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Gu in e&&e[Gu].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=p1(s,o)})}}function l1(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(h1(e,r[0],r[1]),r.join("="))),e}function h1(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function p1(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function M(){return Lh}let Lh=null;function d1(n){Lh=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ni;function Mh(){if(Ni==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Ni=n}return Ni}function f1(){const n=Mh();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function uc(n,e){const t=f1();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const Bh="Abs",Vh="Acos",Uh="Acosh",lc="Add",zh="AddN",Wh="All",Gh="Any",jh="ArgMax",Hh="ArgMin",Kh="Asin",qh="Asinh",Xh="Atan",Yh="Atanh",Qh="Atan2",Zh="AvgPool",m1="AvgPoolGrad",Jh="AvgPool3D",g1="AvgPool3DGrad",ep="BatchMatMul",tp="BatchToSpaceND",np="Bincount",rp="BroadcastArgs",hc="Cast",sp="Ceil",op="ClipByValue",ip="Complex",ap="ComplexAbs",cp="Concat",up="Conv2D",lp="Conv2DBackpropFilter",hp="Conv2DBackpropInput",pp="Conv3D",y1="Conv3DBackpropFilterV2",dp="Conv3DBackpropInputV2",fp="Cos",mp="Cosh",gp="Cumprod",yp="Cumsum",xp="CropAndResize",bp="DenseBincount",vp="DepthToSpace",wp="DepthwiseConv2dNative",Cp="DepthwiseConv2dNativeBackpropFilter",Sp="DepthwiseConv2dNativeBackpropInput",Tp="Diag",$p="Dilation2D",Ep="RealDiv",kp="Einsum",Np="Elu",x1="EluGrad",Ip="Erf",_p="Equal",Rp="Exp",Op="ExpandDims",Ap="Expm1",Dp="FFT",Pp="Fill",Fp="FlipLeftRight",Lp="Floor",Mp="FloorDiv",Bp="FusedBatchNorm",Vp="GatherV2",Up="GatherNd",zp="Greater",Wp="GreaterEqual",pc="Identity",Gp="IFFT",jp="Imag",Hp="IsFinite",Kp="IsInf",qp="IsNan",Xp="LeakyRelu",Yp="Less",Qp="LessEqual",Zp="LinSpace",Jp="Log",ed="Log1p",td="LogicalAnd",nd="LogicalNot",rd="LogicalOr",sd="LRN",b1="LRNGrad",od="Max",id="Maximum",ad="MaxPool",v1="MaxPoolGrad",cd="MaxPool3D",w1="MaxPool3DGrad",ud="MaxPoolWithArgmax",ld="Mean",hd="Min",pd="Minimum",dd="MirrorPad",fd="Mod",md="Multinomial",gd="Multiply",yd="Neg",xd="NotEqual",bd="NonMaxSuppressionV3",vd="NonMaxSuppressionV4",wd="NonMaxSuppressionV5",Cd="OnesLike",Sd="OneHot",Td="Pack",$d="PadV2",Ed="Pow",kd="Prelu",Nd="Prod",Id="RaggedGather",_d="RaggedTensorToTensor",Rd="Range",Od="Real",Ad="Reciprocal",Dd="Relu",Pd="Reshape",Fd="ResizeNearestNeighbor",C1="ResizeNearestNeighborGrad",Ld="ResizeBilinear",S1="ResizeBilinearGrad",Md="Relu6",Bd="Reverse",Vd="Round",Ud="Rsqrt",zd="ScatterNd",Wd="SearchSorted",Gd="Select",jd="Selu",Hd="Slice",Kd="Sin",qd="Sinh",Xd="Sign",Yd="Sigmoid",Qd="Softplus",Zd="Sqrt",Jd="Sum",ef="SpaceToBatchND",tf="SplitV",nf="Softmax",rf="SparseFillEmptyRows",sf="SparseReshape",of="SparseSegmentMean",af="SparseSegmentSum",cf="SparseToDense",uf="SquaredDifference",T1="Square",lf="StridedSlice",hf="StringNGrams",pf="StringSplit",df="StringToHashBucketFast",ff="Sub",mf="Tan",gf="Tanh",dc="Tile",yf="TopK",xf="Transform",po="Transpose",bf="Unique",vf="Unpack",wf="UnsortedSegmentSum",Cf="ZerosLike",Sf="Step",ra="FromPixels",Tf="RotateWithOffset",sa="_FusedMatMul",oa="FusedConv2D",ia="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jt(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(...n)}function $1(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Io=uc("kernelRegistry",()=>new Map),E1=uc("gradRegistry",()=>new Map);function aa(n,e){const t=$f(n,e);return Io.get(t)}function ju(n){return E1.get(n)}function Hu(n){const e=Io.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===n&&t.push(i)}return t}function k1(n){const{kernelName:e,backendName:t}=n,r=$f(e,t);Io.has(r)&&Jt(`The kernel '${e}' for backend '${t}' is already registered`),Io.set(r,n)}function $f(n,e){return`${e}_${n}`}var ca=_e,Mt=null;try{Mt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function _e(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}_e.prototype.__isLong__;Object.defineProperty(_e.prototype,"__isLong__",{value:!0});function xt(n){return(n&&n.__isLong__)===!0}_e.isLong=xt;var Ku={},qu={};function dr(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=qu[n],r)?r:(t=Re(n,(n|0)<0?-1:0,!0),s&&(qu[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=Ku[n],r)?r:(t=Re(n,n<0?-1:0,!1),s&&(Ku[n]=t),t))}_e.fromInt=dr;function Bt(n,e){if(isNaN(n))return e?Jn:Vt;if(e){if(n<0)return Jn;if(n>=Ef)return If}else{if(n<=-Yu)return mt;if(n+1>=Yu)return Nf}return n<0?Bt(-n,e).neg():Re(n%Mr|0,n/Mr|0,e)}_e.fromNumber=Bt;function Re(n,e,t){return new _e(n,e,t)}_e.fromBits=Re;var _o=Math.pow;function fc(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Vt;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return fc(n.substring(1),e,t).neg();for(var s=Bt(_o(t,8)),o=Vt,i=0;i<n.length;i+=8){var a=Math.min(8,n.length-i),c=parseInt(n.substring(i,i+a),t);if(a<8){var u=Bt(_o(t,a));o=o.mul(u).add(Bt(c))}else o=o.mul(s),o=o.add(Bt(c))}return o.unsigned=e,o}_e.fromString=fc;function tn(n,e){return typeof n=="number"?Bt(n,e):typeof n=="string"?fc(n,e):Re(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}_e.fromValue=tn;var Xu=1<<16,N1=1<<24,Mr=Xu*Xu,Ef=Mr*Mr,Yu=Ef/2,Qu=dr(N1),Vt=dr(0);_e.ZERO=Vt;var Jn=dr(0,!0);_e.UZERO=Jn;var Nr=dr(1);_e.ONE=Nr;var kf=dr(1,!0);_e.UONE=kf;var ua=dr(-1);_e.NEG_ONE=ua;var Nf=Re(-1,2147483647,!1);_e.MAX_VALUE=Nf;var If=Re(-1,-1,!0);_e.MAX_UNSIGNED_VALUE=If;var mt=Re(0,-2147483648,!1);_e.MIN_VALUE=mt;var H=_e.prototype;H.toInt=function(){return this.unsigned?this.low>>>0:this.low};H.toNumber=function(){return this.unsigned?(this.high>>>0)*Mr+(this.low>>>0):this.high*Mr+(this.low>>>0)};H.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(mt)){var t=Bt(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=Bt(_o(e,6),this.unsigned),i=this,a="";;){var c=i.div(o),u=i.sub(c.mul(o)).toInt()>>>0,l=u.toString(e);if(i=c,i.isZero())return l+a;for(;l.length<6;)l="0"+l;a=""+l+a}};H.getHighBits=function(){return this.high};H.getHighBitsUnsigned=function(){return this.high>>>0};H.getLowBits=function(){return this.low};H.getLowBitsUnsigned=function(){return this.low>>>0};H.getNumBitsAbs=function(){if(this.isNegative())return this.eq(mt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};H.isZero=function(){return this.high===0&&this.low===0};H.eqz=H.isZero;H.isNegative=function(){return!this.unsigned&&this.high<0};H.isPositive=function(){return this.unsigned||this.high>=0};H.isOdd=function(){return(this.low&1)===1};H.isEven=function(){return(this.low&1)===0};H.equals=function(e){return xt(e)||(e=tn(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};H.eq=H.equals;H.notEquals=function(e){return!this.eq(e)};H.neq=H.notEquals;H.ne=H.notEquals;H.lessThan=function(e){return this.comp(e)<0};H.lt=H.lessThan;H.lessThanOrEqual=function(e){return this.comp(e)<=0};H.lte=H.lessThanOrEqual;H.le=H.lessThanOrEqual;H.greaterThan=function(e){return this.comp(e)>0};H.gt=H.greaterThan;H.greaterThanOrEqual=function(e){return this.comp(e)>=0};H.gte=H.greaterThanOrEqual;H.ge=H.greaterThanOrEqual;H.compare=function(e){if(xt(e)||(e=tn(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};H.comp=H.compare;H.negate=function(){return!this.unsigned&&this.eq(mt)?mt:this.not().add(Nr)};H.neg=H.negate;H.add=function(e){xt(e)||(e=tn(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,i=e.high>>>16,a=e.high&65535,c=e.low>>>16,u=e.low&65535,l=0,h=0,p=0,d=0;return d+=o+u,p+=d>>>16,d&=65535,p+=s+c,h+=p>>>16,p&=65535,h+=r+a,l+=h>>>16,h&=65535,l+=t+i,l&=65535,Re(p<<16|d,l<<16|h,this.unsigned)};H.subtract=function(e){return xt(e)||(e=tn(e)),this.add(e.neg())};H.sub=H.subtract;H.multiply=function(e){if(this.isZero())return Vt;if(xt(e)||(e=tn(e)),Mt){var t=Mt.mul(this.low,this.high,e.low,e.high);return Re(t,Mt.get_high(),this.unsigned)}if(e.isZero())return Vt;if(this.eq(mt))return e.isOdd()?mt:Vt;if(e.eq(mt))return this.isOdd()?mt:Vt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Qu)&&e.lt(Qu))return Bt(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,o=this.low>>>16,i=this.low&65535,a=e.high>>>16,c=e.high&65535,u=e.low>>>16,l=e.low&65535,h=0,p=0,d=0,m=0;return m+=i*l,d+=m>>>16,m&=65535,d+=o*l,p+=d>>>16,d&=65535,d+=i*u,p+=d>>>16,d&=65535,p+=s*l,h+=p>>>16,p&=65535,p+=o*u,h+=p>>>16,p&=65535,p+=i*c,h+=p>>>16,p&=65535,h+=r*l+s*u+o*c+i*a,h&=65535,Re(d<<16|m,h<<16|p,this.unsigned)};H.mul=H.multiply;H.divide=function(e){if(xt(e)||(e=tn(e)),e.isZero())throw Error("division by zero");if(Mt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Mt.div_u:Mt.div_s)(this.low,this.high,e.low,e.high);return Re(t,Mt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Jn:Vt;var r,s,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Jn;if(e.gt(this.shru(1)))return kf;o=Jn}else{if(this.eq(mt)){if(e.eq(Nr)||e.eq(ua))return mt;if(e.eq(mt))return Nr;var i=this.shr(1);return r=i.div(e).shl(1),r.eq(Vt)?e.isNegative()?Nr:ua:(s=this.sub(e.mul(r)),o=r.add(s.div(e)),o)}else if(e.eq(mt))return this.unsigned?Jn:Vt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=Vt}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),c=a<=48?1:_o(2,a-48),u=Bt(r),l=u.mul(e);l.isNegative()||l.gt(s);)r-=c,u=Bt(r,this.unsigned),l=u.mul(e);u.isZero()&&(u=Nr),o=o.add(u),s=s.sub(l)}return o};H.div=H.divide;H.modulo=function(e){if(xt(e)||(e=tn(e)),Mt){var t=(this.unsigned?Mt.rem_u:Mt.rem_s)(this.low,this.high,e.low,e.high);return Re(t,Mt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};H.mod=H.modulo;H.rem=H.modulo;H.not=function(){return Re(~this.low,~this.high,this.unsigned)};H.and=function(e){return xt(e)||(e=tn(e)),Re(this.low&e.low,this.high&e.high,this.unsigned)};H.or=function(e){return xt(e)||(e=tn(e)),Re(this.low|e.low,this.high|e.high,this.unsigned)};H.xor=function(e){return xt(e)||(e=tn(e)),Re(this.low^e.low,this.high^e.high,this.unsigned)};H.shiftLeft=function(e){return xt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Re(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Re(0,this.low<<e-32,this.unsigned)};H.shl=H.shiftLeft;H.shiftRight=function(e){return xt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Re(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Re(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};H.shr=H.shiftRight;H.shiftRightUnsigned=function(e){if(xt(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return Re(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Re(t,0,this.unsigned):Re(t>>>e-32,0,this.unsigned)};H.shru=H.shiftRightUnsigned;H.shr_u=H.shiftRightUnsigned;H.toSigned=function(){return this.unsigned?Re(this.low,this.high,!1):this};H.toUnsigned=function(){return this.unsigned?this:Re(this.low,this.high,!0)};H.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};H.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};H.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};_e.fromBytes=function(e,t,r){return r?_e.fromBytesLE(e,t):_e.fromBytesBE(e,t)};_e.fromBytesLE=function(e,t){return new _e(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};_e.fromBytesBE=function(e,t){return new _e(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const I1=Oh({__proto__:null,default:ca},[ca]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qn=ca||I1;function Yo(n){return Qn.fromString(n,!0,16)}const _f=Yo("c3a5c85c97cb3127"),Yn=Yo("b492b66fbe98f273"),st=Yo("9ae16a3b2f90404f");function la(n){return n.xor(n.shru(47))}function Rf(n,e,t){const r=n.slice(e,e+t);return Qn.fromBytes(Array.from(r),!0,!0)}function Ee(n,e){return Rf(n,e,8)}function Zu(n,e){return Rf(n,e,4)}function We(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Fn(n,e,t=Yo("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function _1(n,e,t,r,s,o){s=s.add(n),o=We(o.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(t),o=o.add(We(s,44)),[s.add(r),o.add(i)]}function ro(n,e,t,r){return _1(Ee(n,e),Ee(n,e+8),Ee(n,e+16),Ee(n,e+24),t,r)}function R1(n,e=n.length){if(e>=8){const t=st.add(e*2),r=Ee(n,0).add(st),s=Ee(n,e-8),o=We(s,37).mul(t).add(r),i=We(r,25).add(s).mul(t);return Fn(o,i,t)}if(e>=4){const t=st.add(e*2),r=Zu(n,0);return Fn(r.shl(3).add(e),Zu(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],o=t+(r<<8),i=e+(s<<2);return la(st.mul(o).xor(_f.mul(i))).mul(st)}return st}function O1(n,e=n.length){const t=st.add(e*2),r=Ee(n,0).mul(Yn),s=Ee(n,8),o=Ee(n,e-8).mul(t),i=Ee(n,e-16).mul(st);return Fn(We(r.add(s),43).add(We(o,30)).add(i),r.add(We(s.add(st),18)).add(o),t)}function A1(n,e=n.length){const t=st.add(e*2),r=Ee(n,0).mul(st),s=Ee(n,8),o=Ee(n,e-8).mul(t),i=Ee(n,e-16).mul(st),a=We(r.add(s),43).add(We(o,30)).add(i),c=Fn(a,r.add(We(s.add(st),18)).add(o),t),u=Ee(n,16).mul(t),l=Ee(n,24),h=a.add(Ee(n,e-32)).mul(t),p=c.add(Ee(n,e-24)).mul(t);return Fn(We(u.add(l),43).add(We(h,30)).add(p),u.add(We(l.add(r),18)).add(h),t)}function D1(n,e=n.length){const t=Qn.fromNumber(81,!0);if(e<=32)return e<=16?R1(n,e):O1(n,e);if(e<=64)return A1(n,e);let r=t,s=t.mul(Yn).add(113),o=la(s.mul(st).add(113)).mul(st),i=[Qn.UZERO,Qn.UZERO],a=[Qn.UZERO,Qn.UZERO];r=r.mul(st).add(Ee(n,0));let c=0;const u=(e-1>>6)*64,l=u+(e-1&63)-63;do r=We(r.add(s).add(i[0]).add(Ee(n,c+8)),37).mul(Yn),s=We(s.add(i[1]).add(Ee(n,c+48)),42).mul(Yn),r=r.xor(a[1]),s=s.add(i[0]).add(Ee(n,c+40)),o=We(o.add(a[0]),33).mul(Yn),i=ro(n,c,i[1].mul(Yn),r.add(a[0])),a=ro(n,c+32,o.add(a[1]),s.add(Ee(n,c+16))),[o,r]=[r,o],c+=64;while(c!==u);const h=Yn.add(o.and(255).shl(1));return c=l,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=We(r.add(s).add(i[0]).add(Ee(n,c+8)),37).mul(h),s=We(s.add(i[1]).add(Ee(n,c+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Ee(n,c+40))),o=We(o.add(a[0]),33).mul(h),i=ro(n,c,i[1].mul(h),r.add(a[0])),a=ro(n,c+32,o.add(a[1]),s.add(Ee(n,c+16))),[o,r]=[r,o],Fn(Fn(i[0],a[0],h).add(la(s).mul(_f)).add(o),Fn(i[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr(n,e){return e==="string"?sr(n):Qo([n],e)}function P1(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Qo(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Pr(n)),M().getBool("DEBUG")&&r1(n,e),P1(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Yt(){return M().platform.now()}function sr(n,e="utf-8"){return e=e||"utf-8",M().platform.encode(n,e)}function Br(n,e="utf-8"){return e=e||"utf-8",M().platform.decode(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F1{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new M1)}profileKernel(e,t,r){let s;const o=()=>{s=r()};let i;const a=Yt();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Yt()-a})}if(M().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const l=s[u];l.data().then(h=>{L1(h,l.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:o,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),s,i]).then(c=>{this.logger.logKernelProfile(t,a,c[0],c[1],o,c[2])})})}}function L1(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class M1{logKernelProfile(e,t,r,s,o,i){const a=typeof s=="number"?_r(`${s}ms`,9):s.error,c=_r(e,25),u=t.rank,l=t.size,h=_r(t.shape.toString(),14);let p="";for(const d in o){const m=o[d];if(m!=null){const g=m.shape||t.shape,y=g.length;p+=`${d}: ${y}D ${y>0?g:""} `}}console.log(`%c${c}	%c${a}	%c${u}D ${h}	%c${l}	%c${p}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B1(n,e,t){const r={},s={};for(let c=0;c<e.length;c++)r[e[c].id]=!0;for(let c=0;c<n.length;c++){const u=n[c],l=u.inputs;for(const h in l){const p=l[h];let d=!1;for(let m=0;m<e.length;m++)if(r[p.id]){u.outputs.forEach(g=>r[g.id]=!0),d=!0,s[u.id]=!0;break}if(d)break}}const o={};o[t.id]=!0;const i={};for(let c=n.length-1;c>=0;c--){const u=n[c],l=u.inputs;for(let h=0;h<u.outputs.length;h++)if(o[u.outputs[h].id]){for(const p in l)o[l[p].id]=!0,i[u.id]=!0;break}}const a=[];for(let c=0;c<n.length;c++){const u=n[c];if(s[u.id]&&i[u.id]){const l={};for(const p in u.inputs){const d=u.inputs[p];r[d.id]&&(l[p]=d)}const h=Object.assign({},u);h.inputs=l,h.outputs=u.outputs,a.push(h)}}return a}function V1(n,e,t,r){for(let s=e.length-1;s>=0;s--){const o=e[s],i=[];if(o.outputs.forEach(c=>{const u=n[c.id];u!=null?i.push(u):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const c in o.inputs){if(!(c in a))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[c]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${u.dtype}'`);const l=o.inputs[c];if(!Me(u.shape,l.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${c}' has shape '${u.shape}', which does not match the shape of the input '${l.shape}'`);if(n[l.id]==null)n[l.id]=u;else{const h=n[l.id];n[l.id]=r(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ju=20,ps=3,Ii=7;function U1(n,e,t,r){const s=qe(e),o=z1(n,e,t,s),i=e.length,a=fo(n,e,t,s,o),c=["Tensor"];return r&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${i}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(a.map(u=>"    "+u).join(`
`)),c.join(`
`)}function z1(n,e,t,r){const s=G(e),o=r[r.length-1],i=new Array(o).fill(0),a=e.length,c=t==="complex64"?ys(n):n;if(a>1)for(let u=0;u<s/o;u++){const l=u*o;for(let h=0;h<o;h++)i[h]=Math.max(i[h],gs(c[l+h],0,t).length)}return i}function gs(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(Ii))} + ${parseFloat(n[1].toFixed(Ii))}j`:qo(n)?r=`'${n}'`:t==="bool"?r=Of(n):r=parseFloat(n.toFixed(Ii)).toString(),_r(r,e)}function Of(n){return n===0?"false":"true"}function fo(n,e,t,r,s,o=!0){const i=t==="complex64"?2:1,a=e[0],c=e.length;if(c===0){if(t==="complex64"){const g=ys(n);return[gs(g[0],0,t)]}return t==="bool"?[Of(n[0])]:[n[0].toString()]}if(c===1){if(a>Ju){const y=ps*i;let x=Array.from(n.slice(0,y)),w=Array.from(n.slice((a-ps)*i,a*i));return t==="complex64"&&(x=ys(x),w=ys(w)),["["+x.map((S,$)=>gs(S,s[$],t)).join(", ")+", ..., "+w.map((S,$)=>gs(S,s[a-ps+$],t)).join(", ")+"]"]}const g=t==="complex64"?ys(n):Array.from(n);return["["+g.map((y,x)=>gs(y,s[x],t)).join(", ")+"]"]}const u=e.slice(1),l=r.slice(1),h=r[0]*i,p=[];if(a>Ju){for(let g=0;g<ps;g++){const y=g*h,x=y+h;p.push(...fo(n.slice(y,x),u,t,l,s,!1))}p.push("...");for(let g=a-ps;g<a;g++){const y=g*h,x=y+h;p.push(...fo(n.slice(y,x),u,t,l,s,g===a-1))}}else for(let g=0;g<a;g++){const y=g*h,x=y+h;p.push(...fo(n.slice(y,x),u,t,l,s,g===a-1))}const d=c===2?",":"";p[0]="["+p[0]+d;for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+d;let m=`,
`;for(let g=2;g<c;g++)m+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":m),p}function ys(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $s{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=G(e),r!=null){const s=r.length;k(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||pt(t,this.size),this.strides=qe(e)}set(e,...t){t.length===0&&(t=[0]),k(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Qt().makeTensor(this.values,this.shape,this.dtype)}}let Qt=null,Er=null;function W1(n){Qt=n}function G1(n){Er=n}class Fe{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=G(e),this.strides=qe(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Er.buffer(this.shape,this.dtype,e)}bufferSync(){return Er.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ta(this.shape,e,this.dtype==="complex64")}arraySync(){return ta(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Qt().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>Br(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Qt().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Qt().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Br(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Qt().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Qt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Er.print(this,e)}clone(){return this.throwIfDisposed(),Er.clone(this)}toString(e=!1){const t=this.dataSync();return U1(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Er.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Qt().makeVariable(this,e,t,r)}}Object.defineProperty(Fe,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function j1(){return uc("Tensor",()=>Fe)}j1();class ha extends Fe{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Me(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Qt().disposeTensor(this),this.dataId=e.dataId,Qt().incRef(this,null)}dispose(){Qt().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(ha,Symbol.hasInstance,{value:n=>n instanceof Fe&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var el;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(el||(el={}));var pa;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(pa||(pa={}));var da;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(da||(da={}));var fa;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(fa||(fa={}));var ma;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(ma||(ma={}));const H1={float32:fa,int32:pa,bool:da,complex64:ma};function pn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return H1[n][e]}function mc(n){return pn(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(n,e){if(n.dtype===e.dtype)return[n,e];const t=pn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function K1(n,e){k(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Af(n){const e=[];return Df(n,e,new Set),e}function Df(n,e,t){if(n==null)return;if(n instanceof Fe){e.push(n);return}if(!q1(n))return;const r=n;for(const s in r){const o=r[s];t.has(o)||(t.add(o),Df(o,e,t))}}function q1(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _i(n){return n.kernelName!=null}class tl{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Vr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new tl}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Jt(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new F1(this.backendInstance),!0}setupRegisteredKernels(){Hu(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Hu(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof Ah)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Jt(`Initialization of backend ${e} failed`),Jt(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Jt(`Initialization of backend ${e} failed`),Jt(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,o=this.readSync(t),i=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Vr.nextTensorId++}nextVariableId(){return Vr.nextVariableId++}clone(e){const t=A.runKernel(pc,{x:e}),r={x:e},s=i=>({x:()=>{const a="float32",c={x:i},u={dtype:a};return A.runKernel(hc,c,u)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,o,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(aa(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let o=0;r.forEach(c=>{o+=c.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let c;const u=_i(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(_i(e)){const{kernelName:m,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;const x=aa(m,this.backendName);k(x!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),a=()=>{const w=this.backend.numDataIds();c=x.kernelFunc({inputs:g,attrs:y,backend:this.backend});const S=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,w,S);const $=S.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(s){const N=this.getTensorsForGradient(m,g,$);r=this.saveTensorsForBackwardMode(N)}return $}}else{const{forwardFunc:m}=e,g=y=>{!s||(r=y.map(x=>this.keep(this.clone(x))))};a=()=>{const y=this.backend.numDataIds();c=this.tidy(()=>m(this.backend,g));const x=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,x),x}}const{inputs:l,attrs:h}=e,p=_i(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(u,l,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(u,l,t,p,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(m=>l[m]!=null?l[m].shape:null),outputShapes:t.map(m=>m.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=ju(e);if(s!=null){const o=s.inputsToSave||[],i=s.outputsToSave||[];let a;s.saveAllInputs?(k(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=o.map(u=>t[u]);const c=r.filter((u,l)=>i[l]);return a.concat(c)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&qo(e[0])&&(o=e.map(c=>sr(c)));const i=s.write(o,t,r),a=new Fe(t,r,i,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const c=this.state.tensorInfo.get(i),u=i1(o);this.state.numBytes+=u-c.bytes,c.bytes=u}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const o={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:o}=e,i=new Fe(s,o,r,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new ha(e,t,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Ji(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof ha||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Ji(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:o},c=ju(e);c!=null&&(s=c.gradFunc),s!=null&&(a.gradient=u=>(u=u.map((l,h)=>{if(l==null){const p=r[h],d=Mn(p.size,p.dtype);return this.makeTensor(d,p.shape,p.dtype)}return l}),s(u.length>1?u:u[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Af(e),r=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,t,r,s=!1){if(k(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));k(o instanceof Fe,()=>"The result y returned by f() must be a tensor.");const i=B1(this.state.activeTape,t,o);if(!s&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=r==null?X1(o.shape):r,V1(a,i,u=>this.tidy(u),Y1);const c=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const l of u.saved)l.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(e){return k(Wu(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{k(t.every(a=>a instanceof Fe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,c)=>{s[c]=a});const o=(a,c)=>(r=e(...t,c),k(r.value instanceof Fe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),k(Wu(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(a,c)=>{const u=r.gradFunc(a,c),l=Array.isArray(u)?u:[u];k(l.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),k(l.every(p=>p instanceof Fe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return l.forEach((p,d)=>{h[d]=()=>p}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Yt(),r=await this.backend.time(e);return r.wallMs=Yt()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new tl;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Vr.nextTensorId=0;Vr.nextVariableId=0;function X1(n){const e=Ph(G(n),"float32");return A.makeTensor(e,n,"float32")}function Pf(){const n=Mh();if(n._tfengine==null){const e=new u1(n);n._tfengine=new Vr(e)}return d1(n._tfengine.ENV),W1(()=>n._tfengine),n._tfengine}const A=Pf();function Y1(n,e){const t={a:n,b:e};return A.runKernel(lc,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1(){return typeof navigator<"u"&&navigator!=null}function Ff(n){if(n||Q1()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Lf(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gt=M();gt.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});gt.registerFlag("IS_BROWSER",()=>Lf());gt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");gt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));gt.registerFlag("PROD",()=>!1);gt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>gt.getBool("DEBUG"));gt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);gt.registerFlag("IS_TEST",()=>!1);gt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);gt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);gt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);gt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);gt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(n,e){let t=n;if(hn(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||hn(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&M().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Mf(n,r,[]),r}function Mf(n,e,t){if(t=t||[],!Array.isArray(n)&&!hn(n)){k(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}k(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),k(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)Mf(n[s],r,t.concat(s))}function nl(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function T(n,e,t,r="numeric"){if(n instanceof Fe)return nl(r,n.dtype,e,t),n;let s=Xo(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),nl(r,s,e,t),n==null||!hn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}const o=Wn(n,s);!hn(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?Qo(n,s):Pr(n,[],!0);return A.makeTensor(a,o,s)}function Ro(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>T(o,`${e}[${i}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bf="__op";function I(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Bf;const s=(...o)=>{A.startScope(t);try{const i=r(...o);return Lr(i)&&console.error("Cannot return a Promise inside of tidy."),A.endScope(i),i}catch(i){throw A.endScope(null),i}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1(n,e){const t=T(n,"real","complex"),r=T(e,"imag","complex");Tt(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return A.runKernel(ip,s)}const Bn=I({complex_:Z1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gn(n,e,t,r){if(r==null&&(r=Xo(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!hn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Fh(e);const s=G(e),o=G(t);k(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<t.length;++i){const a=t[i],c=i===t.length-1?a!==G(e.slice(i)):!0;k(t[i]===e[i]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!hn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Qo(n,r):Pr(n,[],!0),A.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(n,e,t){const r=Wn(n,t);return Gn(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ga={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oo=4;async function J1(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<s.length;++i){const a=s[i],c=Array.isArray(n)?n[i].tensor:n[a];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${c.dtype}`);const u={name:a,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const l=new Promise(async h=>{const p=await c.bytes(),d=p.reduce((y,x)=>y+x.length,0)+Oo*p.length,m=new Uint8Array(d);let g=0;for(let y=0;y<p.length;y++){const x=p[y],w=new Uint8Array(new Uint32Array([x.length]).buffer);m.set(w,g),g+=Oo,m.set(x,g),g+=x.length}h(m)});r.push(l)}else r.push(c.data());e!=null&&(u.group=e),t.push(u)}const o=await Promise.all(r);return{data:eb(o),specs:t}}function Vf(n,e){const t={};let r,s=0;for(const o of e){const i=o.name,a=o.dtype,c=o.shape,u=G(c);let l;if("quantization"in o){const h=o.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${o.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${o.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const p=ga[h.dtype],d=n.slice(s,s+u*p),m=h.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(a==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){l=new Float32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];l[g]=y*h.scale+h.min}}else if(h.dtype==="float16")r===void 0&&(r=ib()),l=r(m);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(a==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);l=new Int32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];l[g]=Math.round(y*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);s+=u*p}else if(a==="string"){const h=G(o.shape);l=[];for(let p=0;p<h;p++){const d=new Uint32Array(n.slice(s,s+Oo))[0];s+=Oo;const m=new Uint8Array(n.slice(s,s+d));l.push(m),s+=d}}else{const h=ga[a],p=n.slice(s,s+u*h);if(a==="float32")l=new Float32Array(p);else if(a==="int32")l=new Int32Array(p);else if(a==="bool")l=new Uint8Array(p);else if(a==="complex64"){l=new Float32Array(p);const d=new Float32Array(l.length/2),m=new Float32Array(l.length/2);for(let x=0;x<d.length;x++)d[x]=l[x*2],m[x]=l[x*2+1];const g=ln(d,c,"float32"),y=ln(m,c,"float32");t[i]=Bn(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);s+=u*h}a!=="complex64"&&(t[i]=ln(l,c,a))}return t}function eb(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const gc=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function rl(n){return gc?Buffer.byteLength(n):new Blob([n]).size}function tb(n){if(gc)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function nb(n){if(gc){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function yc(n){if(n.length===1)return n[0];let e=0;n.forEach(s=>{e+=s.byteLength});const t=new Uint8Array(e);let r=0;return n.forEach(s=>{t.set(new Uint8Array(s),r),r+=s.byteLength}),t.buffer}function sl(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function Uf(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function zf(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),r}async function xc(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),zf(n,t,r)}function Ms(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:rl(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:rl(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function Wf(n){const e=[];for(const t of n)e.push(...t.weights);return e}function rb(){const n=t=>{let r=t<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function sb(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function ob(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function ib(){const n=rb(),e=sb(),t=ob();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i],c=n[t[a>>10]+(a&1023)]+e[a>>10];o[i]=c}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class De{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return De.instance==null&&(De.instance=new De),De.instance}static registerSaveRouter(e){De.getInstance().saveRouters.push(e)}static registerLoadRouter(e){De.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return De.getHandlers(e,"save")}static getLoadHandlers(e,t){return De.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?De.getInstance().loadRouters:De.getInstance().saveRouters).forEach(i=>{const a=i(e,r);a!==null&&s.push(a)}),s}}const ab=n=>De.registerSaveRouter(n),cb=n=>De.registerLoadRouter(n),ub=n=>De.getSaveHandlers(n),lb=(n,e)=>De.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ya="tensorflowjs",xa=1,er="models_store",An="model_info_store";function Gf(){if(!M().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function ba(n){const e=n.result;e.createObjectStore(er,{keyPath:"modelPath"}),e.createObjectStore(An,{keyPath:"modelPath"})}class ar{constructor(e){if(this.indexedDB=Gf(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const o=this.indexedDB.open(ya,xa);o.onupgradeneeded=()=>ba(o),o.onsuccess=()=>{const i=o.result;if(t==null){const a=i.transaction(er,"readonly"),u=a.objectStore(er).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=l=>(i.close(),s(u.error)),a.oncomplete=()=>i.close()}else{const a=Ms(t),c=i.transaction(An,"readwrite");let u=c.objectStore(An);const l=u.put({modelPath:this.modelPath,modelArtifactsInfo:a});let h;l.onsuccess=()=>{h=i.transaction(er,"readwrite");const d=h.objectStore(er).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});d.onsuccess=()=>r({modelArtifactsInfo:a}),d.onerror=m=>{u=c.objectStore(An);const g=u.delete(this.modelPath);g.onsuccess=()=>(i.close(),s(d.error)),g.onerror=y=>(i.close(),s(d.error))}},l.onerror=p=>(i.close(),s(l.error)),c.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},o.onerror=i=>s(o.error)})}}ar.URL_SCHEME="indexeddb://";const jf=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ar.URL_SCHEME)?hb(n.slice(ar.URL_SCHEME.length)):null;De.registerSaveRouter(jf);De.registerLoadRouter(jf);function hb(n){return new ar(n)}function pb(n){return n.startsWith(ar.URL_SCHEME)?n.slice(ar.URL_SCHEME.length):n}class db{constructor(){this.indexedDB=Gf()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(ya,xa);r.onupgradeneeded=()=>ba(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(An,"readonly"),a=o.objectStore(An).getAll();a.onsuccess=()=>{const c={};for(const u of a.result)c[u.modelPath]=u.modelArtifactsInfo;e(c)},a.onerror=c=>(s.close(),t(a.error)),o.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=pb(e),new Promise((t,r)=>{const s=this.indexedDB.open(ya,xa);s.onupgradeneeded=()=>ba(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(An,"readwrite"),a=i.objectStore(An),c=a.get(e);let u;c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const l=a.delete(e),h=()=>{u=o.transaction(er,"readwrite");const d=u.objectStore(er).delete(e);d.onsuccess=()=>t(c.result.modelArtifactsInfo),d.onerror=m=>r(c.error)};l.onsuccess=h,l.onerror=p=>(h(),o.close(),r(c.error))}},c.onerror=l=>(o.close(),r(c.error)),i.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yn="/",kr="tensorflowjs_models",Hf="info",fb="model_topology",mb="weight_specs",gb="weight_data",yb="model_metadata";function Kf(n){return{info:[kr,n,Hf].join(yn),topology:[kr,n,fb].join(yn),weightSpecs:[kr,n,mb].join(yn),weightData:[kr,n,gb].join(yn),modelMetadata:[kr,n,yb].join(yn)}}function qf(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function xb(n){const e=n.split(yn);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(yn)}function bb(n){return n.startsWith(cr.URL_SCHEME)?n.slice(cr.URL_SCHEME.length):n}class cr{constructor(e){if(!M().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Kf(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Ms(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,tb(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw qf(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=nb(i),t}}cr.URL_SCHEME="localstorage://";const Xf=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(cr.URL_SCHEME)?vb(n.slice(cr.URL_SCHEME.length)):null;De.registerSaveRouter(Xf);De.registerLoadRouter(Xf);function vb(n){return new cr(n)}class wb{constructor(){k(M().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),k(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=kr+yn,r=yn+Hf;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(t)&&o.endsWith(r)){const i=xb(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=bb(e);const t=Kf(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return qf(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rr="://";class nt{constructor(){this.managers={}}static getInstance(){return nt.instance==null&&(nt.instance=new nt),nt.instance}static registerManager(e,t){k(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Rr)&&(e=e.slice(0,e.indexOf(Rr))),k(e.length>0,()=>"scheme must not be an empty string.");const r=nt.getInstance();k(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=nt.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(nt.getInstance().managers)}}function mo(n){if(n.indexOf(Rr)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${nt.getSchemes().join(",")}`);return{scheme:n.split(Rr)[0],path:n.split(Rr)[1]}}async function Yf(n,e,t=!1){k(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=De.getLoadHandlers(n);k(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),k(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],o=De.getSaveHandlers(e);k(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),k(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const i=o[0],a=mo(n).scheme,c=mo(n).path,u=a===mo(n).scheme,l=await s.load();t&&u&&await nt.getManager(a).removeModel(c);const h=await i.save(l);return t&&!u&&await nt.getManager(a).removeModel(c),h.modelArtifactsInfo}async function Cb(){const n=nt.getSchemes(),e={};for(const t of n){const r=await nt.getManager(t).listModels();for(const s in r){const o=t+Rr+s;e[o]=r[s]}}return e}async function Sb(n){const e=mo(n);return nt.getManager(e.scheme).removeModel(e.path)}async function Tb(n,e){return Yf(n,e,!1)}async function $b(n,e){return Yf(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eb{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(!window||!M().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}}if(M().get("IS_BROWSER")){M().setPlatform("browser",new Eb);try{nt.registerManager(cr.URL_SCHEME,new wb)}catch{}try{nt.registerManager(ar.URL_SCHEME,new db)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kb={importFetch:()=>require("node-fetch")};let Ri;class Nb{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return M().global.fetch!=null?M().global.fetch(e,t):(Ri==null&&(Ri=kb.importFetch()),Ri(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}M().get("IS_NODE")&&!M().get("IS_BROWSER")&&M().setPlatform("node",new Nb);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Le(n,e="float32",t){return e=e||"float32",Fh(n),new $s(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ib(n,e){const t=T(n,"x","cast");if(!s1(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return A.runKernel(hc,r,s)}const Ae=I({cast_:Ib});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _b(n){const t={x:T(n,"x","clone","string_or_numeric")};return A.runKernel(pc,t)}const Ln=I({clone_:_b});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qf(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Pf();const Rb={buffer:Le,cast:Ae,clone:Ln,print:Qf};G1(Rb);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ob="model",Ab=".json",Db=".weights.bin";function ol(n){return new Promise(e=>setTimeout(e)).then(n)}class ur{constructor(e){if(!M().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ur.URL_SCHEME)&&(e=e.slice(ur.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Ob),this.modelJsonFileName=e+Ab,this.weightDataFileName=e+Db}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=Uf(e,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=o,await ol(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await ol(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ms(e)}}}}ur.URL_SCHEME="downloads://";class Pb{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const o=JSON.parse(s.target.result),i=o.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const c=xc(o,u=>this.loadWeights(u));e(c)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const i of e)t.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(e),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[t,yc(i)])}loadWeightsFile(e,t){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;r(a)},o.onerror=i=>s(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(o=>sl(o.name)),s={};for(const o of e)o.paths.forEach(i=>{const a=sl(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const Fb=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ur.URL_SCHEME)?Lb(n.slice(ur.URL_SCHEME.length)):null;De.registerSaveRouter(Fb);function Lb(n="model"){return new ur(n)}function Mb(n){return new Pb(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(n,e,t,r){i(n),t=t==null?0:t,r=r==null?1:r,a(t,r);let s=0;const o=c=>(c.then(u=>{const l=t+ ++s/n.length*(r-t);return e(l),u}),c);function i(c){k(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function a(c,u){k(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),k(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),k(u>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${u}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Zf(n,e){e==null&&(e={});const t=e.fetchFunc==null?M().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),s=0,o=.5,a=(e.onProgress==null?await Promise.all(r):await il(r,e.onProgress,s,o)).map(h=>h.arrayBuffer()),c=.5,u=1;return e.onProgress==null?await Promise.all(a):await il(a,e.onProgress,c,u)}async function Bb(n,e="",t,r){return Jf(i=>Zf(i,{requestInit:r}))(n,e,t)}function Jf(n){return async(e,t="",r)=>{const s=e.map(()=>!1),o={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((d,m)=>{let g=0;d.weights.forEach(y=>{const x="quantization"in y?y.quantization.dtype:y.dtype,w=ga[x]*G(y.shape),S=()=>{s[m]=!0,o[m]==null&&(o[m]=[]),o[m].push({manifestEntry:y,groupOffset:g,sizeBytes:w})};r!=null?r.forEach(($,N)=>{$===y.name&&(S(),i[N]=!0)}):S(),a.push(y.name),g+=w})}),!i.every(d=>d)){const d=r.filter((m,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const c=s.reduce((d,m,g)=>(m&&d.push(g),d),[]),u=[];c.forEach(d=>{e[d].paths.forEach(m=>{const g=t+(t.endsWith("/")?"":"/")+m;u.push(g)})});const l=await n(u),h={};let p=0;return c.forEach(d=>{const m=e[d].paths.length;let g=0;for(let $=0;$<m;$++)g+=l[p+$].byteLength;const y=new ArrayBuffer(g),x=new Uint8Array(y);let w=0;for(let $=0;$<m;$++){const N=new Uint8Array(l[p+$]);x.set(N,w),w+=N.byteLength}o[d].forEach($=>{const N=y.slice($.groupOffset,$.groupOffset+$.sizeBytes),_=Vf(N,[$.manifestEntry]);for(const O in _)h[O]=_[O]}),p+=m}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vb="application/octet-stream",Ub="application/json";class bc{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(k(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=M().platform.fetch,k(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&k(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Uf(e,r);t.body.append("model.json",new Blob([JSON.stringify(s)],{type:Ub}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Vb}),"model.weights.bin");const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:Ms(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return xc(t,o=>this.loadWeights(o))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=zb(t),o=this.weightPathPrefix||r,i=Wf(e),a=[],c=[];for(const l of e)for(const h of l.paths)this.weightUrlConverter!=null?c.push(this.weightUrlConverter(h)):a.push(o+h+s);this.weightUrlConverter&&a.push(...await Promise.all(c));const u=await Zf(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,yc(u)]}}bc.URL_SCHEME_REGEX=/^https?:\/\//;function zb(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function va(n){return n.match(bc.URL_SCHEME_REGEX)!=null}const em=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>va(r)):t=va(n),t)return vc(n,e)}return null};De.registerSaveRouter(em);De.registerLoadRouter(em);function vc(n,e){return new bc(n,e)}function Wb(n,e){return vc(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oi{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class tm{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Gb{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function jb(n,e,t,r){const s=arguments;return new Gb(nm(...s))}function nm(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Oi(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Oi({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Oi({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function Hb(n){return new tm(n)}function Kb(n){return new tm(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rm=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:Mb,browserHTTPRequest:Wb,concatenateArrayBuffers:yc,decodeWeights:Vf,encodeWeights:J1,fromMemory:jb,fromMemorySync:nm,getLoadHandlers:lb,getModelArtifactsForJSON:xc,getModelArtifactsForJSONSync:zf,getModelArtifactsInfoForJSON:Ms,getSaveHandlers:ub,getWeightSpecs:Wf,http:vc,isHTTPScheme:va,loadWeights:Bb,registerLoadRouter:cb,registerSaveRouter:ab,weightsLoaderFactory:Jf,withSaveHandler:Hb,withSaveHandlerSync:Kb,copyModel:Tb,listModels:Cb,moveModel:$b,removeModel:Sb},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qb(n,e,t=!1,r=!1){let s=T(n,"a","matMul"),o=T(e,"b","matMul");[s,o]=Be(s,o);const i={a:s,b:o},a={transposeA:t,transposeB:r};return A.runKernel(ep,i,a)}const Se=I({matMul_:qb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xb(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:T(n,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:t,offValue:r};return A.runKernel(Sd,i,a)}const Yb=I({oneHot_:Xb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function On(){return A}function we(n,e){return A.tidy(n,e)}function tt(n){Af(n).forEach(t=>t.dispose())}function Dn(n){return A.keep(n)}function Qb(n){return A.setBackend(n)}function Ao(){return A.backendName}function Zb(n){A.removeBackend(n)}function Jb(n){return A.findBackendFactory(n)}function sm(n,e,t=1){return A.registerBackend(n,e,t)}function ev(){return A.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tv(n){const t={input:T(n,"input","imag")};return A.runKernel(jp,t)}const Zo=I({imag_:tv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n){const t={x:T(n,"x","neg")};return A.runKernel(yd,t)}const bn=I({neg_:nv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rv(n){const t={input:T(n,"input","real")};return A.runKernel(Od,t)}const Es=I({real_:rv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sv(n,e,t){const r=T(n,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),k(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{k(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:e};return r.dtype==="complex64"?we(()=>{let i=Es(r),a=Zo(r);return i=A.runKernel(po,{x:i},o),a=A.runKernel(po,{x:a},o),t&&(a=bn(a)),Bn(i,a)}):A.runKernel(po,s,o)}const wa=I({transpose_:sv});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Do(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const o=t-1-s,i=n[o]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(o)}return r}function om(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],o=e.length-r-1,i=e[o];(s==null||s===1&&i>1)&&t.unshift(o)}return t}function me(n,e){const t=[],r=Math.max(n.length,e.length);for(let s=0;s<r;s++){let o=n[n.length-s-1];o==null&&(o=1);let i=e[e.length-s-1];if(i==null&&(i=1),o===1)t.unshift(i);else if(i===1)t.unshift(o);else if(o!==i){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else t.unshift(o)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function im(n,e,t){if(Kr(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Wn(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Gn(n,e,r,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qn;function ov(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(aa(ra,A.backendName)!=null){const m={pixels:n},g={numChannels:e};return A.runKernel(ra,m,g)}const[u,l]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(i)h=n.getContext("2d").getImageData(0,0,u,l).data;else if(r||t)h=n.data;else if(o||s||a){if(qn==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")qn=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else qn=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});qn.canvas.width=u,qn.canvas.height=l,qn.drawImage(n,0,0,u,l),h=qn.getImageData(0,0,u,l).data}let p;if(e===4)p=new Int32Array(h);else{const m=u*l;p=new Int32Array(m*e);for(let g=0;g<m;g++)for(let y=0;y<e;++y)p[g*e+y]=h[g*4+y]}return im(p,[l,u,e],"int32")}async function wc(n,e){let t=T(n,"img","toPixels");if(!(n instanceof Fe)){const u=t;t=Ae(u,"int32"),u.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[r,s]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const i=await t.data(),a=t.dtype==="float32"?255:1,c=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){const l=[0,0,0,255];for(let p=0;p<o;p++){const d=i[u*o+p];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);o===1?(l[0]=d*a,l[1]=d*a,l[2]=d*a):l[p]=d*a}const h=u*4;c[h+0]=Math.round(l[0]),c[h+1]=Math.round(l[1]),c[h+2]=Math.round(l[2]),c[h+3]=Math.round(l[3])}if(e!=null){e.width=s,e.height=r;const u=e.getContext("2d"),l=new ImageData(c,s,r);u.putImageData(l,0,0)}return t!==n&&t.dispose(),c}const Cc=I({fromPixels_:ov});function am(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(G(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,o=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const a=n.shape,c=s.slice();c.pop();let u=1;for(let h=o;h<t;++h)u*=a[h],c.push(a[h]);const l=[...qe(n.shape).map(h=>h/u),1].slice(0,o);return[c,i,u,l]}function cm(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(o+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(o+` update.rank != ${s+n.length-r}`);for(let i=0;i<s;++i)if(t.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-s;++i)if(t.shape[i+s]!==n[i+r])throw new Error(o+` updates.shape[${i+s}] (${t.shape[i+s]}) != shape[${i+s}] (${n[i+s]})`)}function um(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}cm(t,e,n)}function Sc(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=t.length;let i=1;for(let h=s;h<o;++h)i*=t[h];const a=s<1?1:s,c=G(e.shape)/a,u=[...qe(t.slice(0,s)),1],l=G(t);return{sliceRank:s,numUpdates:c,sliceSize:i,strides:u,outputSize:l}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ca=-2,iv=-1;function lm(n,e,t){const r=n.shape.length;k(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),k(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)k(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function av(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function hm(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function pm(n,e,t,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<t;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function dm(n,e,t){return t<=n?t:t-(e-1)}function fm(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function cv(n,e,t,r,s,o,i,a,c){const u=n.length;let l=new Array(u),h=new Array(u),p=new Array(u);if(e.length&&t>0){const d=e[0],m=t+1;l=mm(i,d,m,r,n),h=gm(a,d,m,s,n),p=pm(o,d,m,n)}else for(let d=0;d<u;d++)l[d]=xm(i,r,o,n,d,c),h[d]=bm(a,s,o,n,d,c),p[d]=ym(o,d,c);return{begin:l,end:h,strides:p}}function mm(n,e,t,r,s){const o=[...s],i=fm(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const c=dm(e,t,a);let u=r[c];n&1<<c&&(u=0),o[a]=u}return o}function gm(n,e,t,r,s){const o=[...s],i=fm(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const c=dm(e,t,a);let u=r[c];n&1<<c&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++){const c=s[a];o[a]<0&&(o[a]+=c),o[a]=No(0,o[a],s[a])}return o}function ym(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function xm(n,e,t,r,s,o){let i=e[s];const a=t[s]||1;(n&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const c=r[s];return i<0&&(i+=c),i=No(0,i,c-1),i}function bm(n,e,t,r,s,o){let i=e[s];const a=t[s]||1;(n&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const c=r[s];return i<0&&(i+=c),a>0?i=No(0,i,c):i=No(-1,i,c-1),i}function Tc(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function $c(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function vm(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{k(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(s).fill(-1):typeof t=="number"?o=[t,...new Array(s-1).fill(-1)]:t.length<s?o=t.concat(new Array(s-t.length).fill(-1)):o=t,o=o.map((i,a)=>i>=0?i:(k(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function wm(n,e,t,r,s,o,i,a,c){let u;if(r==null?(u=new Array(e.length),u.fill(1)):u=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};for(let S=0;S<h.dims;S++)l&&(1<<S&a)!==0&&h.numAddAxisAfterEllipsis++,1<<S&i&&(l=!0);l||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};uv(h,p);let d=!0,m=!0,g=!0;const y=[],x=[];for(let S=0;S<n.length;++S){if(p.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);const $=!!(p.shrinkAxisMask&1<<S),N=n[S];if(N===-1){y.push($?1:-1);continue}const _=[p.beginMask&1<<S,p.endMask&1<<S],O=[p.strides[S]>0?0:-1,p.strides[S]>0?N:N-1];if($&&p.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[S]===1;const D=!!(p.beginMask&1<<S&&p.endMask&1<<S);if(p.beginValid&&p.endValid){if($){const j=p.begin[S]<0?N+p.begin[S]:p.begin[S];if(p.begin[S]=j,p.end[S]=p.begin[S]+1,j<0||j>=N)throw Error(`slice index ${p.begin[S]} of dimension ${S} out of bounds.`)}else p.begin[S]=al(p.begin[S],0,p.strides[S],N,_,O),p.end[S]=al(p.end[S],1,p.strides[S],N,_,O);const z=p.strides[S]===1&&p.begin[S]===0&&p.end[S]===N;d=d&&z,m=m&&(S===0&&p.strides[S]===1||z)}else d=d&&p.strides[S]===1&&D,m=m&&(S===0&&p.strides[S]===1||D);let F,L=!1;if(p.beginValid&&p.endValid?(F=p.end[S]-p.begin[S],L=!0):$?(F=1,L=!0):D&&N>=0&&(p.strides[S]<0?F=-N:F=N,L=!0),L){let z;F===0||F<0!=p.strides[S]<0?z=0:z=Math.trunc(F/p.strides[S])+(F%p.strides[S]!==0?1:0),y.push(z)}else y.push(-1)}for(let S=0;S<p.finalShapeGatherIndices.length;++S){const $=p.finalShapeGatherIndices[S];$>=0?x.push(y[$]):$===Ca&&x.push(1)}return{finalShapeSparse:x.filter((S,$)=>p.finalShapeGatherIndices[$]!==Ca),finalShape:x,isIdentity:d,sliceDim0:m,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function uv(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(Ca),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(iv),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function al(n,e,t,r,s,o){if(s[e])return t>0?o[e]:o[e+1&1];{const i=n<0?r+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const lv=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:lm,maskToAxes:av,computeOutShape:hm,stridesWithElidedDims:pm,getNormalizedAxes:cv,startIndicesWithElidedDims:mm,stopIndicesWithElidedDims:gm,stridesForAxis:ym,startForAxis:xm,stopForAxis:bm,isSliceContinous:Tc,computeFlatOffset:$c,parseSliceParams:vm,sliceInfo:wm},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hv(n,e){let t=T(n,"a","add"),r=T(e,"b","add");[t,r]=Be(t,r);const s={a:t,b:r};return A.runKernel(lc,s)}const ye=I({add_:hv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pv(n,e){let t=T(n,"a","floorDiv"),r=T(e,"b","floorDiv");[t,r]=Be(t,r);const s={a:t,b:r};return A.runKernel(Mp,s)}const Cm=I({floorDiv_:pv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dv(n,e){let t=T(n,"a","div"),r=T(e,"b","div");if([t,r]=Be(t,r),t.dtype==="int32"&&r.dtype==="int32")return Cm(t,r);const s={a:t,b:r},o={};return A.runKernel(Ep,s,o)}const ve=I({div_:dv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fv(n,e){let t=T(n,"a","mul"),r=T(e,"b","mul");[t,r]=Be(t,r);const s={a:t,b:r};return A.runKernel(gd,s)}const ee=I({mul_:fv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mv(n){const e=T(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return A.runKernel(ap,t)}else{const t={x:e};return A.runKernel(Bh,t)}}const Pt=I({abs_:mv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gv(n){const t={x:T(n,"x","acos")};return A.runKernel(Vh,t)}const yv=I({acos_:gv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(n){const t={x:T(n,"x","acosh")};return A.runKernel(Uh,t)}const bv=I({acosh_:xv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n){k(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),k(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,o)=>T(s,`tensors${o}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Me(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return A.runKernel(zh,r)}const wv=I({addN_:vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(n,e=null,t=!1){const s={x:T(n,"x","all","bool")},o={axis:e,keepDims:t};return A.runKernel(Wh,s,o)}const Sv=I({all_:Cv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tv(n,e=null,t=!1){const s={x:T(n,"x","any","bool")},o={axis:e,keepDims:t};return A.runKernel(Gh,s,o)}const $v=I({any_:Tv});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ev(n,e=0){const r={x:T(n,"x","argMax")},s={axis:e};return A.runKernel(jh,r,s)}const Sm=I({argMax_:Ev});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(n,e=0){const r={x:T(n,"x","argMin")},s={axis:e};return A.runKernel(Hh,r,s)}const Nv=I({argMin_:kv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iv(n){const t={x:T(n,"x","asin")};return A.runKernel(Kh,t)}const _v=I({asin_:Iv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rv(n){const t={x:T(n,"x","asinh")};return A.runKernel(qh,t)}const Ov=I({asinh_:Rv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(n){const t={x:T(n,"x","atan")};return A.runKernel(Xh,t)}const Dv=I({atan_:Av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pv(n,e){let t=T(n,"a","atan2"),r=T(e,"b","atan2");[t,r]=Be(t,r);const s={a:t,b:r};return A.runKernel(Qh,s)}const Fv=I({atan2_:Pv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(n){const t={x:T(n,"x","atanh")};return A.runKernel(Yh,t)}const Mv=I({atanh_:Lv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tm(n,e,t,r,s="NHWC",o){const i=n[3],a=[...e,i],c=Xr(s);return $t(n,a,t,o,r,null,null,c)}function fr(n,e,t,r,s,o,i="channelsLast"){const[a,c]=Po(e);let u;if(i==="channelsLast")u=[a,c,n[3],n[3]];else if(i==="channelsFirst")u=[a,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return $t(n,u,t,r,s,o,!1,i)}function Bs(n,e,t,r,s,o,i="NDHWC"){const[a,c,u]=Sa(e);let l,h;if(i==="NDHWC")h="channelsLast",l=[a,c,u,n[4],n[4]];else if(i==="NCDHW")h="channelsFirst",l=[a,c,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Vs(n,l,t,r,s,!1,h,o)}function $t(n,e,t,r,s,o,i=!1,a="channelsLast"){let[c,u,l,h]=[-1,-1,-1,-1];if(a==="channelsLast")[c,u,l,h]=n;else if(a==="channelsFirst")[c,h,u,l]=n;else throw new Error(`Unknown dataFormat ${a}`);const[p,d,,m]=e,[g,y]=Po(t),[x,w]=Po(r),S=Or(p,x),$=Or(d,w),{padInfo:N,outHeight:_,outWidth:O}=Uv(s,u,l,g,y,S,$,o,a),D=i?m*h:m;let F;return a==="channelsFirst"?F=[c,D,_,O]:a==="channelsLast"&&(F=[c,_,O,D]),{batchSize:c,dataFormat:a,inHeight:u,inWidth:l,inChannels:h,outHeight:_,outWidth:O,outChannels:D,padInfo:N,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:d,effectiveFilterHeight:S,effectiveFilterWidth:$,dilationHeight:x,dilationWidth:w,inShape:n,outShape:F,filterShape:e}}function Vs(n,e,t,r,s,o=!1,i="channelsLast",a){let[c,u,l,h,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[c,u,l,h,p]=n;else if(i==="channelsFirst")[c,p,u,l,h]=n;else throw new Error(`Unknown dataFormat ${i}`);const[d,m,g,,y]=e,[x,w,S]=Sa(t),[$,N,_]=Sa(r),O=Or(d,$),D=Or(m,N),F=Or(g,_),{padInfo:L,outDepth:z,outHeight:j,outWidth:K}=zv(s,u,l,h,x,w,S,O,D,F,a),Y=o?y*p:y;let te;return i==="channelsFirst"?te=[c,Y,z,j,K]:i==="channelsLast"&&(te=[c,z,j,K,Y]),{batchSize:c,dataFormat:i,inDepth:u,inHeight:l,inWidth:h,inChannels:p,outDepth:z,outHeight:j,outWidth:K,outChannels:Y,padInfo:L,strideDepth:x,strideHeight:w,strideWidth:S,filterDepth:d,filterHeight:m,filterWidth:g,effectiveFilterDepth:O,effectiveFilterHeight:D,effectiveFilterWidth:F,dilationDepth:$,dilationHeight:N,dilationWidth:_,inShape:n,outShape:te,filterShape:e}}function Bv(n,e,t,r,s){r==null&&(r=Ec(n,e,t));const o=n[0],i=n[1],a=or((o-e+2*r)/t+1,s),c=or((i-e+2*r)/t+1,s);return[a,c]}function Vv(n,e,t,r,s,o){s==null&&(s=Ec(n,e,r));const i=n[0],a=n[1],c=n[2],u=or((i-e+2*s)/r+1,o),l=or((a-e+2*s)/r+1,o),h=or((c-e+2*s)/r+1,o);return[u,l,h,t]}function Ec(n,e,t,r=1){const s=Or(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function Po(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Sa(n){return typeof n=="number"?[n,n,n]:n}function Or(n,e){return e<=1?n:n+(n-1)*(e-1)}function Uv(n,e,t,r,s,o,i,a,c){let u,l,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=Bv([e,t],o,r,n,a);l=d[0],h=d[1]}else if(n==="same"){l=Math.ceil(e/r),h=Math.ceil(t/s);const p=Math.max(0,(l-1)*r+o-e),d=Math.max(0,(h-1)*s+i-t),m=Math.floor(p/2),g=p-m,y=Math.floor(d/2),x=d-y;u={top:m,bottom:g,left:y,right:x,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-o+1)/r),h=Math.ceil((t-i+1)/s);else if(typeof n=="object"){const p=c==="channelsLast"?n[1][0]:n[2][0],d=c==="channelsLast"?n[1][1]:n[2][1],m=c==="channelsLast"?n[2][0]:n[3][0],g=c==="channelsLast"?n[2][1]:n[3][1];u={top:p,bottom:d,left:m,right:g,type:p===0&&d===0&&m===0&&g===0?"VALID":"EXPLICIT"},l=or((e-o+p+d)/r+1,a),h=or((t-i+m+g)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:l,outWidth:h}}function zv(n,e,t,r,s,o,i,a,c,u,l){let h,p,d,m;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=Vv([e,t,r,1],a,1,s,n,l);p=y[0],d=y[1],m=y[2]}else if(n==="same"){p=Math.ceil(e/s),d=Math.ceil(t/o),m=Math.ceil(r/i);const g=(p-1)*s+a-e,y=(d-1)*o+c-t,x=(m-1)*i+u-r,w=Math.floor(g/2),S=g-w,$=Math.floor(y/2),N=y-$,_=Math.floor(x/2),O=x-_;h={top:$,bottom:N,left:_,right:O,front:w,back:S,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((e-a+1)/s),d=Math.ceil((t-c+1)/o),m=Math.ceil((r-u+1)/i);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:p,outHeight:d,outWidth:m}}function or(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function ks(n){const[e,t,r]=Po(n);return e===1&&t===1&&r===1}function bt(n,e){return ks(n)||ks(e)}function Xr(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Wt(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")k(Fr(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{k(Fr(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n,e){const r={x:T(n,"x","reshape","string_or_numeric")},s={shape:e};return A.runKernel(Pd,r,s)}const V=I({reshape_:Wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gv(n,e,t,r,s){const o=T(n,"x","avgPool","float32"),i=1;k(bt(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=o,c=!1;o.rank===3&&(c=!0,a=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),k(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Wt("avgPool",r,s);const u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=A.runKernel(Zh,u,l);return h=Ae(h,o.dtype),c?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const $m=I({avgPool_:Gv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n,e,t,r,s,o="NDHWC"){const i=T(n,"x","avgPool3d","float32");let a=i,c=!1;i.rank===4&&(c=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),k(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Wt("avgPool3d",r,s);const u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o};let h=A.runKernel(Jh,u,l);return h=Ae(h,a.dtype),c?V(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Hv=I({avgPool3d_:jv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(n,e=0){k(n.length>=1,()=>"Pass at least one tensor to concat");const t=Ro(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return Ln(t[0]);const r=t,s={axis:e};return A.runKernel(cp,r,s)}const Ge=I({concat_:Kv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n){const t={x:T(n,"x","sigmoid","float32")};return A.runKernel(Yd,t)}const vn=I({sigmoid_:qv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xv(n,e,t){const r=T(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:t};return A.runKernel(Hd,s,o)}const oe=I({slice_:Xv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yv(n){const t={x:T(n,"x","tanh","float32")};return A.runKernel(gf,t)}const Ta=I({tanh_:Yv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n,e,t,r,s,o){const i=T(n,"forgetBias","basicLSTMCell"),a=T(e,"lstmKernel","basicLSTMCell"),c=T(t,"lstmBias","basicLSTMCell"),u=T(r,"data","basicLSTMCell"),l=T(s,"c","basicLSTMCell"),h=T(o,"h","basicLSTMCell"),p=Ge([u,h],1),d=Se(p,a),m=ye(d,c),g=m.shape[0],y=m.shape[1]/4,x=[g,y],w=oe(m,[0,0],x),S=oe(m,[0,y],x),$=oe(m,[0,y*2],x),N=oe(m,[0,y*3],x),_=ye(ee(vn(w),Ta(S)),ee(l,vn(ye(i,$)))),O=ee(Ta(_),vn(N));return[_,O]}const Zv=I({basicLSTMCell_:Qv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jv(n,e,t){const r=T(n,"x","batchToSpaceND"),s=e.reduce((a,c)=>a*c);k(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),k(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),k(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},i={blockShape:e,crops:t};return A.runKernel(tp,o,i)}const Em=I({batchToSpaceND_:Jv});function ew(n){let e;return n.rank===0||n.rank===1?e=V(n,[1,1,1,n.size]):n.rank===2?e=V(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=V(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tw(n,e,t,r,s,o){o==null&&(o=.001);const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),c=T(t,"variance","batchNorm");let u;s!=null&&(u=T(s,"scale","batchNorm"));let l;r!=null&&(l=T(r,"offset","batchNorm")),k(a.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:ew(i),scale:u,offset:l,mean:a,variance:c},d={varianceEpsilon:o},m=A.runKernel(Bp,p,d);return V(m,i.shape)}const Jo=I({batchNorm_:tw});function nw(n,e,t,r,s,o){const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),c=T(t,"variance","batchNorm");let u;s!=null&&(u=T(s,"scale","batchNorm"));let l;return r!=null&&(l=T(r,"offset","batchNorm")),k(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),k(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),k(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&k(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&k(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),Jo(i,a,c,l,u,o)}const rw=I({batchNorm2d_:nw});function sw(n,e,t,r,s,o){const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),c=T(t,"variance","batchNorm");let u;s!=null&&(u=T(s,"scale","batchNorm"));let l;return r!=null&&(l=T(r,"offset","batchNorm")),k(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),k(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),k(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&k(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&k(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),Jo(i,a,c,l,u,o)}const ow=I({batchNorm3d_:sw});function iw(n,e,t,r,s,o){const i=T(n,"x","batchNorm"),a=T(e,"mean","batchNorm"),c=T(t,"variance","batchNorm");let u;s!=null&&(u=T(s,"scale","batchNorm"));let l;return r!=null&&(l=T(r,"offset","batchNorm")),k(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),k(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),k(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&k(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&k(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),Jo(i,a,c,l,u,o)}const aw=I({batchNorm4d_:iw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cw(n,e,t){const r=T(n,"x","bincount"),s=T(e,"weights","bincount");k(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},i={size:t};return A.runKernel(np,o,i)}const km=I({bincount_:cw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uw(n,e){const t=T(n,"s0","broadcastArgs","int32"),r=T(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return A.runKernel(rp,s)}const lw=I({broadcastArgs_:uw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hw(n,e){let t=T(n,"broadcastTo","x");const r=t.shape;if(e.some(u=>!(u>0)||u%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=V(t,u)}const s=t.shape,o=Array.from(e);for(let u=e.length-1;u>=0;u--)if(s[u]===e[u])o[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((u,l)=>u>1?l:-1).filter(u=>u>=0).length===0)return Ln(t);const a={x:t},c={reps:o};return A.runKernel(dc,a,c)}const Cs=I({broadcastTo_:hw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pw(n){const t={x:T(n,"x","ceil","float32")};return A.runKernel(sp,t)}const dw=I({ceil_:pw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(n,e,t){const r={shape:n,value:e,dtype:t};return A.runKernel(Pp,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fw(n,e,t){const r=T(n,"x","clipByValue");if(k(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return ei(r.shape,e,r.dtype);const s={x:r},o={clipValueMin:e,clipValueMax:t};return A.runKernel(op,s,o)}const Nm=I({clipByValue_:fw});function mw(n){return Ge(n,0)}const gw=I({concat1d_:mw});function yw(n,e){return Ge(n,e)}const xw=I({concat2d_:yw});function bw(n,e){return Ge(n,e)}const vw=I({concat3d_:bw});function ww(n,e){return Ge(n,e)}const Cw=I({concat4d_:ww});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sw(n,e,t,r,s="NHWC",o=[1,1],i){const a=T(n,"x","conv2d","float32"),c=T(e,"filter","conv2d","float32");let u=a,l=!1;a.rank===3&&(l=!0,u=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),k(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),Wt("conv2d",r,i);const h=s==="NHWC"?u.shape[3]:u.shape[1];k(h===c.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${c.shape[2]}.`),k(bt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const p={x:u,filter:c},d={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},m=A.runKernel(up,p,d);return l?V(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const ti=I({conv2d_:Sw});function Tw(n,e,t,r,s="NWC",o=1,i){const a=T(n,"x","conv1d"),c=T(e,"filter","conv1d");let u=a,l=!1;a.rank===2&&(l=!0,u=V(a,[1,a.shape[0],a.shape[1]])),k(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),k(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),Wt("conv1d",r,i),k(u.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${c.shape[1]}.`),k(bt(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),k(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=V(c,[1,c.shape[0],c.shape[1],c.shape[2]]),p=V(u,[u.shape[0],1,u.shape[1],u.shape[2]]),y=ti(p,h,[1,t],r,"NHWC",[1,o],i);return l?V(y,[y.shape[2],y.shape[3]]):V(y,[y.shape[0],y.shape[2],y.shape[3]])}const $w=I({conv1d_:Tw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ew(n,e,t,r,s,o="NHWC",i){k(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,c=e,u=!1;e.rank===3&&(u=!0,c=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),k(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),k(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),k(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const l=o==="NHWC"?a[3]:a[1],h=o==="NHWC"?c.shape[3]:c.shape[1];k(l===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[2]}.`),k(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Wt("conv2dDerInput",s,i);const p={dy:c,filter:t},d={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a},m=A.runKernel(hp,p,d);return u?V(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Im=I({conv2DBackpropInput_:Ew});function kw(n,e,t,r,s,o){const i=T(n,"x","conv2dTranspose"),a=T(e,"filter","conv2dTranspose");return Im(t,i,a,r,s,"NHWC",o)}const Nw=I({conv2dTranspose_:kw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n,e,t,r,s="NDHWC",o=[1,1,1]){const i=T(n,"x","conv3d"),a=T(e,"filter","conv3d");let c=i,u=!1;i.rank===4&&(u=!0,c=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),k(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),k(c.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${a.shape[3]}.`),k(bt(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),k(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const l={x:c,filter:a},h={strides:t,pad:r,dataFormat:s,dilations:o},p=A.runKernel(pp,l,h);return u?V(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const _w=I({conv3d_:Iw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rw(n,e,t,r,s){k(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,i=e,a=!1;e.rank===4&&(a=!0,i=V(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const c=o[4],u=i.shape[4];k(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),k(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),k(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),k(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),k(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const l={dy:i,filter:t},h={pad:s,strides:r,inputShape:o},p=A.runKernel(dp,l,h);return a?V(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Ow=I({conv3DBackpropInput_:Rw});function Aw(n,e,t,r,s){const o=T(n,"x","conv3dTranspose"),i=T(e,"filter","conv3dTranspose");return Ow(t,o,i,r,s)}const Dw=I({conv3dTranspose_:Aw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pw(n){const t={x:T(n,"x","cos","float32")};return A.runKernel(fp,t)}const Fw=I({cos_:Pw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lw(n){const t={x:T(n,"x","cosh","float32")};return A.runKernel(mp,t)}const Mw=I({cosh_:Lw});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bw(n,e=0,t=!1,r=!1){const o={x:T(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:r};return A.runKernel(gp,o,i)}const Vw=I({cumprod_:Bw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw(n,e=0,t=!1,r=!1){const o={x:T(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:r};return A.runKernel(yp,o,i)}const zw=I({cumsum_:Uw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ww(n,e,t,r=!1){const s=T(n,"x","denseBincount"),o=T(e,"weights","denseBincount");k(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),k(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},a={size:t,binaryOutput:r};return A.runKernel(bp,i,a)}const Gw=I({denseBincount_:Ww});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n,e,t="NHWC"){const r=T(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],o=t==="NHWC"?r.shape[2]:r.shape[3],i=t==="NHWC"?r.shape[3]:r.shape[1];k(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),k(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),k(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),k(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const a={x:r},c={blockSize:e,dataFormat:t};return A.runKernel(vp,a,c)}const Hw=I({depthToSpace_:jw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kw(n,e,t,r,s="NHWC",o=[1,1],i){const a=T(n,"x","depthwiseConv2d","float32"),c=T(e,"filter","depthwiseConv2d","float32");let u=a,l=!1;a.rank===3&&(l=!0,u=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),k(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const h=s==="NHWC"?u.shape[3]:u.shape[1];k(h===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${c.shape[2]}.`),Wt("depthwiseConv2d",r,i);const p={x:u,filter:c},d={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},m=A.runKernel(wp,p,d);return l?V(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const kc=I({depthwiseConv2d_:Kw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(n){const t={x:T(n,"x","diag")};return A.runKernel(Tp,t)}const Xw=I({diag_:qw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yw(n,e,t,r,s=[1,1],o="NHWC"){const i=T(n,"x","dilation2d"),a=T(e,"filter","dilation2d");k(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),k(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),k(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let c=i,u=!1;i.rank===3&&(c=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);const l={x:c,filter:a},h={strides:t,pad:r,dilations:s},p=A.runKernel($p,l,h);return u?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Qw=I({dilation2d_:Yw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zw(n,e){let t=T(n,"a","equal","string_or_numeric"),r=T(e,"b","equal","string_or_numeric");[t,r]=Be(t,r),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(_p,s)}const _m=I({equal_:Zw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(n,e,t){const r=T(e,"a","where"),s=T(t,"b","where"),o=T(n,"condition","where","bool"),i=me(me(o.shape,r.shape),s.shape),a=Cs(o,i),c=Cs(r,i),u=Cs(s,i),l={condition:a,t:c,e:u};return A.runKernel(Gd,l)}const Ur=I({where_:Jw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eC(n){const t={x:T(n,"x","zerosLike")};return A.runKernel(Cf,t)}const Nc=I({zerosLike_:eC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tC(n,e){let t=T(n,"a","div"),r=T(e,"b","div");[t,r]=Be(t,r);const s=ve(t,r),o=Nc(s),i=_m(r,o);return Ur(i,o,s)}const nC=I({divNoNan_:tC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC(n,e){const t=T(n,"t1","dot"),r=T(e,"t2","dot");k((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],o=r.rank===1?r.size:r.shape[0];if(k(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),t.rank===1&&r.rank===1){const i=V(t,[1,-1]),a=V(r,[-1,1]),c=Se(i,a);return V(c,[])}else if(t.rank===1&&r.rank===2){const i=V(t,[1,-1]),a=V(r,[r.shape[0],r.shape[1]]),c=Se(i,a);return V(c,[c.size])}else if(t.rank===2&&r.rank===1){const i=V(r,[-1,1]),a=Se(t,i);return V(a,[a.size])}else{const i=V(r,[r.shape[0],r.shape[1]]);return Se(t,i)}}const sC=I({dot_:rC});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oC(n,...e){const t=e.map((s,o)=>T(s,`tensors${o}`,"einsum")),r={equation:n};return A.runKernel(kp,t,r)}const iC=I({einsum_:oC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aC(n){const t={x:T(n,"x","elu","float32")};return A.runKernel(Np,t)}const Rm=I({elu_:aC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cC(n){let e=T(n,"x","erf");k(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ae(e,"float32"));const t={x:e};return A.runKernel(Ip,t)}const uC=I({erf_:cC});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ic(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Om(n,e,t){const r=n.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[o++]):s.push(e[i++]);return s}function fn(n,e){const t=[],r=n.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&t.push(n[o]);const s=e.map(o=>n[o]);return[t,s]}function Et(n,e){const t=e.map(r=>1);return Om(n,t,e)}function nn(n,e,t){k(Ic(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Gt(n,e){if(Ic(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function _c(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function jt(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lC(n,e=null,t=!1){const s={x:T(n,"x","max")},o={reductionIndices:e,keepDims:t};return A.runKernel(od,s,o)}const Ar=I({max_:lC});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hC(n,e=null,t=!1){const s={x:T(n,"x","min")},o={axis:e,keepDims:t};return A.runKernel(hd,s,o)}const $a=I({min_:hC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pC(n,e){let t=T(n,"base","pow"),r=T(e,"exp","pow");[t,r]=Be(t,r);const s={a:t,b:r};return A.runKernel(Ed,s)}const Rc=I({pow_:pC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function he(n,e){if((hn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&hn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Gn(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dC(n){const t={x:T(n,"x","sqrt","float32")};return A.runKernel(Zd,t)}const Ea=I({sqrt_:dC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fC(n){const e=T(n,"x","square"),t={};return A.runKernel("Square",{x:e},t)}const Us=I({square_:fC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mC(n,e=null,t=!1){let r=T(n,"x","sum");r.dtype==="bool"&&(r=Ae(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return A.runKernel(Jd,s,o)}const Ie=I({sum_:mC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gC(n,e="euclidean",t=null,r=!1){n=T(n,"x","norm");const s=Am(n,e,t);let o=s.shape;if(r){const i=je(t,n.shape);o=Et(s.shape,i)}return V(s,o)}function Am(n,e,t=null){if(n.rank===0)return Pt(n);if(n.rank!==1&&t===null)return Am(V(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ie(Pt(n),t);if(e===1/0)return Ar(Pt(n),t);if(e===-1/0)return $a(Pt(n),t);if(e==="euclidean"||e===2)return Ea(Ie(Rc(Pt(n),he(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Ar(Ie(Pt(n),t[0]),t[1]-1);if(e===1/0)return Ar(Ie(Pt(n),t[1]),t[0]);if(e===-1/0)return $a(Ie(Pt(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ea(Ie(Us(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const ni=I({norm_:gC});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yC(n,e=null,t=!1){return ni(n,"euclidean",e,t)}const xC=I({euclideanNorm_:yC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bC(n){const t={x:T(n,"x","exp")};return A.runKernel(Rp,t)}const Sn=I({exp_:bC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vC(n,e=0){const t=T(n,"x","expandDims","string_or_numeric");k(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return A.runKernel(Op,r,s)}const Lt=I({expandDims_:vC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wC(n){const t={x:T(n,"x","expm1")};return A.runKernel(Ap,t)}const CC=I({expm1_:wC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SC(n,e){const t=T(n,"x","tile","string_or_numeric");k(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return A.runKernel(dc,r,s)}const Ss=I({tile_:SC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TC(n,e,t,r="float32"){e==null&&(e=n);const s=Le([n,e],r),o=n<=e?n:e;for(let a=0;a<o;++a)s.set(1,a,a);const i=V(s.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return Ss(Lt(i,0),[t[0],1,1]);if(t.length===2)return Ss(Lt(Lt(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return Ss(Lt(Lt(Lt(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Dm=I({eye_:TC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $C(n){const t={x:T(n,"x","floor","float32")};return A.runKernel(Lp,t)}const Pm=I({floor_:$C});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EC(n,e,t=0,r=0){const s=T(n,"x","gather"),o=T(e,"indices","gather","int32"),i={x:s,indices:o},a={axis:t,batchDims:r};return A.runKernel(Vp,i,a)}const Fm=I({gather_:EC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kC(n,e){let t=T(n,"a","greater","string_or_numeric"),r=T(e,"b","greater","string_or_numeric");[t,r]=Be(t,r),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(zp,s)}const ri=I({greater_:kC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NC(n,e){let t=T(n,"a","greaterEqual","string_or_numeric"),r=T(e,"b","greaterEqual","string_or_numeric");[t,r]=Be(t,r),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(Wp,s)}const Lm=I({greaterEqual_:NC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IC(n){const t={x:T(n,"x","isFinite")};return A.runKernel(Hp,t)}const _C=I({isFinite_:IC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RC(n){const t={x:T(n,"x","isInf")};return A.runKernel(Kp,t)}const OC=I({isInf_:RC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AC(n){const t={x:T(n,"x","isNaN")};return A.runKernel(qp,t)}const DC=I({isNaN_:AC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PC(n,e=.2){const r={x:T(n,"x","leakyRelu")},s={alpha:e};return A.runKernel(Xp,r,s)}const Mm=I({leakyRelu_:PC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FC(n,e){let t=T(n,"a","less","string_or_numeric"),r=T(e,"b","less","string_or_numeric");[t,r]=Be(t,r),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(Yp,s)}const LC=I({less_:FC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MC(n,e){let t=T(n,"a","lessEqual","string_or_numeric"),r=T(e,"b","lessEqual","string_or_numeric");[t,r]=Be(t,r),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(Qp,s)}const Oc=I({lessEqual_:MC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BC(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return A.runKernel(Zp,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VC(n,e=5,t=1,r=1,s=.5){const o=T(n,"x","localResponseNormalization");k(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),k(Fr(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=V(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={x:i},u={depthRadius:e,bias:t,alpha:r,beta:s},l=A.runKernel(sd,c,u);return a?V(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const UC=I({localResponseNormalization_:VC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zC(n){const t={x:T(n,"x","log","float32")};return A.runKernel(Jp,t)}const Ns=I({log_:zC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n){const t={x:T(n,"x","log1p")};return A.runKernel(ed,t)}const Bm=I({log1p_:WC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tn(n){return A.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GC(n){const t={x:T(n,"x","softplus")};return A.runKernel(Qd,t)}const Vm=I({softplus_:GC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jC(n){const e=T(n,"x","logSigmoid");return Tn(r=>({value:bn(Vm(bn(r))),gradFunc:i=>ee(i,vn(bn(r)))}))(e)}const HC=I({logSigmoid_:jC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KC(n,e){let t=T(n,"a","sub"),r=T(e,"b","sub");[t,r]=Be(t,r);const s={a:t,b:r};return A.runKernel(ff,s)}const ce=I({sub_:KC});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qC(n,e=-1){const t=T(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Tn((s,o)=>{const a=Ar(s,e,!0),c=ce(s,a),u=ce(Ae(c,"float32"),Ns(Ie(Sn(c),e,!0)));return o([u]),{value:u,gradFunc:(h,p)=>{const[d]=p,m=!0,g=Sn(d);return ce(h,ee(Ie(h,e,m),g))}}})(t)}const XC=I({logSoftmax_:qC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YC(n,e=null,t=!1){const r=T(n,"x","logSumExp"),s=je(e,r.shape),o=Ar(r,s,!0),i=ce(r,o),a=Sn(i),c=Ie(a,s),u=Ns(c),l=ye(V(o,u.shape),u);if(t){const h=Et(l.shape,s);return V(l,h)}return l}const Um=I({logSumExp_:YC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QC(n,e){const t=T(n,"a","logicalAnd","bool"),r=T(e,"b","logicalAnd","bool");me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(td,s)}const Fo=I({logicalAnd_:QC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n){const t={x:T(n,"x","logicalNot","bool")};return A.runKernel(nd,t)}const zm=I({logicalNot_:ZC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JC(n,e){const t=T(n,"a","logicalOr","bool"),r=T(e,"b","logicalOr","bool");me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(rd,s)}const Wm=I({logicalOr_:JC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eS(n,e){const t=T(n,"a","logicalXor","bool"),r=T(e,"b","logicalXor","bool");return me(t.shape,r.shape),Fo(Wm(n,e),zm(Fo(n,e)))}const tS=I({logicalXor_:eS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const so=2147483648;function nS(n,e,t="left"){const r=T(n,"sortedSequence","searchSorted"),s=T(e,"values","searchSorted"),o=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],a=V(r,[-1,o]),c=V(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(G(c.shape)>=so)throw new Error(`values tensor size must less than ${so}`);if(a.shape[1]>=so)throw new Error(`trailing dim_size must less than ${so} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:c},l={side:t};return A.runKernel(Wd,u,l)}const Ac=I({searchSorted_:nS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rS(n,e){return Ac(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sS(n,e,t,r,s){const o=T(n,"x","maxPool"),i=1;let a=o,c=!1;o.rank===3&&(c=!0,a=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),k(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),k(bt(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Wt("maxPool",r,s);const u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=A.runKernel(ad,u,l);return c?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Gm=I({maxPool_:sS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(n,e=[1,1,1],t,r,s,o="NDHWC"){const i=T(n,"x","maxPool3d");let a=i,c=!1;i.rank===4&&(c=!0,a=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),k(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Wt("maxPool3d",r,s);const u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o},h=A.runKernel(cd,u,l);return c?V(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const iS=I({maxPool3d_:oS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aS(n,e,t,r,s=!1){const i={x:T(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},c=A.runKernel(ud,i,a);return{result:c[0],indexes:c[1]}}const cS=I({maxPoolWithArgmax_:aS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uS(n,e){let t=T(n,"a","maximum"),r=T(e,"b","maximum");[t,r]=Be(t,r),t.dtype==="bool"&&(t=Ae(t,"int32"),r=Ae(r,"int32")),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(id,s)}const lS=I({maximum_:uS});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hS(n,e=null,t=!1){const s={x:T(n,"x","mean")},o={axis:e,keepDims:t};return A.runKernel(ld,s,o)}const Lo=I({mean_:hS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vn(n,e="float32"){if(e==="complex64"){const r=Vn(n,"float32"),s=Vn(n,"float32");return Bn(r,s)}const t=Mn(G(n),e);return A.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tr(n,e="float32"){if(e==="complex64"){const r=tr(n,"float32"),s=Vn(n,"float32");return Bn(r,s)}const t=Ph(G(n),e);return A.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pS(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=T(n,"x","meshgrid",n instanceof Fe?n.dtype:"float32");if(e===void 0)return[r];let s=T(e,"y","meshgrid",e instanceof Fe?e.dtype:"float32");const o=G(r.shape),i=G(s.shape);return t==="xy"?(r=V(r,[1,-1]),s=V(s,[-1,1]),[Se(tr([i,1],r.dtype),r),Se(s,tr([1,o],s.dtype))]):(r=V(r,[-1,1]),s=V(s,[1,-1]),[Se(r,tr([1,i],r.dtype)),Se(tr([o,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n,e){let t=T(n,"a","minimum"),r=T(e,"b","minimum");[t,r]=Be(t,r),t.dtype==="bool"&&(t=Ae(t,"int32"),r=Ae(r,"int32")),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(pd,s)}const Dc=I({minimum_:dS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fS(n,e,t){k(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=T(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)k(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),k(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:t},i={x:r};return A.runKernel(dd,i,o)}const jm=I({mirrorPad_:fS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mS(n,e){let t=T(n,"a","mod"),r=T(e,"b","mod");[t,r]=Be(t,r);const s={a:t,b:r};return A.runKernel(fd,s)}const gS=I({mod_:mS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yS(n,e=null,t=!1){n=T(n,"x","moments");const r=je(e,n.shape),s=Lo(n,r,t);let o=s.shape;t||(o=Et(s.shape,r));const i=Us(ce(Ae(n,"float32"),V(s,o))),a=Lo(i,r,t);return{mean:s,variance:a}}const xS=I({moments_:yS});function bS(n,e,t,r){const s=T(e,"data","multiRNNCell"),o=Ro(t,"c","multiRNNCell"),i=Ro(r,"h","multiRNNCell");let a=s;const c=[];for(let h=0;h<n.length;h++){const p=n[h](a,o[h],i[h]);c.push(p[0]),c.push(p[1]),a=p[1]}const u=[],l=[];for(let h=0;h<c.length;h+=2)u.push(c[h]),l.push(c[h+1]);return[u,l]}const vS=I({multiRNNCell_:bS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n,e,t,r=!1){const s=T(n,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const c={logits:i===1?V(s,[1,-1]):s},u={numSamples:e,seed:t,normalized:r},l=A.runKernel(md,c,u);return i===1?V(l,[l.size]):l}const CS=I({multinomial_:wS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SS(n,e){let t=T(n,"a","notEqual","string_or_numeric"),r=T(e,"b","notEqual","string_or_numeric");[t,r]=Be(t,r),me(t.shape,r.shape);const s={a:t,b:r};return A.runKernel(xd,s)}const Hm=I({notEqual_:SS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TS(n){const t={x:T(n,"x","onesLike")};return A.runKernel(Cd,t)}const $S=I({onesLike_:TS});function ES(n,e){const t=T(n,"v1","outerProduct"),r=T(e,"v2","outerProduct");k(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=V(t,[-1,1]),o=V(r,[1,-1]);return Se(s,o)}const kS=I({outerProduct_:ES});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(n,e,t=0){const r=T(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},o={x:r};return A.runKernel($d,o,s)}const Un=I({pad_:NS});function IS(n,e,t=0){return k(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Un(n,[e],t)}const _S=I({pad1d_:IS});function RS(n,e,t=0){return k(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Un(n,e,t)}const OS=I({pad2d_:RS});function AS(n,e,t=0){return k(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Un(n,e,t)}const DS=I({pad3d_:AS});function PS(n,e,t=0){return k(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Un(n,e,t)}const FS=I({pad4d_:PS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(n,e,t){const r=T(n,"x","spaceToBatchND");k(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),k(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),k(r.shape.reduce((i,a,c)=>c>0&&c<=e.length?i&&(a+t[c-1][0]+t[c-1][1])%e[c-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:t};return A.runKernel(ef,s,o)}const Km=I({spaceToBatchND_:LS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(n,e,t,r,s,o,i){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const a=T(n,"x","maxPool");let c=a,u=!1;a.rank===3&&(u=!0,c=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(bt(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const l=fr(c.shape,e,o,s,r),h=[l.dilationHeight,l.dilationWidth];let p;r==="same"?p=VS([l.filterHeight,l.filterWidth],h):p=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[m,g]=BS([l.inHeight,l.inWidth],h,p),y=d?r:"valid",x=d?c:Km(c,h,m),S=(t==="avg"?()=>$m(x,e,o,y,i):()=>Gm(x,e,o,y,i))(),$=d?S:Em(S,h,g);return u?V($,[$.shape[1],$.shape[2],$.shape[3]]):$}function BS(n,e,t){const r=t.map(l=>l[0]),s=t.map(l=>l[1]),o=n.concat(r,s),i=e.map((l,h)=>(l-o[h]%l)%l),a=s.map((l,h)=>l+i[h]),c=e.map((l,h)=>[r[h],a[h]]),u=e.map((l,h)=>[0,i[h]]);return[c,u]}function VS(n,e){const r=n.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}const US=I({pool_:MS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n,e){const t=T(n,"x","prelu"),r=T(e,"alpha","prelu"),s={x:t,alpha:r};return A.runKernel(kd,s)}const qm=I({prelu_:zS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(n,e=null,t=!1){let r=T(n,"x","prod");r.dtype==="bool"&&(r=Ae(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return A.runKernel(Nd,s,o)}const GS=I({prod_:WS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jS(n,e,t,r){const s=n.map((l,h)=>T(l,`tensors${h}`,"raggedGather","int32")),o=T(e,"paramsDenseValues","raggedGather"),i=T(t,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:o,indices:i},c={outputRaggedRank:r},u=A.runKernel(Id,a,c);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const HS=I({raggedGather_:jS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(n,e,t,r,s){const o=T(n,"shape","raggedTensorToTensor","int32"),i=T(e,"values","raggedTensorToTensor"),a=T(t,"defaultValue","raggedTensorToTensor",i.dtype),c=r.map((h,p)=>T(h,`tensors${p}`,"raggedTensorToTensor","int32")),u={shape:o,values:i,defaultValue:a,rowPartitionTensors:c},l={rowPartitionTypes:s};return A.runKernel(_d,u,l)}const qS=I({raggedTensorToTensor_:KS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XS(n,e,t){const r=G(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<r;o++)s[o]=e();return A.makeTensor(s,n,t)}const YS=I({rand_:XS});var Xm={exports:{}};(function(n){(function(e,t,r){function s(c){var u=this,l=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(c),u.s0<0&&(u.s0+=1),u.s1-=l(c),u.s1<0&&(u.s1+=1),u.s2-=l(c),u.s2<0&&(u.s2+=1),l=null}function o(c,u){return u.c=c.c,u.s0=c.s0,u.s1=c.s1,u.s2=c.s2,u}function i(c,u){var l=new s(c),h=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&o(h,l),p.state=function(){return o(l,{})}),p}function a(){var c=4022871197,u=function(l){l=String(l);for(var h=0;h<l.length;h++){c+=l.charCodeAt(h);var p=.02519603282416938*c;c=p>>>0,p-=c,p*=c,c=p>>>0,p-=c,c+=p*4294967296}return(c>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.alea=i})(un,n,!1)})(Xm);var Ym={exports:{}};(function(n){(function(e,t,r){function s(a){var c=this,u="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var h=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^h^h>>>8},a===(a|0)?c.x=a:u+=a;for(var l=0;l<u.length+64;l++)c.x^=u.charCodeAt(l)|0,c.next()}function o(a,c){return c.x=a.x,c.y=a.y,c.z=a.z,c.w=a.w,c}function i(a,c){var u=new s(a),l=c&&c.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,m=(p+d)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,l&&(typeof l=="object"&&o(l,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xor128=i})(un,n,!1)})(Ym);var Qm={exports:{}};(function(n){(function(e,t,r){function s(a){var c=this,u="";c.next=function(){var h=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(h^h<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,a===(a|0)?c.x=a:u+=a;for(var l=0;l<u.length+64;l++)c.x^=u.charCodeAt(l)|0,l==u.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function o(a,c){return c.x=a.x,c.y=a.y,c.z=a.z,c.w=a.w,c.v=a.v,c.d=a.d,c}function i(a,c){var u=new s(a),l=c&&c.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,m=(p+d)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,l&&(typeof l=="object"&&o(l,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xorwow=i})(un,n,!1)})(Qm);var Zm={exports:{}};(function(n){(function(e,t,r){function s(a){var c=this;c.next=function(){var l=c.x,h=c.i,p,d;return p=l[h],p^=p>>>7,d=p^p<<24,p=l[h+1&7],d^=p^p>>>10,p=l[h+3&7],d^=p^p>>>3,p=l[h+4&7],d^=p^p<<7,p=l[h+7&7],p=p^p<<13,d^=p^p<<9,l[h]=d,c.i=h+1&7,d};function u(l,h){var p,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,p=0;p<h.length;++p)d[p&7]=d[p&7]<<15^h.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8?d[7]=-1:d[p],l.x=d,l.i=0,p=256;p>0;--p)l.next()}u(c,a)}function o(a,c){return c.x=a.x.slice(),c.i=a.i,c}function i(a,c){a==null&&(a=+new Date);var u=new s(a),l=c&&c.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,m=(p+d)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,l&&(l.x&&o(l,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xorshift7=i})(un,n,!1)})(Zm);var Jm={exports:{}};(function(n){(function(e,t,r){function s(a){var c=this;c.next=function(){var l=c.w,h=c.X,p=c.i,d,m;return c.w=l=l+1640531527|0,m=h[p+34&127],d=h[p=p+1&127],m^=m<<13,d^=d<<17,m^=m>>>15,d^=d>>>12,m=h[p]=m^d,c.i=p,m+(l^l>>>16)|0};function u(l,h){var p,d,m,g,y,x=[],w=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,w=Math.max(w,h.length)),m=0,g=-32;g<w;++g)h&&(d^=h.charCodeAt((g+32)%h.length)),g===0&&(y=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,g>=0&&(y=y+1640531527|0,p=x[g&127]^=d+y,m=p==0?m+1:0);for(m>=128&&(x[(h&&h.length||0)&127]=-1),m=127,g=4*128;g>0;--g)d=x[m+34&127],p=x[m=m+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,x[m]=d^p;l.w=y,l.X=x,l.i=m}u(c,a)}function o(a,c){return c.i=a.i,c.w=a.w,c.X=a.X.slice(),c}function i(a,c){a==null&&(a=+new Date);var u=new s(a),l=c&&c.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,m=(p+d)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,l&&(l.X&&o(l,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xor4096=i})(un,n,!1)})(Jm);var eg={exports:{}};(function(n){(function(e,t,r){function s(a){var c=this,u="";c.next=function(){var h=c.b,p=c.c,d=c.d,m=c.a;return h=h<<25^h>>>7^p,p=p-d|0,d=d<<24^d>>>8^m,m=m-h|0,c.b=h=h<<20^h>>>12^p,c.c=p=p-d|0,c.d=d<<16^p>>>16^m,c.a=m-h|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,a===Math.floor(a)?(c.a=a/4294967296|0,c.b=a|0):u+=a;for(var l=0;l<u.length+20;l++)c.b^=u.charCodeAt(l)|0,c.next()}function o(a,c){return c.a=a.a,c.b=a.b,c.c=a.c,c.d=a.d,c}function i(a,c){var u=new s(a),l=c&&c.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,d=(u.next()>>>0)/4294967296,m=(p+d)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,l&&(typeof l=="object"&&o(l,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.tychei=i})(un,n,!1)})(eg);var tg={exports:{}};const QS={},ZS=Object.freeze(Object.defineProperty({__proto__:null,default:QS},Symbol.toStringTag,{value:"Module"})),JS=Y0(ZS);(function(n){(function(e,t,r){var s=256,o=6,i=52,a="random",c=r.pow(s,o),u=r.pow(2,i),l=u*2,h=s-1,p;function d($,N,_){var O=[];N=N==!0?{entropy:!0}:N||{};var D=x(y(N.entropy?[$,S(t)]:$==null?w():$,3),O),F=new m(O),L=function(){for(var z=F.g(o),j=c,K=0;z<u;)z=(z+K)*s,j*=s,K=F.g(1);for(;z>=l;)z/=2,j/=2,K>>>=1;return(z+K)/j};return L.int32=function(){return F.g(4)|0},L.quick=function(){return F.g(4)/4294967296},L.double=L,x(S(F.S),t),(N.pass||_||function(z,j,K,Y){return Y&&(Y.S&&g(Y,F),z.state=function(){return g(F,{})}),K?(r[a]=z,j):z})(L,D,"global"in N?N.global:this==r,N.state)}function m($){var N,_=$.length,O=this,D=0,F=O.i=O.j=0,L=O.S=[];for(_||($=[_++]);D<s;)L[D]=D++;for(D=0;D<s;D++)L[D]=L[F=h&F+$[D%_]+(N=L[D])],L[F]=N;(O.g=function(z){for(var j,K=0,Y=O.i,te=O.j,re=O.S;z--;)j=re[Y=h&Y+1],K=K*s+re[h&(re[Y]=re[te=h&te+j])+(re[te]=j)];return O.i=Y,O.j=te,K})(s)}function g($,N){return N.i=$.i,N.j=$.j,N.S=$.S.slice(),N}function y($,N){var _=[],O=typeof $,D;if(N&&O=="object")for(D in $)try{_.push(y($[D],N-1))}catch{}return _.length?_:O=="string"?$:$+"\0"}function x($,N){for(var _=$+"",O,D=0;D<_.length;)N[h&D]=h&(O^=N[h&D]*19)+_.charCodeAt(D++);return S(N)}function w(){try{var $;return p&&($=p.randomBytes)?$=$(s):($=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues($)),S($)}catch{var N=e.navigator,_=N&&N.plugins;return[+new Date,e,_,e.screen,S(t)]}}function S($){return String.fromCharCode.apply(0,$)}if(x(r.random(),t),n.exports){n.exports=d;try{p=JS}catch{}}else r["seed"+a]=d})(typeof self<"u"?self:un,[],Math)})(tg);var eT=Xm.exports,tT=Ym.exports,nT=Qm.exports,rT=Zm.exports,sT=Jm.exports,oT=eg.exports,mr=tg.exports;mr.alea=eT;mr.xor128=tT;mr.xorwow=nT;mr.xorshift7=rT;mr.xor4096=sT;mr.tychei=oT;var Pc=mr;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fc{constructor(e,t,r,s,o){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=Pc.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,o,i;do s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class iT{constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const o=s||Math.random();this.randu=Pc.alea(o.toString()),this.randn=new Fc(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,o,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<t||Math.log(o)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class aT{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Pc.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cT(n,e,t=1,r="float32",s){if(t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const o=new iT(e,t,r,s),i=Le(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const uT=I({randomGamma_:cT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lT(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new Fc(e,t,r,!1,s),i=Le(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const ng=I({randomNormal_:lT});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hT(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return ng(n,0,1,e,t)}const pT=I({randomStandardNormal_:hT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dT(n,e=0,t=1,r="float32",s){const o=Le(n,r),i=new aT(e,t,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const rg=I({randomUniform_:dT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Is(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return A.runKernel(Rd,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fT(n){const t={x:T(n,"x","reciprocal")};return A.runKernel(Ad,t)}const mT=I({reciprocal_:fT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(n){const t={x:T(n,"x","relu")};return A.runKernel(Dd,t)}const si=I({relu_:gT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yT(n){const t={x:T(n,"x","relu6")};return A.runKernel(Md,t)}const sg=I({relu6_:yT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xT(n,e){const r={x:T(n,"x","reverse")},s={dims:e};return A.runKernel(Bd,r,s)}const lr=I({reverse_:xT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bT(n){const e=T(n,"x","reverse");return k(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),lr(e,0)}const vT=I({reverse1d_:bT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wT(n,e){const t=T(n,"x","reverse");return k(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),lr(t,e)}const CT=I({reverse2d_:wT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ST(n,e){const t=T(n,"x","reverse");return k(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),lr(t,e)}const TT=I({reverse3d_:ST});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $T(n,e){const t=T(n,"x","reverse");return k(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),lr(t,e)}const ET=I({reverse4d_:$T});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kT(n){const t={x:T(n,"x","round")};return A.runKernel(Vd,t)}const og=I({round_:kT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NT(n){const t={x:T(n,"x","rsqrt","float32")};return A.runKernel(Ud,t)}const IT=I({rsqrt_:NT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _T(n){const t={x:T(n,"x","selu")};return A.runKernel(jd,t)}const RT=I({selu_:_T});function OT(n,e,t,r,s,o=[1,1],i="NHWC"){const a=T(n,"x","separableConv2d"),c=T(e,"depthwiseFilter","separableConv2d"),u=T(t,"pointwiseFilter","separableConv2d");let l=a,h=!1;if(a.rank===3&&(h=!0,l=V(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");k(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),k(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),k(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),k(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),k(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const p=c.shape[2],d=c.shape[3];k(u.shape[2]===p*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*d}, but got ${u.shape[2]}.`);const m=kc(l,c,r,s,i,o),y=ti(m,u,1,"valid",i);return h?V(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const AT=I({separableConv2d_:OT});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function DT(n,e){const t=T(n,"x","setdiff1d"),r=T(e,"y","setdiff1d");k(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),k(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),k(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),o=await r.data(),i=new Set(o);let a=0;for(let l=0;l<s.length;l++)i.has(s[l])||a++;const c=new $s([a],t.dtype),u=new $s([a],"int32");for(let l=0,h=0;l<s.length;l++)i.has(s[l])||(c.values[h]=s[l],u.values[h]=l,h++);return[c.toTensor(),u.toTensor()]}const PT=DT;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(n){const t={x:T(n,"x","sign")};return A.runKernel(Xd,t)}const LT=I({sign_:FT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(n){const t={x:T(n,"x","sin","float32")};return A.runKernel(Kd,t)}const BT=I({sin_:MT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VT(n){const t={x:T(n,"x","sinh")};return A.runKernel(qd,t)}const UT=I({sinh_:VT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zT(n,e,t){const r=T(n,"x","slice1d");return k(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),oe(r,[e],[t])}const WT=I({slice1d_:zT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GT(n,e,t){const r=T(n,"x","slice2d");return k(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),oe(r,e,t)}const jT=I({slice2d_:GT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HT(n,e,t){const r=T(n,"x","slice3d");return k(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),oe(r,e,t)}const KT=I({slice3d_:HT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qT(n,e,t){const r=T(n,"x","slice4d");return k(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),oe(r,e,t)}const XT=I({slice4d_:qT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YT(n,e=-1){const t=T(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return A.runKernel(nf,r,s)}const QT=I({softmax_:YT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZT(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return A.runKernel(Dp,e)}const Lc=I({fft_:ZT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JT(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return A.runKernel(Gp,e)}const Mo=I({ifft_:JT});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=V(n,[t,e]);r=Mo(s)}else{const s=[t,2*(e-1)],o=V(Es(n),[t,e]),i=V(Zo(n),[t,e]),a=lr(oe(o,[0,1],[t,e-2]),1),c=ee(lr(oe(i,[0,1],[t,e-2]),1),he(-1)),u=Ge([o,a],1),l=Ge([i,c],1),h=V(Bn(u,l),[s[0],s[1]]);r=Mo(h)}if(r=Es(r),n.rank===3&&n.shape[0]!==0){const s=r,o=n.shape[0];r=V(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const ig=I({irfft_:e2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2(n,e,t=0){const s={x:T(n,"x","split")},o={numOrSizeSplits:e,axis:t};return A.runKernel(tf,s,o)}const _s=I({split_:t2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2(n,e){k(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const m=n.shape.map(y=>0),g=n.shape.map(y=>y);g[n.shape.length-1]=e,s=oe(n,m,g),t=e}else if(e!=null&&e>t){const m=n.shape.map(g=>g);m[n.shape.length-1]=e-t,s=Ge([n,Vn(m)],n.shape.length-1),t=e}else s=n;const o=Nc(s),i=V(Bn(s,o),[r,t]),a=Lc(i),c=Math.floor(t/2)+1,u=Es(a),l=Zo(a),h=_s(u,[c,t-c],u.shape.length-1),p=_s(l,[c,t-c],l.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=c,V(Bn(h[0],p[0]),d)}const Mc=I({rfft_:n2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(n,e){let t=T(n,"a","squaredDifference"),r=T(e,"b","squaredDifference");[t,r]=Be(t,r),me(t.shape,r.shape);const s={a:t,b:r},o={};return A.runKernel(uf,s,o)}const ag=I({squaredDifference_:r2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(n,e){const t=T(n,"x","squeeze","string_or_numeric");return V(t,zn(t.shape,e).newShape)}const Ce=I({squeeze_:s2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2(n,e=0){const t=Ro(n,"tensors","stack","string_or_numeric");k(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&k(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return A.runKernel(Td,r,s)}const $n=I({stack_:o2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(n,e=0){const r={x:T(n,"x","step")},s={alpha:e};return A.runKernel(Sf,r,s)}const cg=I({step_:i2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2(n,e,t,r,s=0,o=0,i=0,a=0,c=0){const l={x:T(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};return A.runKernel(lf,l,h)}const c2=I({stridedSlice_:a2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u2(n){const t={x:T(n,"x","tan","float32")};return A.runKernel(mf,t)}const l2=I({tan_:u2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(n,e){Kr(n);const t=Wn(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Gn(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zt(n,e,t){if(Kr(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Wn(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Gn(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n,e,t){if(Kr(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Wn(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Gn(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p2(n,e,t){if(Kr(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Wn(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Gn(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d2(n,e,t){if(Kr(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Wn(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Gn(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2(n,e=1,t=!0){const r=T(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},i={k:e,sorted:t},[a,c]=A.runKernel(yf,o,i);return{values:a,indices:c}}const m2=I({topk_:f2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g2(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Fc(e,t,r,!0,s),i=Le(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const y2=I({truncatedNormal_:g2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2(n,e=0){const t=T(n,"x","unique","string_or_numeric");k(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[o,i]=A.runKernel(bf,r,s);return{values:o,indices:i}}const b2=I({unique_:x2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2(n,e,t){const r=T(n,"x","unsortedSegmentSum"),s=T(e,"segmentIds","unsortedSegmentSum","int32");k(Fr(t),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},i={numSegments:t};return A.runKernel(wf,o,i)}const w2=I({unsortedSegmentSum_:v2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2(n,e=0){const t=T(n,"x","unstack","string_or_numeric");k(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return A.runKernel(vf,r,s)}const gr=I({unstack_:C2});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2(n,e){return Ac(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2(n,e=!0,t,r){return A.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ug(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const r=Le(n,"int32"),s=Le([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const i=r.indexToLoc(t[o]),a=o*n.length;s.values.set(i,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $2(n){const e=T(n,"condition","whereAsync","bool"),t=await e.data(),r=ug(e.shape,t);return n!==e&&e.dispose(),r}const lg=$2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function E2(n,e,t){const r=T(n,"tensor","boolMask"),s=T(e,"mask","boolMask","bool"),o=t==null?0:t,i=s.rank,a=r.shape;k(i>0,()=>"mask cannot be scalar"),Tt(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let g=o;g<o+i;g++)c*=a[g];const u=a.slice(0,o).concat([c],a.slice(o+i)),l=V(r,u),h=V(s,[-1]),p=await lg(h),d=Ce(p,[1]),m=Fm(l,d,o);return n!==r&&r.dispose(),e!==s&&s.dispose(),d.dispose(),l.dispose(),h.dispose(),p.dispose(),m}const k2=E2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2(n,e,t,r,s=!0){const o=T(n,"v","movingAverage"),i=T(e,"x","movingAverage"),a=T(t,"decay","movingAverage");K1(o,i),k(Me(o.shape,i.shape),()=>"Shape mismatch in v and x");const c=he(1),u=ce(c,a);let l=ee(ce(i,o),u);if(s){k(r!=null,()=>"When using zeroDebias: true, step is required.");const h=T(r,"step","movingAverage");l=ve(l,ce(c,Rc(a,h)))}return ye(o,l)}const I2=I({movingAverage_:N2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2(n,e,t){const r=T(n,"indices","scatterND","int32"),s=T(e,"updates","scatterND");um(s,r,t);const o={indices:r,updates:s},i={shape:t};return A.runKernel(zd,o,i)}const R2=I({scatterND_:_2});function O2(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2(n,e,t,r=0){const s=T(n,"sparseIndices","sparseToDense","int32"),o=T(e,"sparseValues","sparseToDense","string_or_numeric"),i=T(r,"defaultValue","sparseToDense",o.dtype);O2(s,o,t,i);const a={sparseIndices:s,sparseValues:o,defaultValue:i},c={outputShape:t};return A.runKernel(cf,a,c)}const D2=I({sparseToDense_:A2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2(n,e){const t=T(e,"indices","gatherND","int32"),s={params:T(n,"x","gatherND","string_or_numeric"),indices:t};return A.runKernel(Up,s)}const F2=I({gatherND_:P2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L2(n,e){if(e==null)return n.shape.slice();if(Me(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2(n,e,t,r){const s=T(n,"x","dropout");if(k(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),k(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Fe?s.clone():s;const o=L2(s,t),i=1-e,a=ve(Pm(ye(rg(o,0,1,"float32",r),i)),i);return ee(s,a)}const B2=I({dropout_:M2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hg(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Bc(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+r-1);s[o]=e-t*Math.cos(i)}return Ze(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function V2(n,e,t=1){const r=T(n,"predictions","inTopK"),s=T(e,"targets","inTopK");k(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),k(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Tt(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];k(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const i=await r.data(),a=await s.data(),[c,u]=[i.length/o,o],l=Cn("bool",c);for(let h=0;h<c;h++){const p=h*u,d=i.subarray(p,p+u),m=[];for(let g=0;g<d.length;g++)m.push({value:d[g],index:g});m.sort((g,y)=>y.value-g.value),l[h]=0;for(let g=0;g<t;g++)if(m[g].index===a[h]){l[h]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),ln(l,s.shape,"bool")}const U2=V2;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(n,e,t,r,s,o="NHWC",i){let a=n;n.rank===3&&(a=V(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=V(e,[1,e.shape[0],e.shape[1],e.shape[2]])),k(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),k(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),k(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=o==="NHWC"?a.shape[3]:a.shape[1],l=o==="NHWC"?c.shape[3]:c.shape[1];k(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),k(l===t[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${t[3]}).`),Wt("conv2dDerFilter",s,i);const h={x:a,dy:c},p={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:t};return A.runKernel(lp,h,p)}const W2=I({conv2DBackpropFilter_:z2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oi(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ee(n,cg(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function ii(n,e){let t=e;const r=om(n.shape,e.shape);return r.length>0&&(t=Ie(t,r)),V(t,n.shape)}function ai(n,e,t,r){if(e==="linear")return n;if(e==="relu")return si(n);if(e==="elu")return Rm(n);if(e==="relu6")return sg(n);if(e==="prelu")return qm(n,t);if(e==="leakyrelu")return Mm(n,r);if(e==="sigmoid")return vn(n);throw new Error(`Unknown fused activation ${e}.`)}const ci=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:l}){if(c=c||"linear",ci(A.state.gradientDepth,c)===!1){k(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let _=ti(n,e,t,r,s,o,i);return a!=null&&(_=ye(_,a)),ai(_,c,u,l)}const h=T(n,"x","conv2d","float32"),p=T(e,"filter","conv2d","float32");let d=h,m=!1;h.rank===3&&(m=!0,d=V(h,[1,h.shape[0],h.shape[1],h.shape[2]])),k(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),k(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Wt("fused conv2d",r,i);const g=s==="NHWC"?d.shape[3]:d.shape[1];k(p.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`),k(bt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const y=$t(d.shape,p.shape,t,o,r,i);let x;a!=null&&(x=T(a,"bias","fused conv2d"),[x]=Be(x,h),s==="NHWC"?me(y.outShape,x.shape):(k(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),k(x.shape.length===0||x.shape[0]===y.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let w;if(u!=null){const _=u.shape;if(k(_.length<=1||_.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`),_.length===1)k(_[0]===1||_[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${y.outChannels}).`);else if(_.length===3)try{me(_,y.outShape)}catch{const D=`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(D)}w=T(u,"prelu weights","fused conv2d")}const S=(_,O)=>{k(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[D,F,L,z]=O,j=oi(_,L,c);k(ks(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const K=Im(F.shape,j,D,t,r),Y=W2(F,j,D.shape,t,r),te=[K,Y];if(z!=null){const re=ii(z,j);te.push(re)}return te},$={x:d,filter:p,bias:x,preluActivationWeights:w},N={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:l};return a==null?Tn((O,D,F)=>{let L=A.runKernel(oa,$,N);return F([D,O,L]),m&&(L=V(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:S}})(d,p):Tn((O,D,F,L)=>{let z=A.runKernel(oa,$,N);return L([D,O,z,F]),m&&(z=V(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:S}})(d,p,x)}const j2=I({fusedConv2d_:G2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2(n,e,t,r,s,o=[1,1],i){let a=n;n.rank===3&&(a=V(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:c},l={strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:t};return A.runKernel(Cp,u,l)}const K2=I({depthwiseConv2dNativeBackpropFilter_:H2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(n,e,t,r,s,o=[1,1],i){let a=e,c=!1;e.rank===3&&(c=!0,a=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},l={strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:n},h=A.runKernel(Sp,u,l);return c?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const X2=I({depthwiseConv2dNativeBackpropInput_:q2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:l}){if(ci(A.state.gradientDepth,c)===!1){let N=kc(n,e,t,r,s,o,i);return a!=null&&(N=ye(N,a)),ai(N,c,u,l)}const h=T(n,"x","depthwiseConv2d","float32"),p=T(e,"filter","depthwiseConv2d","float32");let d=h,m=!1;h.rank===3&&(m=!0,d=V(h,[1,h.shape[0],h.shape[1],h.shape[2]])),k(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),k(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),k(d.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),o==null&&(o=[1,1]),k(bt(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Wt("fused depthwiseConv2d",r,i);const g=$t(d.shape,p.shape,t,o,r,i,!0);let y;a!=null&&(y=T(a,"bias","fused conv2d"),[y]=Be(y,h),me(g.outShape,y.shape));let x;u!=null&&(x=T(u,"prelu weights","fused depthwiseConv2d"));const w=(N,_)=>{k(ks(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[O,D,F,L]=_,z=oi(N,F,c),j=X2(D.shape,z,O,t,r,o,i),K=K2(D,z,O.shape,t,r,o,i);if(L!=null){const Y=ii(y,z);return[j,K,Y]}return[j,K]},S={x:d,filter:p,bias:y,preluActivationWeights:x},$={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:c,leakyreluAlpha:l};return a==null?Tn((_,O,D)=>{let F=A.runKernel(ia,S,$);return D([O,_,F]),m&&(F=V(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:w}})(d,p):Tn((_,O,D,F)=>{let L=A.runKernel(ia,S,$);return F([O,_,L,D]),m&&(L=V(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:w}})(d,p,y)}const Q2=I({fusedDepthwiseConv2d_:Y2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z2({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(ci(A.state.gradientDepth,o)===!1){let z=Se(n,e,t,r);return s!=null&&(z=ye(z,s)),ai(z,o,i,a)}let c=T(n,"a","fused matMul"),u=T(e,"b","fused matMul");[c,u]=Be(c,u);const l=t?c.shape[c.rank-2]:c.shape[c.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=t?c.shape[c.rank-1]:c.shape[c.rank-2],d=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=c.shape.slice(0,-2),g=u.shape.slice(0,-2),y=G(m),x=G(g);k(l===h,()=>`Error in fused matMul: inner shapes (${l}) and (${h}) of Tensors with shapes ${c.shape} and ${u.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=me(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,d]),$=t?V(c,[y,l,p]):V(c,[y,p,l]),N=r?V(u,[x,d,h]):V(u,[x,h,d]);let _;s!=null&&(_=T(s,"bias","fused matMul"),[_]=Be(_,c),me(S,_.shape));let O;i!=null&&(O=T(i,"prelu weights","fused matMul"));const D=(z,j)=>{const[K,Y,te,re]=j,ae=oi(V(z,te.shape),te,o);let be,Ve;if(!t&&!r?(be=Se(ae,Y,!1,!0),Ve=Se(K,ae,!0,!1)):!t&&r?(be=Se(ae,Y,!1,!1),Ve=Se(ae,K,!0,!1)):t&&!r?(be=Se(Y,ae,!1,!0),Ve=Se(K,ae,!1,!1)):(be=Se(Y,ae,!0,!0),Ve=Se(ae,K,!0,!0)),s!=null){const Kt=ii(re,ae);return[be,Ve,Kt]}else return[be,Ve]},F={a:$,b:N,bias:_,preluActivationWeights:O},L={transposeA:t,transposeB:r,activation:o,leakyreluAlpha:a};return s==null?Tn((j,K,Y)=>{const te=A.runKernel(sa,F,L);return Y([j,K,te]),{value:V(te,S),gradFunc:D}})($,N):Tn((j,K,Y,te)=>{const re=A.runKernel(sa,F,L);return te([j,K,re,Y]),{value:V(re,S),gradFunc:D}})($,N,_)}const J2=I({fusedMatMul_:Z2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$=Object.freeze(Object.defineProperty({__proto__:null,conv2d:j2,depthwiseConv2d:Q2,matMul:J2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$(n){return Bc(n,.54,.46)}const n$=I({hammingWindow_:t$});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(n){return Bc(n,.5,.5)}const pg=I({hannWindow_:r$});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(n,e,t,r=!1,s=0){let o=0;const i=[];for(;o+e<=n.size;)i.push(oe(n,o,e)),o+=t;if(r)for(;o<n.size;){const a=o+e-n.size,c=Ge([oe(n,o,e-a),ei([a],s)]);i.push(c),o+=t}return i.length===0?zt([],[0,e]):V(Ge(i),[i.length,e])}const dg=I({frame_:s$});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$(n,e,t,r,s=pg){r==null&&(r=hg(e));const o=dg(n,e,t),i=ee(o,s(e));return Mc(i,r)}const i$=I({stft_:o$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n,e,t,r,s="bilinear",o=0){const i=T(n,"image","cropAndResize"),a=T(e,"boxes","cropAndResize","float32"),c=T(t,"boxInd","cropAndResize","int32"),u=a.shape[0];k(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),k(c.rank===1&&c.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),k(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),k(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),k(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const l={image:i,boxes:a,boxInd:c},h={method:s,extrapolationValue:o,cropSize:r};return A.runKernel(xp,l,h)}const c$=I({cropAndResize_:a$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(n){const e=T(n,"image","flipLeftRight","float32");k(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return A.runKernel(Fp,t,{})}const l$=I({flipLeftRight_:u$});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$(n){const e=T(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];k(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),k(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,Ss(e,s)}const p$=I({grayscaleToRGB_:h$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(n,e,t=0,r=.5){const s=T(n,"image","rotateWithOffset","float32");k(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},i={radians:e,fillValue:t,center:r};return A.runKernel(Tf,o,i)}const f$=I({rotateWithOffset_:d$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yr(n,e,t,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=n.shape[0];return t=Math.min(t,i),k(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),k(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),k(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),k(e.rank===1,()=>"scores must be a 1D tensor"),k(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),k(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=T(n,"boxes","nonMaxSuppression","float32"),i=T(e,"scores","nonMaxSuppression","float32"),a=Yr(o,i,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const c={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return A.runKernel(bd,{boxes:o,scores:i},c)}const g$=I({nonMaxSuppression_:m$});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$(n,e,t){const r=x$(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function x$(n,e,t){return v$(n,e,t||b$)}function b$(n,e){return n>e?1:n<e?-1:0}function v$(n,e,t){let r=0,s=n.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=t(e,n[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fg(n,e,t,r,s){return Vc(n,e,t,r,s,0)}function mg(n,e,t,r,s,o){return Vc(n,e,t,r,s,0,!1,o,!0)}function gg(n,e,t,r,s,o){return Vc(n,e,t,r,s,o,!0)}function Vc(n,e,t,r,s,o,i=!1,a=!1,c=!1){const u=[];for(let y=0;y<e.length;y++)e[y]>s&&u.push({score:e[y],boxIndex:y,suppressBeginIndex:0});u.sort(cl);const l=o>0?-.5/o:0,h=[],p=[];for(;h.length<t&&u.length>0;){const y=u.pop(),{score:x,boxIndex:w,suppressBeginIndex:S}=y;if(x<s)break;let $=!1;for(let N=h.length-1;N>=S;--N){const _=w$(n,w,h[N]);if(_>=r){$=!0;break}if(y.score=y.score*C$(r,l,_),y.score<=s)break}y.suppressBeginIndex=h.length,$||(y.score===x?(h.push(w),p.push(y.score)):y.score>s&&y$(u,y,cl))}const d=h.length,m=t-d;a&&m>0&&(h.push(...new Array(m).fill(0)),p.push(...new Array(m).fill(0)));const g={selectedIndices:h};return i&&(g.selectedScores=p),c&&(g.validOutputs=d),g}function w$(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),l=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),d=(a-o)*(c-i),m=(h-u)*(p-l);if(d<=0||m<=0)return 0;const g=Math.max(o,u),y=Math.max(i,l),x=Math.min(a,h),w=Math.min(c,p),S=Math.max(x-g,0)*Math.max(w-y,0);return S/(d+m-S)}function C$(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function cl(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function S$(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=T(n,"boxes","nonMaxSuppressionAsync"),i=T(e,"scores","nonMaxSuppressionAsync"),a=Yr(o,i,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const c=await Promise.all([o.data(),i.data()]),u=c[0],l=c[1],{selectedIndices:h}=fg(u,l,t,r,s);return o!==n&&o.dispose(),i!==e&&i.dispose(),Ze(h,"int32")}const T$=S$;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=T(n,"boxes","nonMaxSuppression"),a=T(e,"scores","nonMaxSuppression"),c=Yr(i,a,t,r,s,o);t=c.maxOutputSize,r=c.iouThreshold,s=c.scoreThreshold,o=c.softNmsSigma;const u={boxes:i,scores:a},l={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},h=A.runKernel(wd,u,l);return{selectedIndices:h[0],selectedScores:h[1]}}const E$=I({nonMaxSuppressionWithScore_:$$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function k$(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=T(n,"boxes","nonMaxSuppressionAsync"),a=T(e,"scores","nonMaxSuppressionAsync"),c=Yr(i,a,t,r,s,o);t=c.maxOutputSize,r=c.iouThreshold,s=c.scoreThreshold,o=c.softNmsSigma;const u=await Promise.all([i.data(),a.data()]),l=u[0],h=u[1],{selectedIndices:p,selectedScores:d}=gg(l,h,t,r,s,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Ze(p,"int32"),selectedScores:Ze(d)}}const N$=k$;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=T(n,"boxes","nonMaxSuppression"),a=T(e,"scores","nonMaxSuppression"),c=Yr(i,a,t,r,s,null),u=c.maxOutputSize,l=c.iouThreshold,h=c.scoreThreshold,p={boxes:i,scores:a},d={maxOutputSize:u,iouThreshold:l,scoreThreshold:h,padToMaxOutputSize:o},m=A.runKernel(vd,p,d);return{selectedIndices:m[0],validOutputs:m[1]}}const _$=I({nonMaxSuppressionPadded_:I$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function R$(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=T(n,"boxes","nonMaxSuppressionAsync"),a=T(e,"scores","nonMaxSuppressionAsync"),c=Yr(i,a,t,r,s,null),u=c.maxOutputSize,l=c.iouThreshold,h=c.scoreThreshold,[p,d]=await Promise.all([i.data(),a.data()]),{selectedIndices:m,validOutputs:g}=mg(p,d,u,l,h,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Ze(m,"int32"),validOutputs:he(g,"int32")}}const O$=R$;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A$(n,e,t=!1,r=!1){const s=T(n,"images","resizeBilinear");k(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),k(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),k(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},c={alignCorners:t,halfPixelCenters:r,size:e},u=A.runKernel(Ld,a,c);return i?V(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const D$=I({resizeBilinear_:A$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(n,e,t=!1,r=!1){const s=T(n,"images","resizeNearestNeighbor");k(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),k(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),k(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),k(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},c={alignCorners:t,halfPixelCenters:r,size:e},u=A.runKernel(Fd,a,c);return i?V(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const F$=I({resizeNearestNeighbor_:P$});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n,e="binary",t=!1,r=.5){const s=T(n,"image","threshold"),o=.2989,i=.587,a=.114,c=s.shape[0]*s.shape[1];let u=ee(Ze([r]),255),l,h,p,d;if(k(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),k(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),k(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),k(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[l,h,p]=_s(s,[1,1,1],-1);const y=ee(l,o),x=ee(h,i),w=ee(p,a);d=ye(ye(y,x),w)}else d=n;if(e==="otsu"){const y=km(Ae(og(d),"int32"),ln([]),256);u=M$(y,c)}const m=t?Oc(d,u):ri(d,u);return Ae(ee(m,255),"int32")}function M$(n,e){let t=Ze([-1]),r=Ze([0]),s=Ze([0]),o,i,a,c,u,l;for(let h=0;h<n.size-1;h++){o=oe(n,0,h+1),i=oe(n,h+1),u=ve(Ie(o),e),l=ve(Ie(i),e);const p=Ie(ee(o,Is(0,o.size)));a=ve(p,Ie(o));const d=ei(i.shape,o.size),m=ye(Is(0,i.size),d),g=ee(i,m);c=ve(Ie(g),Ie(i));const y=ce(a,c),x=ce(a,c),w=ee(u,l);s=ee(ee(w,y),x);const S=ri(s,r);r=Ur(S,s,r),t=Ur(S,Ze([h]),t)}return t}const B$=I({threshold_:L$});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(n,e,t="nearest",r="constant",s=0,o){const i=T(n,"image","transform","float32"),a=T(e,"transforms","transform","float32");k(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),k(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const c={image:i,transforms:a},u={interpolation:t,fillMode:r,fillValue:s,outputShape:o};return A.runKernel(xf,c,u)}const U$=I({transform_:V$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n,e,t){k(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),k(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const r=T(n,"a","bandPart");k(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(t<=i))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`);e<0&&(e=o),t<0&&(t=i);const a=V(Is(0,o,1,"int32"),[-1,1]),c=Is(0,i,1,"int32"),u=ce(a,c),l=Fo(Oc(u,he(+e,"int32")),Lm(u,he(-t,"int32"))),h=Vn([o,i],r.dtype);return V($n(gr(V(r,[-1,o,i])).map(p=>Ur(l,p,h))),s)}const W$=I({bandPart_:z$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n){let e;if(Array.isArray(n)){e=!1,k(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)k(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else e=!0,n=_s(n,n.shape[0],0).map(s=>Ce(s,[0]));k(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(A.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=ee(Ie(ee(t[i],o)),t[i]);o=ce(o,a)}return ve(o,ni(o,"euclidean"))}));return e?$n(t,0):t}const j$=I({gramSchmidt_:G$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(n,e=!1){if(k(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return ul(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((c,u)=>c*u),r=gr(V(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];r.forEach(c=>{const[u,l]=ul(c,e);s.push(u),o.push(l)});const i=V($n(s,0),n.shape),a=V($n(o,0),n.shape);return[i,a]}}function ul(n,e=!1){return A.tidy(()=>{k(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=Dm(t),o=Ln(n);const i=zt([[1]],[1,1]);let a=Ln(i);const c=t>=r?r:t;for(let u=0;u<c;++u){const l=o,h=a,p=s;[a,o,s]=A.tidy(()=>{const d=oe(o,[u,u],[t-u,1]),m=ni(d),g=oe(o,[u,u],[1,1]),y=Ur(ri(g,0),zt([[-1]]),zt([[1]])),x=ce(g,ee(y,m)),w=ve(d,x);w.shape[0]===1?a=Ln(i):a=Ge([i,oe(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const S=bn(ve(Se(y,x),m)),$=oe(o,[u,0],[t-u,r]),N=ee(S,a),_=wa(a);if(u===0)o=ce($,Se(N,Se(_,$)));else{const F=ce($,Se(N,Se(_,$)));o=Ge([oe(o,[0,0],[u,r]),F],0)}const O=wa(N),D=oe(s,[0,u],[t,s.shape[1]-u]);if(u===0)s=ce(D,Se(Se(D,a),O));else{const F=ce(D,Se(Se(D,a),O));s=Ge([oe(s,[0,0],[t,u]),F],1)}return[a,o,s]}),tt([l,h,p])}return!e&&t>r&&(s=oe(s,[0,0],[t,r]),o=oe(o,[0,0],[r,r])),[s,o]})}const K$=I({qr_:H$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ht;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ht||(ht={}));function q$(n,e,t=ht.SUM_BY_NONZERO_WEIGHTS){const r=T(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=T(e,"weights","computeWeightedLoss"));const o=s==null?r:ee(r,s);if(t===ht.NONE)return o;if(t===ht.SUM)return Ie(o);if(t===ht.MEAN){if(s==null)return Lo(o);{const i=r.size/s.size,a=ve(Ie(o),Ie(s));return i>1?ve(a,he(i)):a}}if(t===ht.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ve(Ie(o),he(r.size));{const i=ee(s,tr(r.shape)),a=Ae(Ie(Hm(i,he(0))),"float32");return ve(Ie(o),a)}}throw Error(`Unknown reduction: ${t}`)}const En=I({computeWeightedLoss_:q$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n,e,t,r=ht.SUM_BY_NONZERO_WEIGHTS){const s=T(n,"labels","absoluteDifference"),o=T(e,"predictions","absoluteDifference");let i=null;t!=null&&(i=T(t,"weights","absoluteDifference")),Tt(s.shape,o.shape,"Error in absoluteDifference: ");const a=Pt(ce(s,o));return En(a,i,r)}const Y$=I({absoluteDifference_:X$});function Q$(n,e,t,r,s=ht.SUM_BY_NONZERO_WEIGHTS){const o=T(n,"labels","cosineDistance"),i=T(e,"predictions","cosineDistance");let a=null;r!=null&&(a=T(r,"weights","cosineDistance")),Tt(o.shape,i.shape,"Error in cosineDistance: ");const c=he(1),u=ce(c,Ie(ee(o,i),t,!0));return En(u,a,s)}const Z$=I({cosineDistance_:Q$});function J$(n,e,t,r=ht.SUM_BY_NONZERO_WEIGHTS){let s=T(n,"labels","hingeLoss");const o=T(e,"predictions","hingeLoss");let i=null;t!=null&&(i=T(t,"weights","hingeLoss")),Tt(s.shape,o.shape,"Error in hingeLoss: ");const a=he(1);s=ce(ee(he(2),s),a);const c=si(ce(a,ee(s,o)));return En(c,i,r)}const eE=I({hingeLoss_:J$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tE(n,e,t,r=1,s=ht.SUM_BY_NONZERO_WEIGHTS){const o=T(n,"labels","huberLoss"),i=T(e,"predictions","huberLoss");let a=null;t!=null&&(a=T(t,"weights","huberLoss")),Tt(o.shape,i.shape,"Error in huberLoss: ");const c=he(r),u=Pt(ce(i,o)),l=Dc(u,c),h=ce(u,l),p=ye(ee(he(.5),Us(l)),ee(c,h));return En(p,a,s)}const nE=I({huberLoss_:tE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rE(n,e,t,r=1e-7,s=ht.SUM_BY_NONZERO_WEIGHTS){const o=T(n,"labels","logLoss"),i=T(e,"predictions","logLoss");let a=null;t!=null&&(a=T(t,"weights","logLoss")),Tt(o.shape,i.shape,"Error in logLoss: ");const c=he(1),u=he(r),l=bn(ee(o,Ns(ye(i,u)))),h=ee(ce(c,o),Ns(ye(ce(c,i),u))),p=ce(l,h);return En(p,a,s)}const sE=I({logLoss_:rE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oE(n,e,t,r=ht.SUM_BY_NONZERO_WEIGHTS){const s=T(n,"labels","meanSquaredError"),o=T(e,"predictions","meanSquaredError");let i=null;t!=null&&(i=T(t,"weights","meanSquaredError")),Tt(s.shape,o.shape,"Error in meanSquaredError: ");const a=ag(s,o);return En(a,i,r)}const iE=I({meanSquaredError_:oE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(n,e){const t=T(n,"labels","sigmoidCrossEntropyWithLogits"),r=T(e,"logits","sigmoidCrossEntropyWithLogits");Tt(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=si(r),o=ee(r,t),i=Bm(Sn(bn(Pt(r))));return ye(ce(s,o),i)}function cE(n,e,t,r=0,s=ht.SUM_BY_NONZERO_WEIGHTS){let o=T(n,"multiClassLabels","sigmoidCrossEntropy");const i=T(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=T(t,"weights","sigmoidCrossEntropy")),Tt(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=he(r),l=he(1),h=he(.5);o=ye(ee(o,ce(l,u)),ee(h,u))}const c=aE(o,i);return En(c,a,s)}const uE=I({sigmoidCrossEntropy_:cE});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lE(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Tn((s,o,i)=>{const c=Um(o,[t],!0),u=ce(Ae(o,"float32"),c);i([s,u]);const l=bn(ee(u,s));return{value:Ie(l,[t]),gradFunc:(d,m)=>{const[g,y]=m,x=Et(d.shape,[t]);return[ee(V(d,x),ce(Ae(g,"float32"),Sn(y))),ee(V(d,x),ce(Sn(y),Ae(g,"float32")))]}}})(n,e)}function hE(n,e,t,r=0,s=ht.SUM_BY_NONZERO_WEIGHTS){let o=T(n,"onehotLabels","softmaxCrossEntropy");const i=T(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=T(t,"weights","softmaxCrossEntropy")),Tt(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=he(r),l=he(1),h=he(o.shape[1]);o=ye(ee(o,ce(l,u)),ve(u,h))}const c=lE(o,i);return En(c,a,s)}const pE=I({softmaxCrossEntropy_:hE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(n,e,t,r){const s=T(n,"indices","sparseFillEmptyRows","int32"),o=T(e,"values","sparseFillEmptyRows"),i=T(t,"denseShape","sparseFillEmptyRows","int32"),a=T(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const c={indices:s,values:o,denseShape:i,defaultValue:a},u=A.runKernel(rf,c);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const fE=I({sparseFillEmptyRows_:dE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mE(n,e,t){const r=T(n,"inputIndices","sparseReshape","int32"),s=T(e,"inputShape","sparseReshape","int32"),o=T(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:r,inputShape:s,newShape:o},a=A.runKernel(sf,i);return{outputIndices:a[0],outputShape:a[1]}}const gE=I({sparseReshape_:mE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yE(n,e,t){const r=T(n,"data","sparseSegmentMean"),s=T(e,"indices","sparseSegmentMean","int32"),o=T(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return A.runKernel(of,i)}const xE=I({sparseSegmentMean_:yE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(n,e,t){const r=T(n,"data","sparseSegmentSum"),s=T(e,"indices","sparseSegmentSum","int32"),o=T(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return A.runKernel(af,i)}const vE=I({sparseSegmentSum_:bE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(n,e,t,r,s,o,i,a){const c=T(n,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error(`Data must be a vector, saw: ${c.shape}`);const u=T(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const l={separator:t,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a},h={data:c,dataSplits:u},p=A.runKernel(hf,h,l);return{nGrams:p[0],nGramsSplits:p[1]}}const CE=I({stringNGrams_:wE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(n,e,t=!0){const r=T(n,"input","stringSplit","string"),s=T(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:t},i={input:r,delimiter:s},a=A.runKernel(pf,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const TE=I({stringSplit_:SE});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $E(n,e){const t=T(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return A.runKernel(df,s,r)}const EE=I({stringToHashBucketFast_:$E});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kE={fft:Lc,ifft:Mo,rfft:Mc,irfft:ig},NE={hammingWindow:n$,hannWindow:pg,frame:dg,stft:i$},wn={flipLeftRight:l$,grayscaleToRGB:p$,resizeNearestNeighbor:F$,resizeBilinear:D$,rotateWithOffset:f$,cropAndResize:c$,nonMaxSuppression:g$,nonMaxSuppressionAsync:T$,nonMaxSuppressionWithScore:E$,nonMaxSuppressionWithScoreAsync:N$,nonMaxSuppressionPadded:_$,nonMaxSuppressionPaddedAsync:O$,threshold:B$,transform:U$},IE={bandPart:W$,gramSchmidt:j$,qr:K$},_E={absoluteDifference:Y$,computeWeightedLoss:En,cosineDistance:Z$,hingeLoss:eE,huberLoss:nE,logLoss:sE,meanSquaredError:iE,sigmoidCrossEntropy:uE,softmaxCrossEntropy:pE},RE={sparseFillEmptyRows:fE,sparseReshape:gE,sparseSegmentMean:xE,sparseSegmentSum:vE},OE={stringNGrams:CE,stringSplit:TE,stringToHashBucketFast:EE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AE=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function DE(){return new Promise(n=>AE(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yg(n,e){const t=n[0].length;n.forEach((s,o)=>{k(s.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),k(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,o)=>{for(let i=0;i<t;i++)k(i===e||s[i]===r[i],()=>`Error in concat${t}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function hr(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Zt;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Zt||(Zt={}));function xg(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const o=t[s],i=r[r.length-t.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+n}] = ${o} but shape[${s+n}] = ${a}`)}else r[i]=o}return r}function bg(n){const e={FIRST_DIM_SIZE:Zt.FIRST_DIM_SIZE,VALUE_ROWIDS:Zt.VALUE_ROWIDS,ROW_LENGTHS:Zt.ROW_LENGTHS,ROW_SPLITS:Zt.ROW_SPLITS,ROW_LIMITS:Zt.ROW_LIMITS,ROW_STARTS:Zt.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function vg(n){return n.length===0?0:n[0]===Zt.FIRST_DIM_SIZE?n.length-1:n.length}function wg(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const o=n[s],i=e[s+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-n.length}] = ${o} but ragged tensor input.flatValues.shape[${s-n.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uc=30;function ui(n){return n<=Uc?n:ea(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cg(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zc(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=e.length;for(let i=0;i<o;++i)s=s.concat([n[i+1]/e[i],e[i]]);s=s.concat(n.slice(o+1))}return s}function Wc(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Gc(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?r?s.push(e[o-1]*n[o]):s.push(n[o]/e[o-1]):s.push(n[o]);return s}function Sg(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function Tg(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $g=1.7580993408473768,Eg=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kg=.3275911,Ng=.254829592,Ig=-.284496736,_g=1.421413741,Rg=-1.453152027,Og=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function PE(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function FE(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function LE(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function ME(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function BE(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function VE(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:t,imag:r}}function UE(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ai="->",zE=/->/g,ll=",",hl="...";function Ag(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(zE,"").length)/Ai.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Ai}").`);const[r,s]=n.split(Ai);k(r.indexOf(hl)===-1,()=>`The ellipsis notation ("${hl}") is not supported yet.`);const o=r.split(ll),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let p=0;p<s.length;++p){const d=s[p];if(!o.some(m=>m.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let p=0;p<r.length;++p){const d=r[p];a.indexOf(d)===-1&&d!==ll&&a.push(d)}const c=new Array(o.length);for(let p=0;p<i;++p){if(new Set(o[p].split("")).size!==o[p].length)throw new Error(`Found duplicate axes in input component ${o[p]}. Support for duplicate axes in input is not implemented yet.`);c[p]=[];for(let d=0;d<o[p].length;++d)c[p].push(a.indexOf(o[p][d]))}const u=a.length,l=s.length,h=[];for(let p=l;p<u;++p)h.push(p);return{allDims:a,summedDims:h,idDims:c}}function Dg(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function Pg(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const o=t[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=o[i]:k(r[e[s][i]]===o[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function Fg(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<t.length;++i){const a=t[i],c=WE(e,a);for(const u of c)o.indexOf(u)===-1&&(r[i].push(u),o.push(u))}return{path:t,steps:r}}function Lg(n){return n.every((e,t)=>e===t)}function WE(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function Mg(n,e,t=0){let r=[];if(typeof e=="number")k(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);k(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,c)=>c>0?a+c:a);e[o]=n.shape[t]-i}k(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Vg(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function Ug(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zg(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Wg(n,e){return`size ${n} must be non-negative, not ${e}`}function Gg(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function jg(n,e){const t=G(n),r=G(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function Hg(n,e){const t=G(n),r=G(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Na(){return"segment ids must be >= 0"}function Kg(){return"segment ids are not increasing"}function qg(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Xg(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yg(n,e){let t=!1,r;for(n<=Uc?(r=n,t=!0):r=ea(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=ea(n,r+1);return r}function Qg(n,e,t){const r=[],s=n.length;for(let o=0;o<s;o++)o!==e?r.push(n[o]):r.push(t);return r}function Zg(n,e,t,r){const s=e.shape.length,o=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let h=0;h<r;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const i=n.shape[t],a=[];let c=1,u=1,l=1;for(let h=0;h<r;++h)a.push(n.shape[h]),c*=n.shape[h];for(let h=r;h<t;h++)a.push(n.shape[h]),u*=n.shape[h];for(let h=r;h<s;h++)a.push(e.shape[h]);for(let h=t+1;h<o;h++)a.push(n.shape[h]),l*=n.shape[h];return{batchSize:c,sliceSize:l,outerSize:u,dimSize:i,outputShape:a}}const GE=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:Yg,computeOutShape:Qg,collectGatherOpShapeInfo:Zg},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(n){try{return n.map(e=>Br(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Jg(n){return n.map(e=>sr(e))}const jE=Object.freeze(Object.defineProperty({__proto__:null,slice_util:lv,segment_util:GE,fromUint8ToStringArray:Rs,fromStringArrayToUint8:Jg,upcastType:pn,axesAreInnerMostDims:Ic,combineLocations:Om,computeOutAndReduceShapes:fn,expandShapeToKeepDim:Et,assertAxesAreInnerMostDims:nn,getAxesPermutation:Gt,getUndoAxesPermutation:_c,getInnerMostAxes:jt,getBroadcastDims:Do,getReductionAxes:om,assertAndGetBroadcastShape:me,assertParamsConsistent:yg,computeOutShape:hr,computeDilation2DInfo:Tm,computePool2DInfo:fr,computePool3DInfo:Bs,computeConv2DInfo:$t,computeConv3DInfo:Vs,computeDefaultPad:Ec,tupleValuesAreOne:ks,eitherStridesOrDilationsAreOne:bt,convertConv2DDataFormat:Xr,checkPadOnDimRoundingMode:Wt,getFusedDyActivation:oi,getFusedBiasGradient:ii,applyActivation:ai,shouldFuse:ci,get RowPartitionType(){return Zt},combineRaggedTensorToTensorShapes:xg,getRowPartitionTypesHelper:bg,getRaggedRank:vg,validateDefaultValueShape:wg,PARALLELIZE_THRESHOLD:Uc,computeOptimalWindowSize:ui,getImageCenter:Cg,getReshaped:zc,getPermuted:Wc,getReshapedPermuted:Gc,getSliceBeginCoords:Sg,getSliceSize:Tg,prepareAndValidate:am,validateUpdateShape:cm,validateInput:um,calculateShapes:Sc,SELU_SCALEALPHA:$g,SELU_SCALE:Eg,ERF_P:kg,ERF_A1:Ng,ERF_A2:Ig,ERF_A3:_g,ERF_A4:Rg,ERF_A5:Og,warn:Jt,log:$1,mergeRealAndImagArrays:ka,splitRealAndImagArrays:PE,complexWithEvenIndex:FE,complexWithOddIndex:LE,getComplexWithIndex:ME,assignToTypedArray:BE,exponents:VE,exponent:UE,decodeEinsumEquation:Ag,getEinsumPermutation:Dg,checkEinsumDimSizes:Pg,getEinsumComputePath:Fg,isIdentityPermutation:Lg,prepareSplitSize:Mg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Bg,getSparseFillEmptyRowsNegativeIndexErrorMessage:Vg,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Ug,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:zg,getSparseReshapeNegativeOutputDimErrorMessage:Wg,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Gg,getSparseReshapeInputOutputMultipleErrorMessage:jg,getSparseReshapeInputOutputMismatchErrorMessage:Hg,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Na,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Kg,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:qg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Xg},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE=M();HE.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Dt;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Dt||(Dt={}));var pl;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(pl||(pl={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KE={};function ey(n){return KE[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(n,e,t,r,s){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,c=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd;if(o.type==="tensor")return ot(e.inputNames[o.inputIndexStart],t,r,s);if(o.type==="tensors")return e.inputNames.slice(a,c).map(p=>ot(p,t,r,s));const u=ot(e.inputNames.slice(a)[0],t,r,s),l=u.dataSync();return o.type==="number"?l[0]:ta(u.shape,l)}const i=e.attrParams[n];return i&&i.value}function ot(n,e,t,r){const[s,o]=ft(n);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const i=t.currentContextIds.find(a=>!!e[Bo(s,a)]);return i!==void 0?e[Bo(s,i)][o]:void 0}function qE(n,e,t){return e[Bo(n,t.currentContextId)]}function on(n,e){const[t,r,s]=ft(n);return[Bo(t,e&&e.currentContextId),r,s]}function Bo(n,e){return e?`${n}-${e}`:n}function ft(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],r=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[t,s,r]}function go(n,e,t){let r=b("pad",n,e,t);if(r==="explicit"){r=b("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function gn(n){return n.kept?n:Ln(n)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XE=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],YE=Object.freeze(Object.defineProperty({__proto__:null,json:XE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QE=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ZE=Object.freeze(Object.defineProperty({__proto__:null,json:QE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JE=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],ek=Object.freeze(Object.defineProperty({__proto__:null,json:JE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tk=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],nk=Object.freeze(Object.defineProperty({__proto__:null,json:tk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rk=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],sk=Object.freeze(Object.defineProperty({__proto__:null,json:rk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ok=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ik=Object.freeze(Object.defineProperty({__proto__:null,json:ok},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ak=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],ck=Object.freeze(Object.defineProperty({__proto__:null,json:ak},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uk=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],lk=Object.freeze(Object.defineProperty({__proto__:null,json:uk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hk=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],pk=Object.freeze(Object.defineProperty({__proto__:null,json:hk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dk=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],fk=Object.freeze(Object.defineProperty({__proto__:null,json:dk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mk=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gk=Object.freeze(Object.defineProperty({__proto__:null,json:mk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yk=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],xk=Object.freeze(Object.defineProperty({__proto__:null,json:yk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bk=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],vk=Object.freeze(Object.defineProperty({__proto__:null,json:bk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wk=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ck=Object.freeze(Object.defineProperty({__proto__:null,json:wk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sk=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Tk=Object.freeze(Object.defineProperty({__proto__:null,json:Sk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $k=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Ek=Object.freeze(Object.defineProperty({__proto__:null,json:$k},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kk=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Nk=Object.freeze(Object.defineProperty({__proto__:null,json:kk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ik=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],_k=Object.freeze(Object.defineProperty({__proto__:null,json:Ik},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rk=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Ok=Object.freeze(Object.defineProperty({__proto__:null,json:Rk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dl{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[YE,ZE,ek,nk,sk,ik,ck,lk,pk,fk,gk,xk,vk,Ck,Tk,Ek,Nk,_k,Ok],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],o=[],i=[],a=r.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?s.push(g[y.name]):y.op==="Const"?o.push(g[y.name]):(y.input==null||y.input.length===0)&&i.push(g[y.name]),g),{});let c=[];const u=[];let l={},h={};t!=null&&(l=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const p=Object.keys(a);p.forEach(g=>{const y=a[g];y.inputNames.forEach((x,w)=>{const[S,,$]=on(x),N=a[S];if(N.outputs!=null){const _=N.outputs.indexOf($);if(_!==-1){const O=`${S}:${_}`;y.inputNames[w]=O}}y.inputs.push(N),N.children.push(y)})}),Object.keys(h).length===0?p.forEach(g=>{const y=a[g];y.children.length===0&&u.push(y)}):Object.keys(h).forEach(g=>{const[y]=on(g),x=a[y];x!=null&&(x.signatureKey=h[g],u.push(x))}),Object.keys(l).length>0?Object.keys(l).forEach(g=>{const[y]=on(g),x=a[y];x&&(x.signatureKey=l[g],c.push(x))}):c=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const m={nodes:a,inputs:c,outputs:u,weights:o,placeholders:s,signature:t,functions:d};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=ey(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=Ia(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Ia(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=Fa(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Fa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Ra(e.attr,o.tfName,o.defaultValue||0),a===void 0&&!!o.tfDeprecatedName&&(a=Ra(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=Pa(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Pa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=_a(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=_a(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Ma(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Ma(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Da(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Da(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=La(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=La(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Oa(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Oa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Aa(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Aa(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=fl(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=fl(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let o={};t!=null&&(o=t.reduce((h,p)=>(h[p.name]=this.mapNode(p),p.op==="Const"&&s.push(h[p.name]),h),{}));const i=[],a=[];e.signature.inputArg.forEach(h=>{const[p]=on(h.name),d={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:jc(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,i.push(d),o[p]=d}),Object.keys(o).forEach(h=>{const p=o[h];p.inputNames.forEach((d,m)=>{const[g,,y]=on(d),x=o[g];if(x.outputs!=null){const w=x.outputs.indexOf(y);if(w!==-1){const S=`${g}:${w}`;p.inputNames[m]=S}}p.inputs.push(x),x.children.push(p)})});const u=e.ret;e.signature.outputArg.forEach(h=>{const[p,d]=on(u[h.name]),m=o[p];m!=null&&(m.defaultOutput=d,a.push(m))});const l=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:r,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function Ak(n){const e=M().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ty(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):Ak(n);return e?t:t.toLowerCase()}function Ia(n,e,t,r=!1){const s=n[e];return s!=null?ty(s.s,r):t}function _a(n,e,t){const r=n[e];return r?r.b:t}function Ra(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function jc(n){switch(typeof n=="string"&&(n=Dt[n]),n){case Dt.DT_FLOAT:case Dt.DT_HALF:return"float32";case Dt.DT_INT32:case Dt.DT_INT64:case Dt.DT_INT8:case Dt.DT_UINT8:return"int32";case Dt.DT_BOOL:return"bool";case Dt.DT_DOUBLE:return"float32";case Dt.DT_STRING:return"string";default:return null}}function fl(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function Oa(n,e,t){const r=n[e];return r&&r.type?jc(r.type):t}function Aa(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>jc(s)):t}function ny(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Da(n,e,t){const r=n[e];return r&&r.shape?ny(r.shape):t}function Pa(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function Fa(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(o=>ty(o,r)):t}function La(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>ny(s)):t}function Ma(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dk{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return ot(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return ot(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Ra(this.node.rawAttrs,e,t);if(r.s!=null)return Ia(this.node.rawAttrs,e,t);if(r.b!=null)return _a(this.node.rawAttrs,e,t);if(r.shape!=null)return Da(this.node.rawAttrs,e,t);if(r.type!=null)return Oa(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return Pa(this.node.rawAttrs,e,t);if(r.list.s!=null)return Fa(this.node.rawAttrs,e,t);if(r.list.shape!=null)return La(this.node.rawAttrs,e,t);if(r.list.b!=null)return Ma(this.node.rawAttrs,e,t);if(r.list.type!=null)return Aa(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je=Object.freeze(Object.defineProperty({__proto__:null,abs:Pt,acos:yv,acosh:bv,add:ye,addN:wv,all:Sv,any:$v,argMax:Sm,argMin:Nv,asin:_v,asinh:Ov,atan:Dv,atan2:Fv,atanh:Mv,avgPool:$m,avgPool3d:Hv,basicLSTMCell:Zv,batchToSpaceND:Em,batchNorm:Jo,batchNorm2d:rw,batchNorm3d:ow,batchNorm4d:aw,bincount:km,broadcastArgs:lw,broadcastTo:Cs,buffer:Le,cast:Ae,ceil:dw,clipByValue:Nm,clone:Ln,complex:Bn,concat:Ge,concat1d:gw,concat2d:xw,concat3d:vw,concat4d:Cw,conv1d:$w,conv2d:ti,conv2dTranspose:Nw,conv3d:_w,conv3dTranspose:Dw,cos:Fw,cosh:Mw,cumprod:Vw,cumsum:zw,denseBincount:Gw,depthToSpace:Hw,depthwiseConv2d:kc,diag:Xw,dilation2d:Qw,div:ve,divNoNan:nC,dot:sC,einsum:iC,elu:Rm,equal:_m,erf:uC,euclideanNorm:xC,exp:Sn,expandDims:Lt,expm1:CC,eye:Dm,fill:ei,floor:Pm,floorDiv:Cm,gather:Fm,greater:ri,greaterEqual:Lm,imag:Zo,isFinite:_C,isInf:OC,isNaN:DC,leakyRelu:Mm,less:LC,lessEqual:Oc,linspace:BC,localResponseNormalization:UC,log:Ns,log1p:Bm,logSigmoid:HC,logSoftmax:XC,logSumExp:Um,logicalAnd:Fo,logicalNot:zm,logicalOr:Wm,logicalXor:tS,lowerBound:rS,matMul:Se,max:Ar,maxPool:Gm,maxPool3d:iS,maxPoolWithArgmax:cS,maximum:lS,mean:Lo,meshgrid:pS,min:$a,minimum:Dc,mirrorPad:jm,mod:gS,moments:xS,mul:ee,multiRNNCell:vS,multinomial:CS,neg:bn,notEqual:Hm,oneHot:Yb,ones:tr,onesLike:$S,outerProduct:kS,pad:Un,pad1d:_S,pad2d:OS,pad3d:DS,pad4d:FS,pool:US,pow:Rc,prelu:qm,print:Qf,prod:GS,raggedGather:HS,raggedTensorToTensor:qS,rand:YS,randomGamma:uT,randomNormal:ng,randomStandardNormal:pT,randomUniform:rg,range:Is,real:Es,reciprocal:mT,relu:si,relu6:sg,reshape:V,reverse:lr,reverse1d:vT,reverse2d:CT,reverse3d:TT,reverse4d:ET,round:og,rsqrt:IT,scalar:he,selu:RT,separableConv2d:AT,setdiff1dAsync:PT,sigmoid:vn,sign:LT,sin:BT,sinh:UT,slice:oe,slice1d:WT,slice2d:jT,slice3d:KT,slice4d:XT,softmax:QT,softplus:Vm,spaceToBatchND:Km,fft:Lc,ifft:Mo,irfft:ig,rfft:Mc,split:_s,sqrt:Ea,square:Us,squaredDifference:ag,squeeze:Ce,stack:$n,step:cg,stridedSlice:c2,sub:ce,sum:Ie,tan:l2,tanh:Ta,tensor:ln,tensor1d:Ze,tensor2d:zt,tensor3d:im,tensor4d:h2,tensor5d:p2,tensor6d:d2,tile:Ss,topk:m2,truncatedNormal:y2,unique:b2,unsortedSegmentSum:w2,unstack:gr,upperBound:S2,variable:T2,where:Ur,whereAsync:lg,zeros:Vn,zerosLike:Nc,op:I,OP_SCOPE_SUFFIX:Bf,booleanMaskAsync:k2,transpose:wa,norm:ni,movingAverage:I2,scatterND:R2,searchSorted:Ac,sparseToDense:D2,gatherND:F2,dropout:B2,enclosingPowerOfTwo:hg,cosineWindow:Bc,inTopKAsync:U2,image:wn,linalg:IE,losses:_E,spectral:kE,fused:e$,signal:NE,sparse:RE,string:OE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pk=(n,e,t,r=Je)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(b("a",n,e,t),b("b",n,e,t))];case"AddN":return[r.addN(b("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(b("a",n,e,t),b("b",n,e,t))];case"Mul":return[r.mul(b("a",n,e,t),b("b",n,e,t))];case"RealDiv":case"Div":return[r.div(b("a",n,e,t),b("b",n,e,t))];case"DivNoNan":return[r.divNoNan(b("a",n,e,t),b("b",n,e,t))];case"FloorDiv":return[r.floorDiv(b("a",n,e,t),b("b",n,e,t))];case"Sub":return[r.sub(b("a",n,e,t),b("b",n,e,t))];case"Minimum":return[r.minimum(b("a",n,e,t),b("b",n,e,t))];case"Maximum":return[r.maximum(b("a",n,e,t),b("b",n,e,t))];case"Pow":return[r.pow(b("a",n,e,t),b("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fk=(n,e,t,r=Je)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(b("x",n,e,t))];case"Acos":return[r.acos(b("x",n,e,t))];case"Acosh":return[r.acosh(b("x",n,e,t))];case"Asin":return[r.asin(b("x",n,e,t))];case"Asinh":return[r.asinh(b("x",n,e,t))];case"Atan":return[r.atan(b("x",n,e,t))];case"Atan2":return[r.atan2(b("x",n,e,t),b("y",n,e,t))];case"Atanh":return[r.atanh(b("x",n,e,t))];case"Ceil":return[r.ceil(b("x",n,e,t))];case"Complex":return[r.complex(b("real",n,e,t),b("imag",n,e,t))];case"Cos":return[r.cos(b("x",n,e,t))];case"Cosh":return[r.cosh(b("x",n,e,t))];case"Elu":return[r.elu(b("x",n,e,t))];case"Erf":return[r.erf(b("x",n,e,t))];case"Exp":return[r.exp(b("x",n,e,t))];case"Expm1":return[r.expm1(b("x",n,e,t))];case"Floor":return[r.floor(b("x",n,e,t))];case"Log":return[r.log(b("x",n,e,t))];case"Log1p":return[r.log1p(b("x",n,e,t))];case"Imag":return[r.imag(b("x",n,e,t))];case"Neg":return[r.neg(b("x",n,e,t))];case"Reciprocal":return[r.reciprocal(b("x",n,e,t))];case"Real":return[r.real(b("x",n,e,t))];case"Relu":return[r.relu(b("x",n,e,t))];case"Round":return[r.round(b("x",n,e,t))];case"Selu":return[r.selu(b("x",n,e,t))];case"Sigmoid":return[r.sigmoid(b("x",n,e,t))];case"Sin":return[r.sin(b("x",n,e,t))];case"Sign":return[r.sign(b("x",n,e,t))];case"Sinh":return[r.sinh(b("x",n,e,t))];case"Softplus":return[r.softplus(b("x",n,e,t))];case"Sqrt":return[r.sqrt(b("x",n,e,t))];case"Square":return[r.square(b("x",n,e,t))];case"Tanh":return[r.tanh(b("x",n,e,t))];case"Tan":return[r.tan(b("x",n,e,t))];case"ClipByValue":return[r.clipByValue(b("x",n,e,t),b("clipValueMin",n,e,t),b("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(b("x",n,e,t))];case"Rsqrt":return[r.rsqrt(ot(n.inputNames[0],e,t))];case"Prod":return[r.prod(b("x",n,e,t),b("axes",n,e,t))];case"LeakyRelu":return[r.leakyRelu(b("x",n,e,t),b("alpha",n,e,t))];case"Prelu":return[r.prelu(b("x",n,e,t),b("alpha",n,e,t))];case"IsNan":return[r.isNaN(ot(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ft(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){k(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];k(s<0||o<0||s===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function ml(n){return!(typeof n=="number"||n.some(e=>e<0))}function ds(n,e,t){let r=Ba(n,t);const s=!ml(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=Ba(o.shape,r)}),!ml(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Ba(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lk{constructor(e,t,r,s,o,i,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=he(0),Dn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ft(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Dn(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return ln([],[0].concat(this.elementShape));const r=this.readMany(e);return Ft(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),$n(r,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ln([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return Ft(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Ge(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,gr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:t.size/r,i=[];we(()=>{t=V(t,[1,r,o]);for(let c=0;c<e.length;++c){const u=c===0?0:s[c-1],l=[0,u,0],h=[1,e[c],o];i[c]=V(oe(t,l,h),this.elementShape)}return i});const a=[];for(let c=0;c<e.length;c++)a[c]=c;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pr{constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Ft(t,o.shape,"TensorList shape mismatch: "),Dn(o)}),this.idTensor=he(0),this.maxNumElements=s,Dn(this.idTensor)}get id(){return this.idTensor.id}copy(){return new pr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Ft(e,this.elementShape,"TensorList shape mismatch: ");const s=ds(this.elementShape,this.tensors,e);return we(()=>{const o=this.tensors.map(i=>V(i,s));return $n(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=ds(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,Ft(s.shape,e,"TensorList shape mismatch: "),V(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ft(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Dn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new pr([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ft(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=ds(this.elementShape,this.tensors,t);return V(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ft(this.elementShape,t.shape,"TensorList shape mismatch: "),Dn(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ft(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=ds(this.elementShape,this.tensors,r);return e.length===0?ln([],[0].concat(s)):we(()=>{const o=e.map(i=>V(this.tensors[i],s));return $n(o,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ft(this.elementShape,t,"TensorList shape mismatch: ");const r=ds(this.elementShape,this.tensors,t);return this.size()===0?ln([],[0].concat(r)):we(()=>{const s=this.tensors.map(o=>V(o,r));return Ge(s,0)})}}function Mk(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);Ft(s,e,"TensorList shape mismatch: ");const o=gr(n);return new pr(o,e,r)}function Bk(n,e,t,r){return new pr([],n,e,r)}function Vk(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new pr([],t,n.dtype,r),i=gr(n,0);return e.forEach((a,c)=>{o.setItem(a,i[c])}),o}function Uk(n,e,t){let r=0;const s=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),i=Ba(o,t),a=r===0?0:n.size/r,c=we(()=>{const l=[];n=V(n,[1,r,a]);for(let h=0;h<e.length;++h){const p=h===0?0:s[h-1],d=[0,p,0],m=[1,e[h],a];l[h]=V(oe(n,d,m),i)}return n.dispose(),l}),u=new pr([],t,n.dtype,e.length);for(let l=0;l<c.length;l++)u.setItem(l,c[l]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zk=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=b("thenBranch",n,e,t),s=b("elseBranch",n,e,t),o=b("cond",n,e,t),i=b("args",n,e,t);return(await o.data())[0]?t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=b("body",n,e,t),s=b("cond",n,e,t),o=b("args",n,e,t),i=await t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),a=o.map(l=>l.id);let c=await i[0].data();i.forEach(l=>{!l.kept&&a.indexOf(l.id)===-1&&l.dispose()});let u=o;for(;c[0];){const l=u;u=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(d=>d.id);l.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const p=await t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);c=await p[0].data(),p.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return u}case"LoopCond":{const r=b("pred",n,e,t);return[gn(r)]}case"Switch":{const r=b("pred",n,e,t);let s=b("data",n,e,t);return s.kept||(s=gn(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>ot(s,e,t)!==void 0);if(r){const s=ot(r,e,t);return[gn(s)]}return}case"Enter":{const r=b("frameName",n,e,t),s=b("tensor",n,e,t);return t.enterFrame(r),[gn(s)]}case"Exit":{const r=b("tensor",n,e,t);return t.exitFrame(),[gn(r)]}case"NextIteration":{const r=b("tensor",n,e,t);return t.nextIteration(),[gn(r)]}case"TensorArrayV3":{const r=b("size",n,e,t),s=b("dtype",n,e,t),o=b("elementShape",n,e,t),i=b("dynamicSize",n,e,t),a=b("clearAfterRead",n,e,t),c=b("identicalElementShapes",n,e,t),u=b("name",n,e,t),l=new Lk(u,s,r,o,c,i,a);return t.addTensorArray(l),[l.idTensor,he(1)]}case"TensorArrayWriteV3":{const r=b("tensorArrayId",n,e,t),s=b("index",n,e,t),o=b("tensor",n,e,t),i=t.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=b("tensorArrayId",n,e,t),s=b("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=b("tensorArrayId",n,e,t),s=b("indices",n,e,t),o=b("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=b("tensorArrayId",n,e,t),s=b("indices",n,e,t),o=b("tensor",n,e,t),i=t.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=b("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),o=b("dtype",n,e,t);return[s.concat(o)]}case"TensorArraySplitV3":{const r=b("tensorArrayId",n,e,t),s=b("tensor",n,e,t),o=b("lengths",n,e,t),i=t.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=b("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[he(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=b("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=b("tensorListId",n,e,t),s=b("index",n,e,t),o=b("tensor",n,e,t),i=t.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=b("tensorListId",n,e,t),s=b("index",n,e,t),o=b("elementShape",n,e,t),i=b("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=b("indices",n,e,t),s=b("tensor",n,e,t),o=b("elementShape",n,e,t),i=b("numElements",n,e,t),a=Vk(s,r,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=b("elementShape",n,e,t),s=b("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=b(o,n,e,t),a=n.op==="TensorListReserve"?-1:i,c=Bk(r,s,i,a);return t.addTensorList(c),[c.idTensor]}case"TensorListGather":{const r=b("tensorListId",n,e,t),s=b("indices",n,e,t),o=b("elementShape",n,e,t),i=b("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=b("tensorListId",n,e,t),s=b("elementShape",n,e,t),o=b("elementDType",n,e,t),i=b("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=b("tensor",n,e,t),s=b("elementShape",n,e,t),o=b("elementDType",n,e,t),i=Mk(r,s,o);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=b("tensorListId",n,e,t),s=t.getTensorList(r.id),o=b("dtype",n,e,t),i=b("elementShape",n,e,t);return[s.concat(o,i)]}case"TensorListPushBack":{const r=b("tensorListId",n,e,t),s=b("tensor",n,e,t),o=t.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=b("tensorListId",n,e,t),s=b("elementShape",n,e,t),o=b("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=b("tensor",n,e,t),s=b("elementShape",n,e,t),o=b("lengths",n,e,t),i=Uk(r,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=b("tensorListId",n,e,t),s=t.getTensorList(r.id);return[he(s.size(),"int32")]}case"TensorListResize":{const r=b("tensorListId",n,e,t),s=b("size",n,e,t),i=t.getTensorList(r.id).resize(s);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gl(n,e,t){const[r,s]=b("fusedOps",n,e,t),o=r==="biasadd",i=!o,a=s==="prelu",c=r==="fusedbatchnorm",u=b("numArgs",n,e,t);if(o){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const l=b("strides",n,e,t),h=go(n,e,t),p=b("dataFormat",n,e,t).toUpperCase(),d=b("dilations",n,e,t);let[m,g]=b("args",n,e,t);i&&(g=m,m=void 0);const y=b("leakyreluAlpha",n,e,t);return{stride:l,pad:h,dataFormat:p,dilations:d,biasArg:m,preluArg:g,activationFunc:s,leakyreluAlpha:y}}const Wk=(n,e,t,r=Je)=>{switch(n.op){case"Conv1D":{const s=b("stride",n,e,t),o=b("pad",n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilation",n,e,t);return[r.conv1d(b("x",n,e,t),b("filter",n,e,t),s,o,i,a)]}case"Conv2D":{const s=b("strides",n,e,t),o=go(n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilations",n,e,t);return[r.conv2d(b("x",n,e,t),b("filter",n,e,t),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:c,preluArg:u,activationFunc:l,leakyreluAlpha:h}=gl(n,e,t);return[r.fused.conv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:l,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:c,preluArg:u,activationFunc:l,leakyreluAlpha:h}=gl(n,e,t);return[r.fused.depthwiseConv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:l,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=b("outputShape",n,e,t),o=b("strides",n,e,t),i=go(n,e,t);return[r.conv2dTranspose(b("x",n,e,t),b("filter",n,e,t),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=b("strides",n,e,t),o=go(n,e,t),i=b("dilations",n,e,t),a=b("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(b("input",n,e,t),b("filter",n,e,t),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=b("strides",n,e,t),o=b("pad",n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilations",n,e,t);return[r.conv3d(b("x",n,e,t),b("filter",n,e,t),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=b("strides",n,e,t),o=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.avgPool(b("x",n,e,t),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=b("strides",n,e,t),o=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.maxPool(b("x",n,e,t),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=b("strides",n,e,t),o=b("pad",n,e,t),i=b("kernelSize",n,e,t),a=b("includeBatchInIndex",n,e,t),{result:c,indexes:u}=r.maxPoolWithArgmax(b("x",n,e,t),[i[1],i[2]],[s[1],s[2]],o,a);return[c,u]}case"AvgPool3D":{const s=b("strides",n,e,t),o=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.avgPool3d(b("x",n,e,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=b("strides",n,e,t),o=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.maxPool3d(b("x",n,e,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=b("strides",n,e,t),o=b("pad",n,e,t),i=b("dilations",n,e,t),a=s[1],c=s[2],u=i[1],l=i[2];return[r.dilation2d(b("x",n,e,t),b("filter",n,e,t),[a,c],o,[u,l],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gk=(n,e,t,r=Je)=>{switch(n.op){case"Fill":{const s=b("shape",n,e,t),o=b("dtype",n,e,t),i=b("value",n,e,t);return[r.fill(s,i,o)]}case"LinSpace":{const s=b("start",n,e,t),o=b("stop",n,e,t),i=b("num",n,e,t);return[r.linspace(s,o,i)]}case"Multinomial":{const s=b("logits",n,e,t),o=b("numSamples",n,e,t),i=b("seed",n,e,t);return[r.multinomial(s,o,i)]}case"OneHot":{const s=b("indices",n,e,t),o=b("depth",n,e,t),i=b("onValue",n,e,t),a=b("offValue",n,e,t),c=b("dtype",n,e,t);return[r.oneHot(s,o,i,a,c)]}case"Ones":return[r.ones(b("shape",n,e,t),b("dtype",n,e,t))];case"OnesLike":return[r.onesLike(b("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(b("shape",n,e,t),b("dtype",n,e,t),b("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(b("shape",n,e,t),b("minval",n,e,t),b("maxval",n,e,t),b("dtype",n,e,t))];case"Range":{const s=b("start",n,e,t),o=b("stop",n,e,t),i=b("step",n,e,t);return[r.range(s,o,i,b("dtype",n,e,t))]}case"TruncatedNormal":{const s=b("shape",n,e,t),o=b("mean",n,e,t),i=b("stdDev",n,e,t),a=b("seed",n,e,t);return[r.truncatedNormal(s,o,i,b("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(b("shape",n,e,t),b("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(n,e,t){const r=b("boxes",n,e,t),s=b("scores",n,e,t),o=b("maxOutputSize",n,e,t),i=b("iouThreshold",n,e,t),a=b("scoreThreshold",n,e,t),c=b("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:c}}const jk=async(n,e,t,r,s=Je)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:u,softNmsSigma:l}=Di(n,e,t),h=await s.image.nonMaxSuppressionWithScoreAsync(o,i,a,c,u,l);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:u}=Di(n,e,t),l=b("padToMaxOutputSize",n,e,t),h=await s.image.nonMaxSuppressionPaddedAsync(o,i,a,c,u,l);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:u}=Di(n,e,t);return[await s.image.nonMaxSuppressionAsync(o,i,a,c,u)]}case"Where":{const o=s.cast(b("condition",n,e,t),"bool"),i=[await s.whereAsync(o)];return o.dispose(),i}case"ListDiff":return s.setdiff1dAsync(b("x",n,e,t),b("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hk=(n,e,t,r=Je)=>{switch(n.op){case"LowerBound":{const s=b("sortedSequence",n,e,t),o=b("values",n,e,t);return[r.lowerBound(s,o)]}case"TopKV2":{const s=b("x",n,e,t),o=b("k",n,e,t),i=b("sorted",n,e,t),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=b("sortedSequence",n,e,t),o=b("values",n,e,t);return[r.upperBound(s,o)]}case"Unique":{const s=b("x",n,e,t),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=b("x",n,e,t),o=b("axis",n,e,t),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kk=(n,e,t,r=Je)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=b("default",n,e,t);return[ot(n.name,e,t)||s];case"Placeholder":return[ot(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=b("x",n,e,t);return[gn(l)]}case"IdentityN":return b("x",n,e,t).map(l=>gn(l));case"Snapshot":const o=b("x",n,e,t);return[gn(o)];case"Shape":return[r.tensor1d(b("x",n,e,t).shape,"int32")];case"ShapeN":return b("x",n,e,t).map(l=>r.tensor1d(l.shape));case"Size":return[r.scalar(b("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(b("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=b("x",n,e,t),a=b("data",n,e,t),c=b("message",n,e,t),u=b("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let l=0;l<a.length;l++)console.log(Array.prototype.slice.call(a[l].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qk{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=he(0),this.tensorMap=new Map,Dn(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return he(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),we(()=>{const s=gr(t),o=r.length,i=s.length;k(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const c=r[a],u=s[a];Dn(u),this.tensorMap.set(c,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return we(()=>{const s=[];for(let o=0;o<r.length;o++){const i=r[o],a=this.findWithDefault(i,t);s.push(a)}return $n(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r!=null?r:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xk=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=b("keyDType",n,e,t),o=b("valueDType",n,e,t),i=new qk(s,o);return r.addHashTable(n.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=b("tableHandle",n,e,t,r),o=b("keys",n,e,t),i=b("values",n,e,t);return[await r.getHashTableById(s.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=b("tableHandle",n,e,t,r),o=b("keys",n,e,t),i=b("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=b("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yk=(n,e,t,r=Je)=>{switch(n.op){case"ResizeBilinear":{const s=b("images",n,e,t),o=b("size",n,e,t),i=b("alignCorners",n,e,t),a=b("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=b("images",n,e,t),o=b("size",n,e,t),i=b("alignCorners",n,e,t),a=b("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=b("image",n,e,t),o=b("boxes",n,e,t),i=b("boxInd",n,e,t),a=b("cropSize",n,e,t),c=b("method",n,e,t),u=b("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,o,i,a,c,u)]}case"ImageProjectiveTransformV3":{const s=b("images",n,e,t),o=b("transforms",n,e,t),i=b("outputShape",n,e,t),a=b("fillValue",n,e,t),c=b("interpolation",n,e,t),u=b("fillMode",n,e,t);return[r.image.transform(s,o,c.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk=(n,e,t,r=Je)=>{switch(n.op){case"Equal":return[r.equal(b("a",n,e,t),b("b",n,e,t))];case"NotEqual":return[r.notEqual(b("a",n,e,t),b("b",n,e,t))];case"Greater":return[r.greater(b("a",n,e,t),b("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(b("a",n,e,t),b("b",n,e,t))];case"Less":return[r.less(b("a",n,e,t),b("b",n,e,t))];case"LessEqual":return[r.lessEqual(b("a",n,e,t),b("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(b("a",n,e,t),b("b",n,e,t))];case"LogicalNot":return[r.logicalNot(b("a",n,e,t))];case"LogicalOr":return[r.logicalOr(b("a",n,e,t),b("b",n,e,t))];case"Select":case"SelectV2":return[r.where(b("condition",n,e,t),b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zk=(n,e,t,r=Je)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(b("a",n,e,t),b("b",n,e,t),b("transposeA",n,e,t),b("transposeB",n,e,t))];case"Einsum":return[r.einsum(b("equation",n,e,t),...b("tensors",n,e,t))];case"Transpose":return[r.transpose(b("x",n,e,t),b("perm",n,e,t))];case"_FusedMatMul":const[s,o]=b("fusedOps",n,e,t),i=s==="biasadd",a=o==="prelu",c=b("numArgs",n,e,t),u=b("leakyreluAlpha",n,e,t);if(i){if(a&&c!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&c!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,h]=b("args",n,e,t);return[r.fused.matMul({a:b("a",n,e,t),b:b("b",n,e,t),transposeA:b("transposeA",n,e,t),transposeB:b("transposeB",n,e,t),bias:l,activation:o,preluActivationWeights:h,leakyreluAlpha:u})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jk=(n,e,t,r=Je)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(b("x",n,e,t),b("axis",n,e,t),b("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(b("x",n,e,t),b("radius",n,e,t),b("bias",n,e,t),b("alpha",n,e,t),b("beta",n,e,t))];case"Softmax":return[r.softmax(b("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(b("x",n,e,t))];case"SparseToDense":return[r.sparseToDense(b("sparseIndices",n,e,t),b("outputShape",n,e,t),b("sparseValues",n,e,t),b("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eN=(n,e,t,r=Je)=>{switch(n.op){case"Max":{const a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.max(b("x",n,e,t),a,c)]}case"Mean":{const a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.mean(b("x",n,e,t),a,c)]}case"Min":{const a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.min(b("x",n,e,t),a,c)]}case"Sum":{const a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.sum(b("x",n,e,t),a,c)]}case"All":{const a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.all(b("x",n,e,t),a,c)]}case"Any":{const a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.any(b("x",n,e,t),a,c)]}case"ArgMax":{const a=b("axis",n,e,t);return[r.argMax(b("x",n,e,t),a)]}case"ArgMin":{const a=b("axis",n,e,t);return[r.argMin(b("x",n,e,t),a)]}case"Prod":{const a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.prod(b("x",n,e,t),a,c)]}case"Cumprod":{const a=b("axis",n,e,t),c=b("exclusive",n,e,t),u=b("reverse",n,e,t);return[r.cumprod(b("x",n,e,t),a,c,u)]}case"Cumsum":{const a=b("axis",n,e,t),c=b("exclusive",n,e,t),u=b("reverse",n,e,t);return[r.cumsum(b("x",n,e,t),a,c,u)]}case"Bincount":const s=b("x",n,e,t),o=b("weights",n,e,t),i=b("size",n,e,t);return[r.bincount(s,o,i)];case"DenseBincount":{const a=b("x",n,e,t),c=b("weights",n,e,t),u=b("size",n,e,t),l=b("binaryOutput",n,e,t);return[r.denseBincount(a,c,u,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN=(n,e,t,r=Je)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=b("n",n,e,t),o=b("axis",n,e,t);let i=b("tensors",n,e,t);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=b("x",n,e,t),o=b("indices",n,e,t);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=b("axis",n,e,t),o=b("batchDims",n,e,t),i=b("x",n,e,t),a=b("indices",n,e,t);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=b("dims",n,e,t),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=b("x",n,e,t);return[r.reverse(i,o)]}case"ReverseV2":{const s=b("axis",n,e,t),o=b("x",n,e,t);return[r.reverse(o,s)]}case"Slice":{const s=b("begin",n,e,t),o=b("size",n,e,t);return[r.slice(b("x",n,e,t),s,o)]}case"StridedSlice":{const s=b("begin",n,e,t),o=b("end",n,e,t),i=b("strides",n,e,t),a=b("beginMask",n,e,t),c=b("endMask",n,e,t),u=b("ellipsisMask",n,e,t),l=b("newAxisMask",n,e,t),h=b("shrinkAxisMask",n,e,t),p=b("x",n,e,t);return[r.stridedSlice(p,s,o,i,a,c,u,l,h)]}case"Pack":return we(()=>{const s=b("axis",n,e,t),o=b("tensors",n,e,t),i=o[0].shape,a=r.squeeze(o[0]).shape,c=o.map(u=>{const l=Me(u.shape,i);if(!l&&!Me(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return l?u:r.reshape(u,i)});return[r.stack(c,s)]});case"Unpack":{const s=b("axis",n,e,t),o=b("tensor",n,e,t);return r.unstack(o,s)}case"Tile":{const s=b("reps",n,e,t);return[r.tile(b("x",n,e,t),s)]}case"Split":case"SplitV":{const s=b("axis",n,e,t),o=b("numOrSizeSplits",n,e,t),i=b("x",n,e,t);return r.split(i,o,s)}case"ScatterNd":{const s=b("indices",n,e,t),o=b("values",n,e,t),i=b("shape",n,e,t);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=b("x",n,e,t),o=b("indices",n,e,t);return[r.gatherND(s,o)]}case"SparseToDense":{const s=b("sparseIndices",n,e,t),o=b("outputShape",n,e,t),i=b("sparseValues",n,e,t),a=b("defaultValue",n,e,t);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nN=(n,e,t,r=Je)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(b("indices",n,e,t),b("values",n,e,t),b("denseShape",n,e,t),b("defaultValue",n,e,t));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(b("inputIndices",n,e,t),b("inputShape",n,e,t),b("newShape",n,e,t));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rN=(n,e,t,r=Je)=>{switch(n.op){case"FFT":return[r.fft(b("x",n,e,t))];case"IFFT":return[r.ifft(b("x",n,e,t))];case"RFFT":return[r.rfft(b("x",n,e,t))];case"IRFFT":return[r.irfft(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sN=(n,e,t,r=Je)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(b("data",n,e,t),b("dataSplits",n,e,t),b("separator",n,e,t),b("nGramWidths",n,e,t),b("leftPad",n,e,t),b("rightPad",n,e,t),b("padWidth",n,e,t),b("preserveShortSequences",n,e,t));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(b("input",n,e,t),b("delimiter",n,e,t),b("skipEmpty",n,e,t));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(b("input",n,e,t),b("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN=(n,e,t,r=Je)=>{switch(n.op){case"Cast":return[r.cast(b("x",n,e,t),b("dtype",n,e,t))];case"ExpandDims":{const s=b("axis",n,e,t);return[r.expandDims(b("x",n,e,t),s)]}case"Squeeze":{const s=b("axis",n,e,t);return[r.squeeze(b("x",n,e,t),s)]}case"Reshape":return[r.reshape(b("x",n,e,t),b("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(b("x",n,e,t),b("padding",n,e,t),b("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(b("x",n,e,t),b("padding",n,e,t),b("constantValue",n,e,t))];case"SpaceToBatchND":{const s=b("blockShape",n,e,t),o=b("paddings",n,e,t);return[r.spaceToBatchND(b("x",n,e,t),s,o)]}case"BatchToSpaceND":{const s=b("blockShape",n,e,t),o=b("crops",n,e,t);return[r.batchToSpaceND(b("x",n,e,t),s,o)]}case"DepthToSpace":{const s=b("blockSize",n,e,t),o=b("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(b("x",n,e,t),s,o)]}case"BroadcastTo":return[r.broadcastTo(b("x",n,e,t),b("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(b("s0",n,e,t),b("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yl(n,e,t,r,s=we){const o=((i,a,c)=>{switch(i.category){case"arithmetic":return s(()=>Pk(i,a,c));case"basic_math":return s(()=>Fk(i,a,c));case"control":return zk(i,a,c);case"convolution":return s(()=>Wk(i,a,c));case"creation":return s(()=>Gk(i,a,c));case"dynamic":return jk(i,a,c);case"evaluation":return s(()=>Hk(i,a,c));case"image":return s(()=>Yk(i,a,c));case"graph":return s(()=>Kk(i,a,c));case"logical":return s(()=>Qk(i,a,c));case"matrices":return s(()=>Zk(i,a,c));case"normalization":return s(()=>Jk(i,a,c));case"reduction":return s(()=>eN(i,a,c));case"slice_join":return s(()=>tN(i,a,c));case"sparse":return s(()=>nN(i,a,c));case"spectral":return s(()=>rN(i,a,c));case"string":return s(()=>sN(i,a,c));case"transformation":return s(()=>oN(i,a,c));case"hash_table":return Xk(i,a,c,r);case"custom":const u=ey(i.op);if(u&&u.customExecutor)return u.customExecutor(new Dk(i,a,c));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Lr(o)?o.then(i=>[].concat(i)):[].concat(o)}class xl{constructor(e={},t={},r={},s={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(n,e,t,r){const s=new Set,o=[];let i=null,a=null;const c=new Set,u=Object.keys(n).map(p=>ft(p)[0]);let l=[];r!=null&&(l=r.map(p=>ft(p.name)[0]));const h=[...e];for(;h.length>0;){const p=h.pop();if((ry(p)||lN(p)||hN(p))&&i==null&&(i=p,a=i.children.map(d=>d.name).filter(d=>s.has(d))),s.add(p.name),t[p.name]==null&&u.indexOf(p.name)===-1&&l.indexOf(p.name)===-1){if(p.inputs.length===0){o.push(p.name);continue}p.inputs.forEach(d=>{c.has(d.name)||(c.add(d.name),h.push(d))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}function iN(n,e,t){const{usedNodes:r,inputs:s}=t,o=[],i=Object.keys(s).map(l=>ft(l)[0]).map(l=>n.nodes[l]),a=n.initNodes;i.forEach(l=>{r.has(l.name)&&o.push(l)}),n.weights.forEach(l=>{r.has(l.name)&&o.push(l)}),a!=null&&a.forEach(l=>{r.has(l.name)&&o.push(l)});const c=new Set,u=[];for(;o.length>0;){const l=o.pop();c.add(l.name),e[l.name]||u.push(l),l.children.forEach(h=>{!c.has(h.name)&&r.has(h.name)&&h.inputs.every(p=>c.has(p.name))&&o.push(h)})}return u}const aN=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],cN=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],uN=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function ry(n){return aN.indexOf(n.op)>=0}function lN(n){return cN.indexOf(n.op)>=0}function hN(n){return uN.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vo{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Vo(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const r=e.map(o=>o.name).sort(),s=t.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,t){const r=bl(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const a=t.map(u=>u.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}return iN(this.graph,this.weightMap,r)}execute(e,t){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(h=>this.graph.nodes[ft(h)[0]]),o=t.map(h=>ft(h)[0]);let i=o.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),i.length===0&&(i=this._outputs);const a=this.getCompilationKey(s,i);let c=this.compiledMap.get(a);c==null&&(c=this.compile(e,i),this.compiledMap.set(a,c));const u={},l={};return we(()=>{const h=new xl(this.weightMap,u,l,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(g=>{const[y,x]=ft(g),w=[];w[x]=e[g],p[y]=w});const d=this.getFrozenTensorIds(p),m={};for(let g=0;g<c.length;g++){const y=c[g];if(!p[y.name]){const x=yl(y,p,h,this._resourceManager);if(Lr(x))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=x,this.checkTensorForDisposal(y.name,y,p,h,d,o,m)}}return this.parent==null&&h.dispose(d),t.map(g=>ot(g,p,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,o,i,a){t.category==="control"||i.indexOf(e)!==-1||(r[e].forEach(c=>{c!=null&&(a[c.id]=(a[c.id]||0)+t.children.length)}),t.inputs.forEach(c=>{if(c.category!=="control"){const u=qE(c.name,r,s);u!=null&&u.forEach(l=>{if(l&&!l.kept&&!o.has(l.id)){const h=a[l.id];if(h===1){if(!this.keepTensorForDebug)l.dispose();else{const[p,d]=on(t.name,s);this.intermediateTensors[p]?this.intermediateTensors[p][d]=l:(this.intermediateTensors[p]=[],this.intermediateTensors[p][d]=l)}delete a[l.id]}else h!=null&&a[l.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,r=!1,s={},o={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=M().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(l){console.warn(l.message)}this.resetIntermediateTensors();const i=new xl(this.weightMap,s,o,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,i,t,r);const a=t.map(l=>ot(l,this.tensorsMap,i)),c=a.map(l=>l.id),u=Object.keys(e).map(l=>e[l].id);return this.keepIds=new Set([...c,...u,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&i.dispose(this.keepIds),a}async executeFunctionAsync(e,t,r){const s=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const o=Object.keys(e),i=o.map(S=>this.graph.nodes[ft(S)[0]]),a=r.map(S=>ft(S)[0]);let c=a.map(S=>this.graph.nodes[S]);c.length===0&&(c=this._outputs);const{usedNodes:u,missingInputs:l,dynamicNode:h,syncInputs:p}=bl(e,c,this.weightMap,this._initNodes),d=[...i,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[$,N]=ft(S),_=[];_[N]=e[S],m[$]=_});const g={},y=this.getFrozenTensorIds(m),x={};for(;d.length>0;){const S=this.processStack(i,d,t,m,x,y,a,g,u);await Promise.all(S)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=c.filter(S=>!ry(S)&&!ot(S.name,m,t)).map(S=>S.name);if(w.length>0){let S="";throw h!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${o}]. Consider providing the following inputs: [${l}]. ${S}`)}return m}processStack(e,t,r,s,o,i,a,c,u){const l=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let p="";if(h.node.op==="Enter"&&b("isConstant",h.node,s,r)&&([p]=on(h.node.name,r)),s[h.node.name]==null){const d=yl(h.node,s,r,this._resourceManager);p||([p]=on(h.node.name,r));const m=r.currentContext;Lr(d)?l.push(d.then(g=>(s[p]=g,r.currentContext=m,this.checkTensorForDisposal(p,h.node,s,r,i,a,c),this.processChildNodes(h.node,t,r,s,o,u),g))):(s[p]=d,this.checkTensorForDisposal(p,h.node,s,r,i,a,c),this.processChildNodes(h.node,t,r,s,o,u))}else this.processChildNodes(h.node,t,r,s,o,u)}return l}processChildNodes(e,t,r,s,o,i){e.children.forEach(a=>{const[c]=on(a.name,r);o[c]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!ot(u,s,r))&&(o[c]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!ot(u,s,r))&&(o[c]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=ft(t),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((c,u)=>i[u]===-1||i[u]===c);k(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&k(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const t={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const s=this._signature.inputs[r];t[s.name]=e[r]}else t[r]=e[r];return t}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=ft(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[r]=ft(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class pN{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dN="?tfjs-format=file",fN="model.json";class mN{constructor(e,t={},r=rm){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new pN}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Lr(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(r=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Vo(dl.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=dl.Instance.transformGraph(e.modelInitializer);this.initializer=new Vo(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){const r=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const s=r instanceof Fe?[r]:r,o={};return s.forEach((i,a)=>o[this.structuredOutputKeys[a]]=i),o}return r}normalizeInputs(e){if(!(e instanceof Fe)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,r,s)=>(t[r]=e[s],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function zr(n,e={},t=rm){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=gN(n));const r=new mN(n,e,t);return await r.load(),r}function gN(n){return n.endsWith("/")||(n=n+"/"),`${n}${fN}${dN}`}/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var sy=function(n,e){return(sy=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])})(n,e)};function oy(n,e){function t(){this.constructor=n}sy(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Te=function(){return(Te=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n}).apply(this,arguments)};function de(n,e,t,r){return new(t||(t=Promise))(function(s,o){function i(u){try{c(r.next(u))}catch(l){o(l)}}function a(u){try{c(r.throw(u))}catch(l){o(l)}}function c(u){var l;u.done?s(u.value):(l=u.value,l instanceof t?l:new t(function(h){h(l)})).then(i,a)}c((r=r.apply(n,e||[])).next())})}function fe(n,e){var t,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return function(l){if(t)throw new TypeError("Generator is already executing.");for(;i;)try{if(t=1,r&&(s=2&l[0]?r.return:l[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,l[1])).done)return s;switch(r=0,s&&(l=[2&l[0],s.value]),l[0]){case 0:case 1:s=l;break;case 4:return i.label++,{value:l[1],done:!1};case 5:i.label++,r=l[1],l=[0];continue;case 7:l=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||l[0]!==6&&l[0]!==2)){i=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){i.label=l[1];break}if(l[0]===6&&i.label<s[1]){i.label=s[1],s=l;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(l);break}s[2]&&i.ops.pop(),i.trys.pop();continue}l=e.call(n,i)}catch(h){l=[6,h],r=0}finally{t=s=0}if(5&l[0])throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}([c,u])}}}function nr(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var r=Array(n),s=0;for(e=0;e<t;e++)for(var o=arguments[e],i=0,a=o.length;i<a;i++,s++)r[s]=o[i];return r}var dn=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Os=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],yN={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},xN={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},bN=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],vN=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function Uo(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function iy(n){return de(this,void 0,void 0,function(){var e,t;return fe(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof Fe?[4,wc(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Uo(n.width),e.height=Uo(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function ay(n){return de(this,void 0,void 0,function(){var e,t,r,s,o,i;return fe(this,function(a){switch(a.label){case 0:return n instanceof Fe?(e=n.shape.slice(0,2),t=e[0],r=e[1],s=ImageData.bind,[4,wc(n)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,t]))];case 2:return o=document.createElement("canvas"),i=o.getContext("2d"),o.width=Uo(n.width),o.height=Uo(n.height),i.drawImage(n,0,0),[2,i.getImageData(0,0,o.width,o.height)]}})})}function wN(n){return de(this,void 0,void 0,function(){var e,t;return fe(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,iy(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,Cc(e,4)]}})})}function cy(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got "+n);if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got "+n)}var fs={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},CN=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return de(this,void 0,void 0,function(){return fe(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return de(this,void 0,void 0,function(){return fe(this,function(e){return[2,ay(this.mask)]})})},n.prototype.toTensor=function(){return de(this,void 0,void 0,function(){return fe(this,function(e){return[2,wN(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function SN(n){return cy(n),"person"}var TN=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new Q0.Pose({locateFile:function(s,o){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:o+"/"+s}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var o=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(o.segmentation={maskValueToLabel:SN,mask:new CN(s.segmentationMask)}),r.poses=[o]}})}return n.prototype.translateOutput=function(e,t){var r=this,s={keypoints:e.map(function(o,i){return{x:o.x*r.width,y:o.y*r.height,z:o.z,score:o.visibility,name:Os[i]}})};return t!=null&&(s.keypoints3D=t.map(function(o,i){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:Os[i]}})),s},n.prototype.estimatePoses=function(e,t,r){return de(this,void 0,void 0,function(){var s,o;return fe(this,function(i){switch(i.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Fe?(o=ImageData.bind,[4,wc(e)]):[3,2];case 1:return s=new(o.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,i.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return i.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function $N(n){return de(this,void 0,void 0,function(){var e,t;return fe(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Te({},fs);var o=Te({},s);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=fs.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=fs.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=fs.smoothSegmentation),o.modelType==null&&(o.modelType=fs.modelType),o}(n),[4,(t=new TN(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function As(n){return n instanceof Fe?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function uy(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function Hc(n){return n instanceof Fe?n:Cc(n)}function ly(n,e,t){return Va(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function Va(n,e){k(n.width!==0,function(){return e+" width cannot be 0."}),k(n.height!==0,function(){return e+" height cannot be 0."})}function Pi(n,e,t){var r=t.rotationVectorStartKeypointIndex,s=t.rotationVectorEndKeypointIndex,o=n.locationData,i=o.relativeKeypoints[r].x*e.width,a=o.relativeKeypoints[r].y*e.height,c=o.relativeKeypoints[s].x*e.width,u=o.relativeKeypoints[s].y*e.height,l=2*Math.sqrt((c-i)*(c-i)+(u-a)*(u-a)),h=function(p,d,m){var g,y=p.locationData,x=m.rotationVectorStartKeypointIndex,w=m.rotationVectorEndKeypointIndex;g=m.rotationVectorTargetAngle?m.rotationVectorTargetAngle:Math.PI*m.rotationVectorTargetAngleDegree/180;var S=y.relativeKeypoints[x].x*d.width,$=y.relativeKeypoints[x].y*d.height,N=y.relativeKeypoints[w].x*d.width,_=y.relativeKeypoints[w].y*d.height;return uy(g-Math.atan2(-(_-$),N-S))}(n,e,t);return{xCenter:i/e.width,yCenter:a/e.height,width:l/e.width,height:l/e.height,rotation:h}}function hy(n){if(n.length!==16)throw new Error("Array length must be 16 but got "+n.length);return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function Fi(n,e,t,r,s,o,i){return n[e][s]*(n[t][o]*n[r][i]-n[t][i]*n[r][o])}function et(n,e,t){var r=(e+1)%4,s=(e+2)%4,o=(e+3)%4,i=(t+1)%4,a=(t+2)%4,c=(t+3)%4;return Fi(n,r,s,o,i,a,c)+Fi(n,s,o,r,i,a,c)+Fi(n,o,r,s,i,a,c)}function vl(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],s=0,o=n;s<o.length;s++){var i=o[s],a=i.x-.5,c=i.y-.5,u=t.ignoreRotation?0:e.rotation,l=Math.cos(u)*a-Math.sin(u)*c,h=Math.sin(u)*a+Math.cos(u)*c;l=l*e.width+e.xCenter,h=h*e.height+e.yCenter;var p=i.z*e.width,d=Te({},i);d.x=l,d.y=h,d.z=p,r.push(d)}return r}function py(n,e){var t=function(r,s,o,i){var a=s-r,c=i-o;if(a===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var u=c/a;return{scale:u,offset:o-r*u}}(0,255,e[0],e[1]);return we(function(){return ye(ee(n,t.scale),t.offset)})}function Ua(n,e,t){var r,s,o,i,a,c,u,l,h,p,d,m,g,y,x=e.outputTensorSize,w=e.keepAspectRatio,S=e.borderMode,$=e.outputTensorFloatRange,N=As(n),_=function(F,L){return L?{xCenter:L.xCenter*F.width,yCenter:L.yCenter*F.height,width:L.width*F.width,height:L.height*F.height,rotation:L.rotation}:{xCenter:.5*F.width,yCenter:.5*F.height,width:F.width,height:F.height,rotation:0}}(N,t),O=function(F,L,z){if(z===void 0&&(z=!1),!z)return{top:0,left:0,right:0,bottom:0};var j=L.height,K=L.width;Va(L,"targetSize"),Va(F,"roi");var Y,te,re=j/K,ae=F.height/F.width,be=0,Ve=0;return re>ae?(Y=F.width,te=F.width*re,Ve=(1-ae/re)/2):(Y=F.height/re,te=F.height,be=(1-re/ae)/2),F.width=Y,F.height=te,{top:Ve,left:be,right:be,bottom:Ve}}(_,x,w),D=(r=_,s=N.width,o=N.height,i=!1,a=r.width,c=r.height,u=i?-1:1,l=Math.cos(r.rotation),h=Math.sin(r.rotation),p=r.xCenter,d=r.yCenter,m=1/s,g=1/o,(y=new Array(16))[0]=a*l*u*m,y[1]=-c*h*m,y[2]=0,y[3]=(-.5*a*l*u+.5*c*h+p)*m,y[4]=a*h*u*g,y[5]=c*l*g,y[6]=0,y[7]=(-.5*c*l-.5*a*h*u+d)*g,y[8]=0,y[9]=0,y[10]=a*m,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,hy(y));return{imageTensor:we(function(){var F=Hc(n),L=zt(ly(D,N,x),[1,8]),z=S==="zero"?"constant":"nearest",j=wn.transform(Lt(Ae(F,"float32")),L,"bilinear",z,0,[x.height,x.width]);return $!=null?py(j,$):j}),padding:O,transformationMatrix:D}}function wl(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function EN(n){return we(function(){var e=function(s){return we(function(){return[oe(s,[0,0,0],[1,-1,1]),oe(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:Ce(r),logits:Ce(t)}})}function dy(n){return n!=null&&n.currentTime!=null}function Cl(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<n.length;++i){var a=n[i];t=Math.min(t,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:s,xMax:r,yMax:o,width:r-t,height:o-s},e}function kN(n,e,t,r){return de(this,void 0,void 0,function(){var s,o,i,a,c;return fe(this,function(u){switch(u.label){case 0:return n.sort(function(l,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,l.score)}),s=zt(n.map(function(l){return[l.locationData.relativeBoundingBox.yMin,l.locationData.relativeBoundingBox.xMin,l.locationData.relativeBoundingBox.yMax,l.locationData.relativeBoundingBox.xMax]})),o=Ze(n.map(function(l){return l.score[0]})),[4,wn.nonMaxSuppressionAsync(s,o,e,t)];case 1:return[4,(i=u.sent()).array()];case 2:return a=u.sent(),c=n.filter(function(l,h){return a.indexOf(h)>-1}),tt([s,o,i]),[2,c]}})})}function fy(n,e){return n.map(function(t){var r=Te(Te({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function NN(n,e,t){return de(this,void 0,void 0,function(){var r,s,o,i,a,c,u,l,h,p,d,m,g,y,x,w,S,$,N,_,O,D,F,L;return fe(this,function(z){switch(z.label){case 0:if(r=Ce(e,[0]),s=r.shape,o=s[0],i=s[1],a=s[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+n.length+", heatmap length: "+a);return c=[],[4,r.buffer()];case 1:for(u=z.sent(),l=0;l<n.length;l++)if(h=n[l],p=Te({},h),c.push(p),d=Math.trunc(p.x*i),m=Math.trunc(p.y*o),!(d<0||d>=i||m<0||d>=o)){for(g=Math.trunc((t.kernelSize-1)/2),y=Math.max(0,d-g),x=Math.min(i,d+g+1),w=Math.max(0,m-g),S=Math.min(o,m+g+1),$=0,N=0,_=0,O=0,D=w;D<S;++D)for(F=y;F<x;++F)L=u.get(D,F,l),$+=L,O=Math.max(O,L),N+=F*L,_+=D*L;O>=t.minConfidenceToRefine&&$>0&&(p.x=N/i/$,p.y=_/o/$)}return r.dispose(),[2,c]}})})}function Sl(n,e){var t=e.left,r=e.top,s=e.left+e.right,o=e.top+e.bottom;return n.map(function(i){return Te(Te({},i),{x:(i.x-t)/(1-s),y:(i.y-r)/(1-o),z:i.z/(1-s)})})}function IN(n,e,t){return Ao()==="webgl"?function(r,s,o){var i=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `+i+`);

      setOutput(outputValue);
    }
`},c=ev();return we(function(){var u=c.compileAndRun(a,[r,s]);return On().makeTensorFromDataId(u.dataId,u.shape,u.dtype)})}(n,e,t):we(function(){var r=ce(e,.5),s=Us(r),o=ce(1,Dc(1,ee(s,ye(5.68842,ee(s,ye(-.748699,ee(s,ye(-57.8051,ee(s,ye(291.309,ee(s,-624.717)))))))))));return ye(e,ee(ce(n,e),ee(o,t.combineWithPreviousRatio)))})}function _N(n,e,t){return de(this,void 0,void 0,function(){var r,s,o,i,a;return fe(this,function(c){switch(c.label){case 0:return r=n[0],s=n[1],o=function(u,l,h){return we(function(){var p,d,m,g;h.reverseOutputOrder?(d=Ce(oe(u,[0,h.boxCoordOffset+0],[-1,1])),p=Ce(oe(u,[0,h.boxCoordOffset+1],[-1,1])),g=Ce(oe(u,[0,h.boxCoordOffset+2],[-1,1])),m=Ce(oe(u,[0,h.boxCoordOffset+3],[-1,1]))):(p=Ce(oe(u,[0,h.boxCoordOffset+0],[-1,1])),d=Ce(oe(u,[0,h.boxCoordOffset+1],[-1,1])),m=Ce(oe(u,[0,h.boxCoordOffset+2],[-1,1])),g=Ce(oe(u,[0,h.boxCoordOffset+3],[-1,1]))),d=ye(ee(ve(d,h.xScale),l.w),l.x),p=ye(ee(ve(p,h.yScale),l.h),l.y),h.applyExponentialOnBoxSize?(m=ee(Sn(ve(m,h.hScale)),l.h),g=ee(Sn(ve(g,h.wScale)),l.w)):(m=ee(ve(m,h.hScale),l.h),g=ee(ve(g,h.wScale),l.h));var y=ce(p,ve(m,2)),x=ce(d,ve(g,2)),w=ye(p,ve(m,2)),S=ye(d,ve(g,2)),$=Ge([V(y,[h.numBoxes,1]),V(x,[h.numBoxes,1]),V(w,[h.numBoxes,1]),V(S,[h.numBoxes,1])],1);if(h.numKeypoints)for(var N=0;N<h.numKeypoints;++N){var _=h.keypointCoordOffset+N*h.numValuesPerKeypoint,O=void 0,D=void 0;h.reverseOutputOrder?(O=Ce(oe(u,[0,_],[-1,1])),D=Ce(oe(u,[0,_+1],[-1,1]))):(D=Ce(oe(u,[0,_],[-1,1])),O=Ce(oe(u,[0,_+1],[-1,1])));var F=ye(ee(ve(O,h.xScale),l.w),l.x),L=ye(ee(ve(D,h.yScale),l.h),l.y);$=Ge([$,V(F,[h.numBoxes,1]),V(L,[h.numBoxes,1])],1)}return $})}(s,e,t),i=we(function(){var u=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(u=Nm(r,-t.scoreClippingThresh,t.scoreClippingThresh)),u=vn(u)):u}),[4,RN(o,i,t)];case 1:return a=c.sent(),tt([o,i]),[2,a]}})})}function RN(n,e,t){return de(this,void 0,void 0,function(){var r,s,o,i,a,c,u,l,h,p,d,m;return fe(this,function(g){switch(g.label){case 0:return r=[],[4,n.data()];case 1:return s=g.sent(),[4,e.data()];case 2:for(o=g.sent(),i=0;i<t.numBoxes;++i)if(!(t.minScoreThresh!=null&&o[i]<t.minScoreThresh||(a=i*t.numCoords,c=ON(s[a+0],s[a+1],s[a+2],s[a+3],o[i],t.flipVertically,i),(u=c.locationData.relativeBoundingBox).width<0||u.height<0))){if(t.numKeypoints>0)for((l=c.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,p=0;p<h;p+=t.numValuesPerKeypoint)d=a+t.keypointCoordOffset+p,m={x:s[d+0],y:t.flipVertically?1-s[d+1]:s[d+1]},l.relativeKeypoints.push(m);r.push(c)}return[2,r]}})})}function ON(n,e,t,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-t:n,xMax:r,yMax:o?1-n:t,width:r-e,height:t-n}}}}function AN(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Tl(n,e,t,r){return de(this,void 0,void 0,function(){var s,o,i,a,c,u,l,h;return fe(this,function(p){switch(p.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,o=s/e.numLandmarks,[4,n.data()];case 1:for(i=p.sent(),a=[],c=0;c<e.numLandmarks;++c)u=c*o,(h={x:0,y:0}).x=t?e.inputImageWidth-i[u]:i[u],o>1&&(h.y=r?e.inputImageHeight-i[u+1]:i[u+1]),o>2&&(h.z=i[u+2]),o>3&&(h.score=AN(e.visibilityActivation,i[u+3])),a.push(h);for(l=0;l<a.length;++l)(h=a[l]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function $l(n,e,t){var r=n.width,s=n.height,o=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(o=function(l,h){return h.rotation!=null?l+=h.rotation:h.rotationDegree!=null&&(l+=Math.PI*h.rotationDegree/180),uy(l)}(o,t)),o===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var i=(e.width*r*t.shiftX*Math.cos(o)-e.height*s*t.shiftY*Math.sin(o))/e.width,a=(e.width*r*t.shiftX*Math.sin(o)+e.height*s*t.shiftY*Math.cos(o))/e.height;n.xCenter=n.xCenter+i,n.yCenter=n.yCenter+a}if(t.squareLong){var c=Math.max(r*e.width,s*e.height);r=c/e.width,s=c/e.height}else if(t.squareShort){var u=Math.min(r*e.width,s*e.height);r=u/e.width,s=u/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function DN(n,e){return n.map(function(t){var r=Te(Te({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var Pn=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Li=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Pn(this.getAlpha(this.minCutOff)),this.dx=new Pn(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s=Math.trunc(t);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,i=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),c=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(a),c)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),za=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return nr(e);o=1/r}return e.map(function(i,a){var c=Te(Te({},i),{x:s.xFilters[a].apply(i.x,t,o),y:s.yFilters[a].apply(i.y,t,o)});return i.z!=null&&(c.z=s.zFilters[a].apply(i.z,t,o)),c})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Li(t.config)}),this.yFilters=e.map(function(r){return new Li(t.config)}),this.zFilters=e.map(function(r){return new Li(t.config)}))},n}(),Mi=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Pn(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s,o=Math.trunc(t);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)s=1;else{for(var i=e*r-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,c=i,u=a,l=(1+this.window.length)*(1e6/30),h=0,p=this.window;h<p.length;h++){var d=p[h];if(u+d.duration>l)break;c+=d.distance,u+=d.duration}var m=c/(1e-6*u);s=1-1/(1+this.config.velocityScale*Math.abs(m)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,s)},n}(),PN=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return nr(e);o=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(i,a){var c=Te(Te({},i),{x:s.xFilters[a].apply(i.x,t,o),y:s.yFilters[a].apply(i.y,t,o)});return i.z!=null&&(c.z=s.zFilters[a].apply(i.z,t,o)),c})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Mi(t.config)}),this.yFilters=e.map(function(r){return new Mi(t.config)}),this.zFilters=e.map(function(r){return new Mi(t.config)}))},n}(),Bi=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new PN(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new za(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,s,o){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var i=o!=null?function(u,l){return(u.width*l.width+u.height*l.height)/2}(o,r):1,a=s?fy(e,r):e,c=this.keypointsFilter.apply(a,t,i);return s?DN(c,r):c},n}(),El=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Pn(t.alpha)}));for(var r=[],s=0;s<e.length;++s){var o=e[s],i=Te({},o);i.score=this.visibilityFilters[s].apply(o.score),r.push(i)}return r},n}(),FN={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Sr={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},LN={maxPoses:1,flipHorizontal:!1},MN={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},BN=.3,kl={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},VN={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},UN={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},zN={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},WN={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},GN={kernelSize:7,minConfidenceToRefine:.5},Nl={alpha:.1},jN={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},HN={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},KN={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},qN={activation:"none"},XN={combineWithPreviousRatio:.7},YN=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return de(this,void 0,void 0,function(){return fe(this,function(e){return[2,iy(this.mask)]})})},n.prototype.toImageData=function(){return de(this,void 0,void 0,function(){return fe(this,function(e){return[2,ay(this.mask)]})})},n.prototype.toTensor=function(){return de(this,void 0,void 0,function(){return fe(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function QN(n){return cy(n),"person"}var ZN=function(){function n(e,t,r,s,o,i){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=o,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var p=[],d=0;d<h.numLayers;){for(var m=[],g=[],y=[],x=[],w=d;w<h.strides.length&&h.strides[w]===h.strides[d];){var S=wl(h.minScale,h.maxScale,w,h.strides.length);if(w===0&&h.reduceBoxesInLowestLayer)y.push(1),y.push(2),y.push(.5),x.push(.1),x.push(S),x.push(S);else{for(var $=0;$<h.aspectRatios.length;++$)y.push(h.aspectRatios[$]),x.push(S);if(h.interpolatedScaleAspectRatio>0){var N=w===h.strides.length-1?1:wl(h.minScale,h.maxScale,w+1,h.strides.length);x.push(Math.sqrt(S*N)),y.push(h.interpolatedScaleAspectRatio)}}w++}for(var _=0;_<y.length;++_){var O=Math.sqrt(y[_]);m.push(x[_]/O),g.push(x[_]*O)}var D=0,F=0;if(h.featureMapHeight.length>0)D=h.featureMapHeight[d],F=h.featureMapWidth[d];else{var L=h.strides[d];D=Math.ceil(h.inputSizeHeight/L),F=Math.ceil(h.inputSizeWidth/L)}for(var z=0;z<D;++z)for(var j=0;j<F;++j)for(var K=0;K<m.length;++K){var Y={xCenter:(j+h.anchorOffsetX)/F,yCenter:(z+h.anchorOffsetY)/D,width:0,height:0};h.fixedAnchorSize?(Y.width=1,Y.height=1):(Y.width=g[K],Y.height=m[K]),p.push(Y)}d=w}return p}(FN);var a=Ze(this.anchors.map(function(h){return h.width})),c=Ze(this.anchors.map(function(h){return h.height})),u=Ze(this.anchors.map(function(h){return h.xCenter})),l=Ze(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:u,y:l,w:a,h:c},this.prevFilteredSegmentationMask=this.enableSegmentation?zt([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return de(this,void 0,void 0,function(){var s,o,i,a,c,u,l,h,p,d,m,g,y,x,w,S,$,N,_,O,D,F,L;return fe(this,function(z){switch(z.label){case 0:return s=function(j){var K;if((K=j==null?LN:Te({},j)).maxPoses==null&&(K.maxPoses=1),K.maxPoses<=0)throw new Error("Invalid maxPoses "+K.maxPoses+". Should be > 0.");if(K.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return K}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:dy(e)?1e6*e.currentTime:null,o=As(e),i=we(function(){return Ae(Hc(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((c=z.sent()).length===0)return this.reset(),i.dispose(),[2,[]];u=c[0],a=this.poseDetectionToRoi(u,o),z.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return l=z.sent(),i.dispose(),l==null?(this.reset(),[2,[]]):(h=l.landmarks,p=l.auxiliaryLandmarks,d=l.poseScore,m=l.worldLandmarks,g=l.segmentationMask,y=this.poseLandmarkFiltering(h,p,m,o),x=y.actualLandmarksFiltered,w=y.auxiliaryLandmarksFiltered,S=y.actualWorldLandmarksFiltered,$=this.poseLandmarksToRoi(w,o),this.regionOfInterest=$,N=this.smoothSegmentation&&g!=null?this.poseSegmentationFiltering(g):g,(_=x!=null?fy(x,o):null)!=null&&_.forEach(function(j,K){j.name=Os[K]}),(O=S)!=null&&O.forEach(function(j,K){j.name=Os[K]}),D={score:d,keypoints:_,keypoints3D:O},N!==null&&(F=we(function(){var j=Lt(N,2),K=Un(j,[[0,0],[0,0],[0,1]]);return jm(K,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||tt(N),L={maskValueToLabel:QN,mask:new YN(F)},D.segmentation=L),[2,[D]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=IN(t,e,XN),tt(e)),tt(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),tt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(tt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=zt([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return de(this,void 0,void 0,function(){var t,r,s,o,i,a,c,u,l,h;return fe(this,function(p){switch(p.label){case 0:return t=Ua(e,VN),r=t.imageTensor,s=t.padding,o=this.detectorModel.predict(r),i=EN(o),a=i.boxes,[4,_N([c=i.logits,a],this.anchorTensor,MN)];case 1:return(u=p.sent()).length===0?(tt([r,o,c,a]),[2,u]):[4,kN(u,this.maxPoses,BN)];case 2:return l=p.sent(),h=function(d,m){d===void 0&&(d=[]);for(var g=m.left,y=m.top,x=m.left+m.right,w=m.top+m.bottom,S=0;S<d.length;S++){var $=d[S],N=$.locationData.relativeBoundingBox,_=(N.xMin-g)/(1-x),O=(N.yMin-y)/(1-w),D=N.width/(1-x),F=N.height/(1-w);N.xMin=_,N.yMin=O,N.width=D,N.height=F,N.xMax=_+D,N.yMax=O+F;var L=$.locationData.relativeKeypoints;L&&L.forEach(function(z){var j=(z.x-g)/(1-x),K=(z.y-y)/(1-w);z.x=j,z.y=K})}return d}(l,s),tt([r,o,c,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(e,t){return $l(Pi(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,kl)},n.prototype.poseLandmarksByRoi=function(e,t){return de(this,void 0,void 0,function(){var r,s,o,i,a,c,u,l,h,p,d,m,g,y;return fe(this,function(x){switch(x.label){case 0:if(r=As(t),s=Ua(t,UN,e),o=s.imageTensor,i=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType);return c=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&c.push("activation_segmentation"),u=this.landmarkModel.execute(o,c),[4,this.tensorsToPoseLandmarksAndSegmentation(u)];case 1:return(l=x.sent())==null?(tt(u),tt(o),[2,null]):(h=l.landmarks,p=l.auxiliaryLandmarks,d=l.poseScore,m=l.worldLandmarks,g=l.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,i,a,h,p,m,g)]);case 2:return y=x.sent(),tt(u),tt(o),[2,Te({poseScore:d},y)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,s,o,i,a,c){return de(this,void 0,void 0,function(){var u,l,h,p,d,m;return fe(this,function(g){return u=Sl(o,r),l=Sl(i,r),h=vl(u,t),p=vl(l,t),d=function(y,x){for(var w=[],S=0,$=y;S<$.length;S++){var N=$[S],_=N.x,O=N.y,D=x.rotation,F=Math.cos(D)*_-Math.sin(D)*O,L=Math.sin(D)*_+Math.cos(D)*O,z=Te({},N);z.x=F,z.y=L,w.push(z)}return w}(a,t),m=null,this.enableSegmentation&&(m=we(function(){var y=c.shape,x=y[0],w=y[1],S=function(_){var O=hy(new Array(16).fill(0));O[0][0]=et(_,0,0),O[1][0]=-et(_,0,1),O[2][0]=et(_,0,2),O[3][0]=-et(_,0,3),O[0][2]=et(_,2,0),O[1][2]=-et(_,2,1),O[2][2]=et(_,2,2),O[3][2]=-et(_,2,3),O[0][1]=-et(_,1,0),O[1][1]=et(_,1,1),O[2][1]=-et(_,1,2),O[3][1]=et(_,1,3),O[0][3]=-et(_,3,0),O[1][3]=et(_,3,1),O[2][3]=-et(_,3,2),O[3][3]=et(_,3,3);for(var D=_[0][0]*O[0][0]+_[1][0]*O[0][1]+_[2][0]*O[0][2]+_[3][0]*O[0][3],F=0;F<O.length;F++)for(var L=0;L<O.length;L++)O[F][L]/=D;return O}(s),$=zt(ly(S,{width:w,height:x},e),[1,8]),N=[1,x,w,1];return Ce(wn.transform(V(c,N),$,"bilinear","constant",0,[e.height,e.width]),[0,3])}),tt(c)),[2,{landmarks:h,auxiliaryLandmarks:p,worldLandmarks:d,segmentationMask:m}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return de(this,void 0,void 0,function(){var t,r,s,o,i,a,c,u,l,h,p,d,m;return fe(this,function(g){switch(g.label){case 0:return t=e[0],r=e[1],s=e[2],o=e[3],i=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=g.sent()[0])<.5?[2,null]:[4,Tl(t,zN)];case 2:return[4,NN(g.sent(),s,GN)];case 3:return c=g.sent(),u=c.slice(0,33),l=c.slice(33,35),[4,Tl(o,WN)];case 4:return h=g.sent(),p=h.slice(0,33),d=function(y,x,w){w===void 0&&(w=!0);for(var S=[],$=0;$<y.length;$++){var N=Te({},x[$]);w&&(N.score=y[$].score),S.push(N)}return S}(u,p,!0),m=this.enableSegmentation?function(y,x,w){return we(function(){var S=Ce(y,[0]),$=S.shape[2];if($===1){var N=S;switch(x.activation){case"none":break;case"sigmoid":N=vn(N);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+x.activation+")")}var _=w?wn.resizeBilinear(N,[w.height,w.width]):N;return Ce(_,[2])}throw new Error("Unsupported number of tensor channels "+$)})}(i,qN):null,[2,{landmarks:u,auxiliaryLandmarks:l,poseScore:a,worldLandmarks:d,segmentationMask:m}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return $l(Pi(Cl(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,kl)},n.prototype.poseLandmarkFiltering=function(e,t,r,s){var o,i,a;if(this.timestamp!=null&&this.enableSmoothing){var c=Pi(Cl(t),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new El(Nl)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new El(Nl)),i=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new Bi(jN)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,s,!0,c),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new Bi(HN)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,s,!0,c),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new Bi(KN)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else o=e,i=t,a=r;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},n}();function JN(n){return de(this,void 0,void 0,function(){var e,t,r,s,o,i;return fe(this,function(a){switch(a.label){case 0:return e=function(c){var u=Te({},c==null?Sr:c);if(u.enableSmoothing==null&&(u.enableSmoothing=Sr.enableSmoothing),u.enableSegmentation==null&&(u.enableSegmentation=Sr.enableSegmentation),u.smoothSegmentation==null&&(u.smoothSegmentation=Sr.smoothSegmentation),u.modelType==null&&(u.modelType=Sr.modelType),u.detectorModelUrl==null&&(u.detectorModelUrl=Sr.detectorModelUrl),u.landmarkModelUrl==null)switch(u.modelType){case"lite":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:u.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return u}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([zr(e.detectorModelUrl,{fromTFHub:t}),zr(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),o=s[0],i=s[1],[2,new ZN(o,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var ir,He,my=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but encountered "+t.maxTracks);if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but encountered "+t.maxAge);if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+t.keypointTrackerParams.keypointConfidenceThreshold);if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but encountered "+t.keypointTrackerParams.minNumberOfKeypoints);for(var r=0,s=t.keypointTrackerParams.keypointFalloff;r<s.length;r++){var o=s[r];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive but encountered "+o)}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var s=Array.from(Array(t[0].length).keys()),o=[],i=0,a=Array.from(Array(e.length).keys());i<a.length;i++){var c=a[i];if(s.length!==0){for(var u=-1,l=-1,h=0,p=s;h<p.length;h++){var d=p[h],m=t[c][d];m>=this.minSimilarity&&m>l&&(u=d,l=m)}if(u>=0){var g=this.tracks[u];g=Object.assign(g,this.createTrack(e[c],r,g.id)),e[c].id=g.id;var y=s.indexOf(u);s.splice(y,1)}else o.push(c)}else o.push(c)}for(var x=0,w=o;x<w.length;x++){c=w[x];var S=this.createTrack(e[c],r);this.tracks.push(S),e[c].id=S.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var s={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:nr(e.keypoints).map(function(o){return Te({},o)})};return e.box!==void 0&&(s.box=Te({},e.box)),s},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),eI=function(n){function e(t){return n.call(this,t)||this}return oy(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(s){return r.tracks.map(function(o){return r.iou(s,o)})})},e.prototype.iou=function(t,r){var s=Math.max(t.box.xMin,r.box.xMin),o=Math.max(t.box.yMin,r.box.yMin),i=Math.min(t.box.xMax,r.box.xMax),a=Math.min(t.box.yMax,r.box.yMax);if(s>=i||o>=a)return 0;var c=(i-s)*(a-o);return c/(t.box.width*t.box.height+r.box.width*r.box.height-c)},e}(my),tI=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return oy(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,o=t;s<o.length;s++){for(var i=o[s],a=[],c=0,u=this.tracks;c<u.length;c++){var l=u[c];a.push(this.oks(i,l))}r.push(a)}return r},e.prototype.oks=function(t,r){for(var s=this.area(r.keypoints)+1e-6,o=0,i=0,a=0;a<t.keypoints.length;++a){var c=t.keypoints[a],u=r.keypoints[a];if(!(c.score<this.keypointThreshold||u.score<this.keypointThreshold)){i+=1;var l=Math.pow(c.x-u.x,2)+Math.pow(c.y-u.y,2),h=2*this.keypointFalloff[a];o+=Math.exp(-1*l/(2*s*Math.pow(h,2)))}}return i<this.minNumKeyoints?0:o/i},e.prototype.area=function(t){var r=this,s=t.filter(function(c){return c.score>r.keypointThreshold}),o=Math.min.apply(Math,nr([1],s.map(function(c){return c.x}))),i=Math.max.apply(Math,nr([0],s.map(function(c){return c.x}))),a=Math.min.apply(Math,nr([1],s.map(function(c){return c.y})));return(i-o)*(Math.max.apply(Math,nr([0],s.map(function(c){return c.y})))-a)},e}(my);function gy(n){switch(n){case He.BlazePose:return Os.reduce(function(e,t,r){return e[t]=r,e},{});case He.PoseNet:case He.MoveNet:return dn.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model "+n+" is not supported.")}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(ir||(ir={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(He||(He={}));var Dr=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case He.BlazePose:return yN;case He.PoseNet:case He.MoveNet:return xN;default:throw new Error("Model "+n+" is not supported.")}},getAdjacentPairs:function(n){switch(n){case He.BlazePose:return vN;case He.PoseNet:case He.MoveNet:return bN;default:throw new Error("Model "+n+" is not supported.")}},getKeypointIndexByName:gy}),Il=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],yy={modelType:"SinglePose.Lightning",enableSmoothing:!0},_l={},Rl={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Vi={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Ol={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function nI(n,e,t,r){for(var s={},o=0,i=dn;o<i.length;o++){var a=i[o];s[a]=[e[t[a]].y*r.height,e[t[a]].x*r.width]}if(function(w,S){return(w[S.left_hip].score>.2||w[S.right_hip].score>.2)&&(w[S.left_shoulder].score>.2||w[S.right_shoulder].score>.2)}(e,t)){var c=(s.left_hip[0]+s.right_hip[0])/2,u=(s.left_hip[1]+s.right_hip[1])/2,l=function(w,S,$,N,_){for(var O=["left_shoulder","right_shoulder","left_hip","right_hip"],D=0,F=0,L=0;L<O.length;L++)(te=Math.abs(N-$[O[L]][0]))>D&&(D=te),(re=Math.abs(_-$[O[L]][1]))>F&&(F=re);for(var z=0,j=0,K=0,Y=Object.keys($);K<Y.length;K++){var te,re,ae=Y[K];w[S[ae]].score<.2||((te=Math.abs(N-$[ae][0]))>z&&(z=te),(re=Math.abs(_-$[ae][1]))>j&&(j=re))}return[D,F,z,j]}(e,t,s,c,u),h=l[0],p=l[1],d=l[2],m=l[3],g=Math.max(1.9*p,1.9*h,1.2*d,1.2*m),y=[c-(g=Math.min(g,Math.max(u,r.width-u,c,r.height-c))),u-g];if(g>Math.max(r.width,r.height)/2)return Wa(n==null,r);var x=2*g;return{yMin:y[0]/r.height,xMin:y[1]/r.width,yMax:(y[0]+x)/r.height,xMax:(y[1]+x)/r.width,height:(y[0]+x)/r.height-y[0]/r.height,width:(y[1]+x)/r.width-y[1]/r.width}}return Wa(n==null,r)}function Wa(n,e){var t,r,s,o;return n?e.width>e.height?(t=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):(t=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:o,yMax:s+t,xMax:o+r,height:t,width:r}}function rI(n){var e,t=n==null?yy:Te({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(Il.indexOf(t.modelType)<0)throw new Error("Invalid architecture "+t.modelType+". Should be one of "+Il);if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=ir.BoundingBox),t.trackerType===ir.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var s=Al(Vi,r);return s.keypointTrackerParams=Te({},Vi.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(t.trackerConfig):t.trackerConfig=Vi;else{if(t.trackerType!==ir.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Al(Ol,e)):t.trackerConfig=Ol}return t}function Al(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var sI=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=gy(He.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new za(Rl),this.cropRegionFilterYMin=new Pn(.9),this.cropRegionFilterXMin=new Pn(.9),this.cropRegionFilterYMax=new Pn(.9),this.cropRegionFilterXMax=new Pn(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===ir.Keypoint?this.tracker=new tI(t.trackerConfig):t.trackerType===ir.BoundingBox&&(this.tracker=new eI(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return de(this,void 0,void 0,function(){var t,r,s,o,i;return fe(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Ao()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=a.sent(),a.label=3;case 3:for(t.dispose(),s={keypoints:[],score:0},o=0,i=0;i<17;++i)s.keypoints[i]={y:r[3*i],x:r[3*i+1],score:r[3*i+2]},s.keypoints[i].score>.2&&(++o,s.score+=s.keypoints[i].score);return o>0&&(s.score/=o),[2,s]}})})},n.prototype.runMultiPersonPoseModel=function(e){return de(this,void 0,void 0,function(){var t,r,s,o,i,a,c,u;return fe(this,function(l){switch(l.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Ao()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=l.sent(),l.label=3;case 3:for(t.dispose(),s=[],o=r.length/56,i=0;i<o;++i)for(s[i]={keypoints:[]},a=56*i+51,s[i].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},c=56*i+55,s[i].score=r[c],s[i].keypoints=[],u=0;u<17;++u)s[i].keypoints[u]={y:r[56*i+3*u],x:r[56*i+3*u+1],score:r[56*i+3*u+2]};return[2,s]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=_l),de(this,void 0,void 0,function(){var s,o,i,a,c,u;return fe(this,function(l){switch(l.label){case 0:return t=function(h){return h==null?_l:Te({},h)}(t),e==null?(this.reset(),[2,[]]):(r==null?dy(e)&&(r=1e6*e.currentTime):r*=1e3,s=Hc(e),o=As(s),i=Lt(s,0),e instanceof Fe||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,o,r)]);case 1:return a=l.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,o,r)];case 3:a=l.sent(),l.label=4;case 4:for(c=0;c<a.length;++c)for(u=0;u<a[c].keypoints.length;++u)a[c].keypoints[u].name=dn[u],a[c].keypoints[u].y*=o.height,a[c].keypoints[u].x*=o.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,r){return de(this,void 0,void 0,function(){var s,o,i,a,c=this;return fe(this,function(u){switch(u.label){case 0:return this.cropRegion||(this.cropRegion=Wa(this.cropRegion==null,t)),s=we(function(){var l=zt([[c.cropRegion.yMin,c.cropRegion.xMin,c.cropRegion.yMax,c.cropRegion.xMax]]),h=Vn([1],"int32"),p=[c.modelInputResolution.height,c.modelInputResolution.width];return Ae(wn.cropAndResize(e,l,h,p,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(o=u.sent(),s.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<o.keypoints.length;++i)o.keypoints[i].y=this.cropRegion.yMin+o.keypoints[i].y*this.cropRegion.height,o.keypoints[i].x=this.cropRegion.xMin+o.keypoints[i].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,r,1)),a=nI(this.cropRegion,o.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return de(this,void 0,void 0,function(){var s,o,i,a,c,u,l,h,p,d,m,g=this;return fe(this,function(y){switch(y.label){case 0:return t.width>t.height?(o=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*t.height/t.width),s=wn.resizeBilinear(e,[i,o]),c=o,u=32*Math.ceil(i/32),a=Un(s,[[0,0],[0,u-i],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*t.width/t.height),i=this.multiPoseMaxDimension,s=wn.resizeBilinear(e,[i,o]),c=32*Math.ceil(o/32),u=i,a=Un(s,[[0,0],[0,0],[0,c-o],[0,0]])),s.dispose(),e.dispose(),l=Ae(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(l)];case 1:for(h=y.sent(),l.dispose(),h=h.filter(function(x){return x.score>=g.minPoseScore}),d=0;d<h.length;++d)for(p=0;p<h[d].keypoints.length;++p)h[d].keypoints[p].y*=u/i,h[d].keypoints[p].x*=c/o;if(this.enableTracking&&(this.tracker.apply(h,r),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new za(Rl)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,r,1);m=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(x,w){m.has(w)||g.keypointFilterMap.delete(w)})}return[2,h]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:s,xMax:o,height:s-t,width:o-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function oI(n){return n===void 0&&(n=yy),de(this,void 0,void 0,function(){var e,t,r,s;return fe(this,function(o){switch(o.label){case 0:return e=rI(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,zr(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=o.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,zr(s,{fromTFHub:r})];case 3:t=o.sent(),o.label=4;case 4:return Ao()==="webgl"&&M().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new sI(t,e)]}})})}var Dl={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},Pl=["MobileNetV1","ResNet50"],Fl={MobileNetV1:[8,16],ResNet50:[16]},iI=[8,16,32],Ll={MobileNetV1:[.5,.75,1],ResNet50:[1]},Ml=[1,2,4],aI={maxPoses:1,flipHorizontal:!1},cI={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},uI=[-123.15,-115.9,-103.06];function Ui(n){return Math.floor(n/2)}var lI=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(Ui(e),e);)this.exchange(e,Ui(e)),e=Ui(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function hI(n,e,t,r,s,o){for(var i=o.shape,a=i[0],c=i[1],u=!0,l=Math.max(t-s,0),h=Math.min(t+s+1,a),p=l;p<h;++p){for(var d=Math.max(r-s,0),m=Math.min(r+s+1,c),g=d;g<m;++g)if(o.get(p,g,n)>e){u=!1;break}if(!u)break}return u}function pI(n){return de(this,void 0,void 0,function(){return fe(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function xy(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function by(n,e,t){var r=xy(n.heatmapY,n.heatmapX,n.id,t),s=r.y,o=r.x;return{x:n.heatmapX*e+o,y:n.heatmapY*e+s}}function vy(n,e,t,r){var s=t.x,o=t.y;return n.some(function(i){var a,c,u,l,h,p,d=i.keypoints;return a=o,c=s,u=d[r].y,l=d[r].x,(h=u-a)*h+(p=l-c)*p<=e})}var Bl=dn.reduce(function(n,e,t){return n[e]=t,n},{}),wy=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[Bl[e],Bl[t]]}),zi=wy.map(function(n){return n[1]}),Vl=wy.map(function(n){return n[0]});function Ul(n,e,t){return n<e?e:n>t?t:n}function Wi(n,e,t,r){return{y:Ul(Math.round(n.y/e),0,t-1),x:Ul(Math.round(n.x/e),0,r-1)}}function zl(n,e){return{x:n.x+e.x,y:n.y+e.y}}function Wl(n,e,t,r,s,o,i,a){a===void 0&&(a=2);for(var c=r.shape,u=c[0],l=c[1],h={y:e.y,x:e.x},p=zl(h,function(w,S,$){var N=$.shape[2]/2;return{y:$.get(S.y,S.x,w),x:$.get(S.y,S.x,N+w)}}(n,Wi(h,o,u,l),i)),d=0;d<a;d++){var m=Wi(p,o,u,l),g=xy(m.y,m.x,t,s);p=zl({x:m.x*o,y:m.y*o},{x:g.x,y:g.y})}var y=Wi(p,o,u,l),x=r.get(y.y,y.x,t);return{y:p.y,x:p.x,name:dn[t],score:x}}function dI(n,e,t,r,s,o){var i=e.shape[2],a=zi.length,c=new Array(i),u=n.part,l=n.score,h=by(u,r,t);c[u.id]={score:l,name:dn[u.id],y:h.y,x:h.x};for(var p=a-1;p>=0;--p){var d=zi[p],m=Vl[p];c[d]&&!c[m]&&(c[m]=Wl(p,c[d],m,e,t,r,o))}for(p=0;p<a;++p)d=Vl[p],m=zi[p],c[d]&&!c[m]&&(c[m]=Wl(p,c[d],m,e,t,r,s));return c}function fI(n,e,t){return t.reduce(function(r,s,o){var i=s.y,a=s.x,c=s.score;return vy(n,e,{y:i,x:a},o)||(r+=c),r},0)/t.length}function mI(n,e,t,r,s,o,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),de(this,void 0,void 0,function(){var c,u,l,h,p,d,m,g,y,x,w,S;return fe(this,function($){switch($.label){case 0:return[4,pI([n,e,t,r])];case 1:for(c=$.sent(),u=c[0],l=c[1],h=c[2],p=c[3],d=[],m=function(N,_,O){for(var D=O.shape,F=D[0],L=D[1],z=D[2],j=new lI(F*L*z,function(ae){return ae.score}),K=0;K<F;++K)for(var Y=0;Y<L;++Y)for(var te=0;te<z;++te){var re=O.get(K,Y,te);re<N||hI(te,re,K,Y,_,O)&&j.enqueue({score:re,part:{heatmapY:K,heatmapX:Y,id:te}})}return j}(i,1,u),g=a*a;d.length<o&&!m.empty();)y=m.dequeue(),x=by(y.part,s,l),vy(d,g,x,y.part.id)||(w=dI(y,u,l,s,h,p),S=fI(d,g,w),d.push({keypoints:w,score:S}));return[2,d]}})})}function gI(n){var e=n.shape,t=e[0],r=e[1],s=e[2];return we(function(){var o,i,a=V(n,[t*r,s]),c=Sm(a,0),u=Lt(ve(c,he(r,"int32")),1),l=Lt((o=c,i=r,we(function(){var h=ve(o,he(i,"int32"));return ce(o,ee(h,he(i,"int32")))})),1);return Ge([u,l],1)})}function yI(n,e,t){return we(function(){var r=function(s,o){for(var i=[],a=0;a<dn.length;a++){var c=s.get(a,0).valueOf(),u=s.get(a,1).valueOf(),l=xI(c,u,a,o),h=l.x,p=l.y;i.push(p),i.push(h)}return zt(i,[dn.length,2])}(n,t);return ye(Ae(ee(n.toTensor(),he(e,"int32")),"float32"),r)})}function xI(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+dn.length)}}function bI(n,e,t){return de(this,void 0,void 0,function(){var r,s,o,i,a,c,u,l,h,p;return fe(this,function(d){switch(d.label){case 0:return r=0,s=gI(n),[4,Promise.all([n.buffer(),e.buffer(),s.buffer()])];case 1:return o=d.sent(),i=o[0],a=o[1],c=o[2],[4,(u=yI(c,t,a)).buffer()];case 2:return l=d.sent(),h=Array.from(function(m,g){for(var y=g.shape[0],x=new Float32Array(y),w=0;w<y;w++){var S=g.get(w,0),$=g.get(w,1);x[w]=m.get(S,$,w)}return x}(i,c)),p=h.map(function(m,g){return r+=m,{y:l.get(g,0),x:l.get(g,1),score:m,name:dn[g]}}),s.dispose(),u.dispose(),[2,{keypoints:p,score:r/p.length}]}})})}function Gl(n,e){return(n-1)%e==0}var jl="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Hl="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Kl(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var ql=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;k(r[1]===-1&&r[2]===-1,function(){return"Input shape ["+r[1]+", "+r[2]+"] must both be equal to or -1"});var s,o,i=(s=t.inputResolution,o=t.outputStride,{height:Kl(s.height,o),width:Kl(s.width,o)});(function(a){k(iI.indexOf(a)>=0,function(){return"outputStride of "+a+" is invalid. It must be either 8 or 16."})})(t.outputStride),function(a,c){k(Gl(a.height,c),function(){return"height of "+a.height+" is invalid for output stride "+c+"."}),k(Gl(a.width,c),function(){return"width of "+a.width+" is invalid for output stride "+c+"."})}(i,t.outputStride),this.inputResolution=i,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=aI),de(this,void 0,void 0,function(){var r,s,o,i,a,c,u,l,h,p,d,m,g,y,x;return fe(this,function(w){switch(w.label){case 0:return r=function(S){var $=S;if($.maxPoses==null&&($.maxPoses=1),$.maxPoses<=0)throw new Error("Invalid maxPoses "+$.maxPoses+". Should be > 0.");if($.maxPoses>1){if(($=Te(Te({},cI),$)).scoreThreshold<0||$.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+$.scoreThreshold+". Should be in range [0.0, 1.0]");if($.nmsRadius<=0)throw new Error("Invalid nmsRadius "+$.nmsRadius+".")}return $}(t),e==null?[2,[]]:(this.maxPoses=r.maxPoses,s=Ua(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=s.imageTensor,i=s.padding,a=this.architecture==="ResNet50"?ye(o,uI):py(o,[-1,1]),c=this.posenetModel.predict(a),this.architecture==="ResNet50"?(u=Ce(c[2],[0]),l=Ce(c[3],[0]),h=Ce(c[0],[0]),p=Ce(c[1],[0])):(u=Ce(c[0],[0]),l=Ce(c[1],[0]),h=Ce(c[2],[0]),p=Ce(c[3],[0])),d=vn(l),this.maxPoses!==1?[3,2]:[4,bI(d,u,this.outputStride)]);case 1:return g=w.sent(),m=[g],[3,4];case 2:return[4,mI(d,u,h,p,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 3:m=w.sent(),w.label=4;case 4:return y=As(e),x=function(S,$,N,_){var O=$.height,D=$.width,F=O/(N.height*(1-_.top-_.bottom)),L=D/(N.width*(1-_.left-_.right)),z=-_.top*N.height,j=-_.left*N.width;if(L===1&&F===1&&z===0&&j===0)return S;for(var K=0,Y=S;K<Y.length;K++)for(var te=0,re=Y[K].keypoints;te<re.length;te++){var ae=re[te];ae.x=(ae.x+j)*L,ae.y=(ae.y+z)*F}return S}(m,y,this.inputResolution,i),r.flipHorizontal&&(x=function(S,$){for(var N=0,_=S;N<_.length;N++)for(var O=0,D=_[N].keypoints;O<D.length;O++){var F=D[O];F.x=$.width-1-F.x}return S}(x,y)),o.dispose(),a.dispose(),tt(c),u.dispose(),l.dispose(),h.dispose(),p.dispose(),d.dispose(),[2,x]}})})},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function vI(n){return n===void 0&&(n=Dl),de(this,void 0,void 0,function(){var e,t,r,s,o;return fe(this,function(i){switch(i.label){case 0:return(e=function(l){var h=l||Dl;if(h.architecture==null&&(h.architecture="MobileNetV1"),Pl.indexOf(h.architecture)<0)throw new Error("Invalid architecture "+h.architecture+". Should be one of "+Pl);if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),Fl[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride "+h.outputStride+". Should be one of "+Fl[h.architecture]+" for architecture "+h.architecture+".");if(h.multiplier==null&&(h.multiplier=1),Ll[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier "+h.multiplier+". Should be one of "+Ll[h.architecture]+" for architecture "+h.architecture+".");if(h.quantBytes==null&&(h.quantBytes=4),Ml.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes "+h.quantBytes+". Should be one of "+Ml+" for architecture "+h.architecture+".");if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,c=e.quantBytes,u="model-stride"+a+".json",t=c===4?Hl+"float/"+u:Hl+"quant"+c+"/"+u,[4,zr(e.modelUrl||t)]);case 1:return r=i.sent(),[2,new ql(r,e)];case 2:return s=function(l,h,p){var d={1:"100",.75:"075",.5:"050"},m="model-stride"+l+".json";return p===4?jl+"float/"+d[h]+"/"+m:jl+"quant"+p+"/"+d[h]+"/"+m}(e.outputStride,e.multiplier,e.quantBytes),[4,zr(e.modelUrl||s)];case 3:return o=i.sent(),[2,new ql(o,e)]}var a,c,u})})}function wI(n,e){return de(this,void 0,void 0,function(){var t,r;return fe(this,function(s){switch(n){case He.PoseNet:return[2,vI(e)];case He.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,JN(e)];if(t.runtime==="mediapipe")return[2,$N(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r);case He.MoveNet:return[2,oI(e)];default:throw new Error(n+" is not a supported model name.")}})})}var CI={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}},Ir=(n=>(n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet",n))(Ir||{}),At=(n=>(n.Front="Front",n.Left="Left",n.Right="Right",n.Back="Back",n.Unknown="Unknown",n))(At||{});function SI(n,e){let t=0,r=0,s=n.width,o=n.height;const i=o/s,a=e.height/e.width;return a>i?(s=Math.ceil(n.height/a),t=Math.ceil((n.width-s)/2)):a<i&&(o=Math.ceil(a*n.width),r=Math.ceil((n.height-o)/2)),[t,r,s,o]}function TI(n,e){let t=[0,0,0],r=[-1,-1,3];const[s,o]=n.shape,i=s/o,a=e.height/e.width;return a>i?(t=[0,Math.ceil((o-Math.ceil(s/a))/2),0],r=[-1,Math.ceil(s/a),3]):a<i&&(t=[Math.ceil((s-Math.ceil(a*o))/2),0,0],r=[Math.ceil(a*o),-1,3]),wn.resizeBilinear(oe(n,t,r),[e.height,e.width])}function $I(n){const e=Array.from(n).sort((r,s)=>r-s),t=Math.floor(e.length/2);return e.length%2===0?(e[t-1]+e[t])/2:e[t]}function Cy(n){return n.reduce((e,t)=>e+t,0)/n.length}function EI(n){if(n.length<=1)return 0;const e=Cy(n);return Math.sqrt(n.reduce((t,r)=>t+Math.pow(r-e,2),0)/(n.length-1))}class Wr{constructor(e,t,r=1.75){ue(this,"keypoints");ue(this,"modelName");ue(this,"userHeight");ue(this,"score");ue(this,"auxillaryPoints",{aux_torso_center:["left_shoulder","right_shoulder","left_hip","right_hip"],aux_hip_center:["left_hip","right_hip"],aux_knee_center:["left_knee","right_knee"],aux_shoulder_center:["left_shoulder","right_shoulder"],aux_head_center:["left_ear","right_ear"],aux_ankle_center:["left_ankle","right_ankle"],aux_mouth:["mouth_left","mouth_right"],aux_eye_center:["left_eye","right_eye"]});ue(this,"calculatedAuxillaryPoints",{aux_neck:()=>this.auxNeck,aux_back_head:()=>this.auxBackHead});if(e.length!==33&&e.length!==17)throw new Error(`[${this.constructor.name}] Received wrong pose format, should be 33 or 17, received ${e.length}`);this.keypoints=e,this.modelName=t,this.userHeight=r}update(e){return this.keypoints=e,this}updateTF(e){return this.keypoints=ja(e.keypoints,!0),this.score=e.score,this}getScorePolicy(){let e="mean";switch(this.direction){case At.Front:case At.Back:e="mean";break;case At.Left:case At.Right:e="max";break;default:e="mean";break}return e}getMax(e,t=.5){return this.keypoints.filter(r=>{var s;return((s=r.score)!=null?s:0)>=t}).reduce((r,s)=>{var o;return Math.max(r,(o=s[e])!=null?o:0)},0)}getMin(e,t=.5){return this.keypoints.filter(r=>{var s;return((s=r.score)!=null?s:0)>=t}).reduce((r,s)=>{var o;return Math.min(r,(o=s[e])!=null?o:0)},Number.POSITIVE_INFINITY)}get direction(){return this.detectDirections()}get auxHipCenter(){const e="aux_hip_center";return this.getCenter(e,this.auxillaryPoints[e])}get auxKneeCenter(){const e="aux_knee_center";return this.getCenter(e,this.auxillaryPoints[e])}get auxShoulderCenter(){const e="aux_shoulder_center";return this.getCenter(e,this.auxillaryPoints[e])}get auxTorsoCenter(){const e="aux_torso_center";return this.getCenter(e,this.auxillaryPoints[e])}get auxHeadCenter(){const e="aux_head_center";return this.getCenter(e,this.auxillaryPoints[e])}get auxAnkleCenter(){const e="aux_ankle_center";return this.getCenter(e,this.auxillaryPoints[e])}get auxToeCenter(){let e=0;if(this.direction===At.Front)e=-.5;else return this.auxAnkleCenter;const t=this.bodyHeight/(6.6-e)*Math.SQRT1_2;return this.auxAnkleCenter.add({x:0,y:t})}get auxNeck(){const[e,t,r]=this.getKeypointsByName(["aux_shoulder_center","aux_torso_center","aux_head_center"]);return e.add(e.subtract(t).multiply(.2))}get auxBackHead(){const[e,t]=this.getKeypointsByName(["nose","aux_head_center"]);return t.add(t.subtract(e).multiply(.5))}detectDirections(e=.2){const[t,r]=this.getKeypointsByName(["left_shoulder","right_shoulder"]),s=3.5,o=t.x-r.x;if(this.torsoRatio<s)return o>0?At.Front:At.Back;const i=[];this.leftKeypoints.forEach((c,u)=>{var l,h;if(c!==void 0){const p=this.rightKeypoints[u],d=((l=p==null?void 0:p.score)!=null?l:0)-((h=c==null?void 0:c.score)!=null?h:0);Math.abs(d)>=e?i.push(d>0?1:-1):i.push(0)}});const a=i.reduce((c,u)=>c+u,0);return a<0?At.Left:a>0?At.Right:At.Front}detectAngle(e,t,r){const[s,o,i]=this.getKeypointsByName([e,t,r]);return NI(s,o,i)}detectPerpendicularDist(e,t,r){const[s,o,i]=this.getKeypointsByName([e,t,r]),a=II(s,o,i);return this.pixelToReal(a)}get bodyHeight(){return this.auxHeadCenter.subtract(this.auxAnkleCenter).length}get torsoHeight(){return this.auxShoulderCenter.subtract(this.auxHipCenter).length}get legLength(){return this.auxHipCenter.subtract(this.auxAnkleCenter).length}get torsoRatio(){return this.torsoHeight/this.torsoWidth}get torsoWidth(){const[e,t,r,s]=this.getKeypointsByName(["left_shoulder","right_shoulder","left_hip","right_hip"]);return yo([r,e]).distanceTo(yo([s,t]))}get headWidth(){const[e,t]=this.getKeypointsByName(["left_ear","right_ear"]);return e.distanceTo(t)}getCenter(e,t,r="mean"){const s=this.getKeypointsByName(t);r===void 0&&(r=this.getScorePolicy());const o=yo(s,r);return o.name=e,o}getAuxillaryPointByName(e){if(e in this.auxillaryPoints)return this.getCenter(e,this.auxillaryPoints[e]);if(e in this.calculatedAuxillaryPoints)return this.calculatedAuxillaryPoints[e]();throw new Error(`[${this.constructor.name}] no aux point named ${e}`)}pixelToReal(e,t=.27){const r=this.torsoHeight;return this.userHeight*t/r*e}jointAngleAnalysis(e,t,r){const s=[e,t,r],o=this.detectAngle(...s),i=this.detectPerpendicularDist(...s);return[o,i]}getKeypointsByName(e){return Ga(this.keypoints,e,this.modelName)}getKeypointByName(e){return zo(this.keypoints,e,this.modelName)}getKeypointsIdBySide(e){return Dr.getKeypointIndexBySide(this.modelName)[e]}getKeypointsBySide(e){return Dr.getKeypointIndexBySide(this.modelName)[e].map(r=>this.keypoints[r])}get leftKeypoints(){return this.getKeypointsBySide("left")}get rightKeypoints(){return this.getKeypointsBySide("right")}get scores(){return this.keypoints.map(e=>{var t;return(t=e.score)!=null?t:0})}get scoreMedian(){return $I(this.scores)}get scoreMean(){return this.scores.reduce((e,t)=>e+t,0)/this.scores.length}get connections(){return Dr.getAdjacentPairs(this.modelName)}applyOffset(e){this.keypoints=this.keypoints.map(t=>t.subtract(e))}validateHeadVisibility(e=.5){var t;if(((t=this.auxHeadCenter.score)!=null?t:0)<=e&&this.direction!==At.Back){console.debug(`[${this.constructor.name}] head visibility low.`);return}return this}validateVisibilityDiscrepency(e=.3){var t,r;if(Math.abs(((t=this.auxHeadCenter.score)!=null?t:0)-((r=this.auxAnkleCenter.score)!=null?r:0))>=e){console.debug(`[${this.constructor.name}] visibility discrepency too high.`);return}return this}validateVisibilityMean(e=.3){const t=["ear","shoulder","hip","knee","ankle"].map(s=>{var o;return(o=this.getKeypointByName(s).score)!=null?o:0}),r=Cy(t);if(r<=e){console.debug(`[${this.constructor.name}] visibility mean too low.`,r);return}return this}validateVisibilitySTD(e=.3){const t=["ear","shoulder","hip","knee","ankle"].map(s=>{var o;return(o=this.getKeypointByName(s).score)!=null?o:0}),r=EI(t);if(r>=e){console.debug(`[${this.constructor.name}] visibility std too high.`,r);return}return this}validateX(e,t,r=.3){if(this.getMin("x",r)<=e||this.getMax("x",r)>=t){console.debug(`[${this.constructor.name}] x out of frame.`);return}return this}validateY(e,t,r=.3){if(console.debug(`[${this.constructor.name}] ankle out of frame.`,this.auxAnkleCenter.y),this.getMin("y",r)<=e||this.getMax("y",r)>=t){console.debug(`[${this.constructor.name}] y out of frame.`);return}return this}validateToe(e){if(this.auxToeCenter.y>=e){console.debug(`[${this.constructor.name}] Toe out of frame.`);return}return this}}function zo(n,e,t){var s,o;if(e.includes("aux"))return new Wr(n,t).getAuxillaryPointByName(e);if(!e.includes("left")&&!e.includes("right")&&!e.includes("nose")){const i=zo(n,"".concat("left_",e),t),a=zo(n,"".concat("right_",e),t);return((s=i==null?void 0:i.score)!=null?s:0)>((o=a==null?void 0:a.score)!=null?o:0)?i:a}const r=Dr.getKeypointIndexByName(t);return n[r[e]]}function Ga(n,e,t){return e.map(r=>zo(n,r,t))}function ja(n,e){return n.map(t=>{const r=lt.fromObject(t);return e&&(r.z=0),r})}function kI(...n){return n.reduce((e,t)=>e.add(t),new lt)}function yo(n,e="mean"){const t=kI(...n).divide(n.length);let r;switch(e){case"mean":r=n.reduce((s,o)=>{var i;return s+((i=o==null?void 0:o.score)!=null?i:0)},0)/n.length;break;case"max":r=n.reduce((s,o)=>{var i,a;return s>((i=o==null?void 0:o.score)!=null?i:0)?s:(a=o==null?void 0:o.score)!=null?a:0},0);break;case"min":r=n.reduce((s,o)=>{var i,a;return s<((i=o==null?void 0:o.score)!=null?i:0)?s:(a=o==null?void 0:o.score)!=null?a:0},0);break}return t.score=r,t}function NI(n,e,t){const r=e.subtract(n),s=t.subtract(n);return r.angleTo(s,"deg")}function II(n,e,t){const{x:r,y:s}=n,{x:o,y:i}=e,{x:a,y:c}=t,u=t.distanceTo(e);return Math.abs((a-o)*(i-s)-(o-r)*(c-i))/u}class lt{constructor(e=0,t=0,r=0,s=1,o){ue(this,"x");ue(this,"y");ue(this,"z");ue(this,"score");ue(this,"name");ue(this,"timestamp");this.x=e!=null?e:0,this.y=t!=null?t:0,this.z=r!=null?r:0,this.score=s,this.name=o}static fromObject(e){const{x:t,y:r,z:s,score:o,name:i}=e;return new this(t,r,s,o,i)}static fromTensor(e,t,r){if(e.shape[0]!==3)throw new Error("Tensor is in a wrong shape.");const s=e.arraySync();return new this(s[0],s[1],s[2],t,r)}toArray(e=2){return[this.x,this.y,this.z].slice(0,e||3)}toTensor(){return Ze([this.x,this.y,this.z])}toAngles(){return{theta:Math.atan2(this.z,this.x),phi:Math.asin(this.y/this.length)}}get length(){return Math.hypot(this.x,this.y,this.z)}get unit(){return this.divide(this.length)}get min(){return Math.min(Math.min(this.x,this.y),this.z)}get max(){return Math.max(Math.max(this.x,this.y),this.z)}negative(){return new lt(-this.x,-this.y,-this.z,this.score,this.name)}add(e){var t;return new lt(this.x+e.x,this.y+e.y,this.z+((t=e==null?void 0:e.z)!=null?t:0),this.score,this.name)}subtract(e){var t;return new lt(this.x-e.x,this.y-e.y,this.z-((t=e==null?void 0:e.z)!=null?t:0),this.score,this.name)}multiply(e){return e instanceof lt?new lt(this.x*e.x,this.y*e.y,this.z*e.z,this.score,this.name):new lt(this.x*e,this.y*e,this.z*e,this.score,this.name)}divide(e){return e instanceof lt?new lt(this.x/e.x,this.y/e.y,this.z/e.z,this.score,this.name):new lt(this.x/e,this.y/e,this.z/e,this.score,this.name)}equals(e){return this.x===e.x&&this.y===e.y&&this.z===e.z}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e){return new lt(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x,this.score,this.name)}angleTo(e,t="deg"){const r=Math.acos(this.dot(e)/(this.length*e.length));if(t==="rad")return r;if(t==="deg")return r/Math.PI*180;throw new Error("Unrecognized type.")}distanceTo(e){return this.subtract(e).length}clone(){return new lt(this.x,this.y,this.z,this.score,this.name)}}class AV{constructor(e,t=5e3){ue(this,"name");ue(this,"window");ue(this,"history",[]);this.name=e,this.window=t}update(e,t=.8,r=.8){return(e==null?void 0:e.score)&&(e==null?void 0:e.score)>r&&(this.history.length>0&&(e=e.multiply(t).add(this.value.multiply(1-t))),e.timestamp=Date.now(),this.history.push(e)),this.filter(),this}updateByName(e){this.update(e.getKeypointByName(this.name))}filter(){const e=Date.now();this.history=this.history.filter(t=>{var r;return!(e-((r=t==null?void 0:t.timestamp)!=null?r:0)>=this.window)})}get value(){return yo(this.history)}draw(e){e.save(),e.globalAlpha=1,e.lineWidth=8,e.strokeStyle="red";const t=Date.now(),r=this.history.slice(),s=r.pop();e.beginPath(),s&&e.moveTo(s.x,s.y),r.reverse().forEach(o=>{o!=null&&o.timestamp?e.globalAlpha=(1-Math.abs(t-(o==null?void 0:o.timestamp))/this.window)*.5+.5:e.globalAlpha=1,e.lineTo(o.x,o.y)}),e.stroke(),e.closePath(),e.restore()}}function DV(n,e,t){const r=e.subtract(n),s=t.subtract(n),o=r.cross(s),i=-(o.x*n.x+o.y*n.y+o.z*n.z);return[o.x,o.y,o.z,i]}function PV(n,e){const t=n.keypoints.map(s=>s.subtract(e));return new Wr(t,n.modelName,n.userHeight)}class _I{constructor(e,t=!1){ue(this,"displaySize");ue(this,"poseDetector");ue(this,"singleImage");ue(this,"ready");ue(this,"modelName");this.displaySize={width:e.width,height:e.height},this.ready=!1,this.singleImage=t}async load(e,t){var a,c,u,l,h,p,d;let r,s;if(this.modelName=e,e===Ir.BlazePose){r=He.BlazePose;const m=t;s={runtime:"tfjs",enableSmoothing:(a=m==null?void 0:m.enableSmoothing)!=null?a:!this.singleImage,modelType:(c=m==null?void 0:m.modelType)!=null?c:"full",detectorModelUrl:(u=m==null?void 0:m.detectorModelUrl)!=null?u:"https://alg.halftime.fit/model/detecter/model.json",landmarkModelUrl:(l=m==null?void 0:m.landmarkModelUrl)!=null?l:"https://alg.halftime.fit/model/landmark/model.json"}}else if(e===Ir.MoveNet){r=He.MoveNet;const m=t;s={modelType:(h=m==null?void 0:m.modelType)!=null?h:CI.modelType.SINGLEPOSE_THUNDER,enableSmoothing:(p=m==null?void 0:m.enableSmoothing)!=null?p:!this.singleImage,minPoseScore:.3,modelUrl:(d=m==null?void 0:m.modelUrl)!=null?d:"https://alg.halftime.fit/model/movenet/thunder/model.json"}}else if(e===Ir.PoseNet)r=He.PoseNet,s={architecture:"MobileNetV1",outputStride:16,multiplier:.75,modelUrl:"https://alg.halftime.fit/model/posenet/model.json"};else throw new Error(`[${this.constructor.name}] Unrecognized model name.`);const[o,i]=await cn(wI(r,s));if(o||i===void 0)throw new Error(`[${this.constructor.name}] Creation failed.`);return this.poseDetector=i,console.log(`[${this.constructor.name}] Created.
`,this.poseDetector),this.ready=!0,this.ready}async detectSinglePose(e){if(!this.ready||this.poseDetector===void 0)throw new Error(`[${this.constructor.name}] Detector not ready.`);const t=we(()=>{const o={data:new Uint8Array(e.data),width:e.width,height:e.height},i=Cc(o,4);return TI(i,this.displaySize)}),[r,s]=await cn(this.detect(t));if(!s)throw new Error("Detection failed");return t.dispose(),s}async detect(e){let t;this.singleImage?t={flipHorizontal:!1}:t={flipHorizontal:!0},this.modelName===Ir.PoseNet&&(t={flipHorizontal:!1,scoreThreshold:.5});const r=Date.now(),[s,o]=await cn(this.poseDetector.estimatePoses(e,t,r));return s||o===void 0?(console.warn(`[${this.constructor.name}] Detection failed.`),[]):o}async detectProcessed(e){const[t,r]=await cn(this.detect(e));if(!r)throw new Error("No pose detected");const s=r[0],o=ja(s.keypoints,!0),i=new Wr(o,this.modelName);let a=i;if(s!=null&&s.keypoints3D){const c=ja(s==null?void 0:s.keypoints3D,!1);a=new Wr(c,this.modelName)}return[i,a]}dispose(){var e;(e=this.poseDetector)==null||e.dispose()}}const RI="#ff6f00",OI="#0fbea0",AI="#28b2f6",DI="#dedede";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zn={},oo={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function PI(n,e){Zn[n]=e}function en(n,e){if(!(n in Zn)||e!=null){const r=LI(n,e);if(r!==null)Zn[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=Zn[n];return t==null||t.isContextLost()?(delete Zn[n],en(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Zn[n])}function FI(n){if(typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function LI(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e==null?FI(n):e;return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Zn[n]},!1),M().getBool("SOFTWARE_WEBGL_ENABLED")&&(oo.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",oo)||t.getContext("experimental-webgl",oo):t.getContext("webgl2",oo)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ds;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Ds||(Ds={}));var St;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(St||(St={}));var Ke;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ke||(Ke={}));function zs(n,e){return[e,n]}function MI(n,e){return n*e}function io(n){const e=G(n),t=Math.ceil(e/4);return Zi(t)}function Qr(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function BI(n,e){const[t,r]=Qr(n,e);return t*r*4}function Kc(n,e){const t=n;let r,s,o,i,a,c,u,l,h,p;return M().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,o=t.RGBA16F,i=t.RGBA32F,a=t.RED,u=4,l=1,h=t.HALF_FLOAT,p=t.FLOAT,c=t.RGBA8):(r=n.RGBA,s=n.RGBA,o=n.RGBA,i=t.RGBA,a=n.RGBA,u=4,l=4,h=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,c=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:c,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:h,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q(n,e){const t=e();return M().getBool("DEBUG")&&VI(n),t}function VI(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+GI(n,e))}const UI=596e-10,zI=65504;function WI(n){return!!(M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||UI<Math.abs(n)&&Math.abs(n)<zI)}function GI(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function ao(n,e){return kn(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function jI(n,e){const t=kn(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Q(n,()=>n.shaderSource(t,e)),Q(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function HI(n,e){const t=kn(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Q(n,()=>n.shaderSource(t,e)),Q(n,()=>n.compileShader(t)),M().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw Sy(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const KI=/ERROR: [0-9]+:([0-9]+):/g;function Sy(n,e){const t=KI.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),o=s.length.toString().length+2,i=s.map((h,p)=>_r((p+1).toString(),o)+h);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const c=i.slice(0,r-1),u=i.slice(r-1,r),l=i.slice(r);console.log(c.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${_r(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function qI(n){return kn(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function XI(n,e){if(Q(n,()=>n.linkProgram(e)),!M().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Gi(n,e){if(Q(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function YI(n,e){const t=kn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Q(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function QI(n,e){const t=kn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Q(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Q(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function ZI(n){return kn(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function JI(n,e){const t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function e_(n){return kn(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Xl(n,e,t,r,s,o,i){const a=n.getAttribLocation(e,t);return a===-1?!1:(Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Q(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,o,i)),Q(n,()=>n.enableVertexAttribArray(a)),!0)}function t_(n,e,t){i_(n,t),Q(n,()=>n.activeTexture(n.TEXTURE0+t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function n_(n,e,t){return kn(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function r_(n,e,t){return n.getUniformLocation(e,t)}function s_(n,e,t,r){Q(n,()=>t_(n,e,r)),Q(n,()=>n.uniform1i(t,r))}function ji(n,e,t){Q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Yl(n,e){Q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function co(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+o_(n,e))}function o_(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function kn(n,e,t){const r=Q(n,()=>e());if(r==null)throw new Error(t);return r}function i_(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Gr(n,e=2){return G(n.slice(0,n.length-e))}function jr(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Hi(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Gr(n),...jr(n)]),e}function a_(n,e=!1){let t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=M().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&M().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,c)=>c>=n.length-2?ac(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=zn(n).newShape);let s=G(n),o=null;n.length<=1&&s<=t?o=[1,s]:n.length===2&&n[0]<=t&&n[1]<=t?o=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?o=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?o=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?o=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(o=[n[0],n[1]*n[2]*n[3]]);const i=o!=null&&Math.max(...o)>r&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=Gr(n);let c=2,u=2;n.length&&([c,u]=jr(n)),s=a*(c/2)*(u/2),o=Zi(s).map(l=>l*2)}else o=Zi(s);return o}function uo(n){return n%2===0}function Wo(n,e){if(n=n.slice(-2),e=e.slice(-2),Me(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],r=e.slice(-1)[0];if(t===r||uo(t)&&uo(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&uo(n[0])&&uo(e[0])}let Ki,qi;function c_(n){if(Ki==null){const e=en(n);Ki=e.getParameter(e.MAX_TEXTURE_SIZE)}return Ki}function u_(n){if(qi==null){const e=en(n);qi=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qi)}function l_(n){if(n===0)return 0;let e;const t=en(n);return Ut(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Ut(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Ut(n,e){return n.getExtension(e)!=null}function Ql(n){try{if(en(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function h_(n){if(n===0)return!1;const e=en(n);if(n===1){if(!Ut(e,"OES_texture_float"))return!1}else if(!Ut(e,"EXT_color_buffer_float"))return!1;return Ha(e)}function p_(n){if(n===0)return!1;const e=en(n);if(n===1){if(!Ut(e,"OES_texture_float")||!Ut(e,"WEBGL_color_buffer_float"))return!1}else{if(Ut(e,"EXT_color_buffer_float"))return Ha(e);const r="EXT_color_buffer_half_float";if(Ut(e,r)){const s=e.getExtension(r);return d_(e,s)}return!1}return Ha(e)}function Ha(n){const e=Kc(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),i}function d_(n,e){const t=Kc(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const s=1,o=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,s,o,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}function f_(n){return n!==2?!1:en(n).fenceSync!=null}function Ws(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&k(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z=M();Z.registerFlag("HAS_WEBGL",()=>Z.getNumber("WEBGL_VERSION")>0);Z.registerFlag("WEBGL_VERSION",()=>Ql(2)?2:Ql(1)?1:0);Z.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Z.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Z.get("WEBGL_VERSION")===2);Z.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Z.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Z.registerFlag("WEBGL_PACK",()=>Z.getBool("HAS_WEBGL"));Z.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_PACK_CLIP",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_PACK_REDUCE",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_LAZILY_UNPACK",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_CONV_IM2COL",()=>Z.getBool("WEBGL_PACK"));Z.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>c_(Z.getNumber("WEBGL_VERSION")));Z.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>u_(Z.getNumber("WEBGL_VERSION")));Z.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Z.getNumber("WEBGL_VERSION");return n===0?0:l_(n)});Z.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Z.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ff());Z.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>h_(Z.getNumber("WEBGL_VERSION")));Z.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Z.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Z.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Z.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>p_(Z.getNumber("WEBGL_VERSION")));Z.registerFlag("WEBGL_FENCE_API_ENABLED",()=>f_(Z.getNumber("WEBGL_VERSION")));Z.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Z.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Z.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Z.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Ff()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Z.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Z.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Z.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Z.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Z.registerFlag("WEBGL_EXP_CONV",()=>!1);Z.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Z.getBool("IS_TEST"));Z.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Z.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Z.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ct(){let n,e,t,r,s,o,i,a,c,u;return M().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=M().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:c,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr(n,e,t="index"){const r=qe(e);return r.map((s,o)=>{const i=`int ${n[o]} = ${t} / ${s}`,a=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`;return`${i}; ${a};`}).join("")}function li(n,e,t="index"){const r=qe(e);return r.map((s,o)=>{const i=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,a=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function m_(n,e){const t=n.length,r=n.map(o=>`${e}[${o}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let o=t-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function g_(n,e,t="index"){const r=n.map((o,i)=>i),s=m_(r,e);return s.map((o,i)=>{const a=`int ${n[i]} = ${t} / ${s[i]}`,c=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${s[i]}`:`index -= ${n[i]} * ${s[i]}`;return`${a}; ${c};`}).join("")}function qc(n){const e=qe(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Xc(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Ty=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:$y}=jE;function y_(n,e,t){const r=[];if(n.forEach(d=>{const m=G(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${m>1?`[${m}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:g}=Yc(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),o=n.map(d=>x_(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=ct(),c=w_(a);let u,l,h=T_(a);return e.isPacked?(u=b_(e.logicalShape,i,t.enableShapeUniforms),l=S_(a)):(u=v_(e.logicalShape,i,t.enableShapeUniforms),l=C_(a)),t.packedInputs&&(h+=N_),[h,c,l,s,u,o,t.userCode].join(`
`)}function Zr(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return V_(n,e);case 1:return z_(n,e);case 2:return G_(n,e);case 3:return H_(n,e);case 4:return q_(n,e);case 5:return X_(n);case 6:return Y_(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Ey(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return B_(n);case 1:return U_(n,e);case 2:return W_(n,e);case 3:return j_(n,e);default:return K_(n,e)}}function x_(n,e,t=!1,r){let s="";t?s+=Ey(n,r):s+=Zr(n,r);const o=n.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(t?s+=Q_(n,e):s+=Z_(n,e)),s}function b_(n,e,t){switch(n.length){case 0:return ky();case 1:return I_(n,e,t);case 2:return L_(n,e,t);case 3:return R_(n,e,t);default:return A_(n,e,t)}}function v_(n,e,t){switch(n.length){case 0:return ky();case 1:return __(n,e,t);case 2:return M_(n,e,t);case 3:return O_(n,e,t);case 4:return D_(n,e,t);case 5:return P_(n,e);case 6:return F_(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function w_(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function C_(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function S_(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function T_(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${$_}
    ${E_}
    ${k_}
  `}const $_=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,E_=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,k_=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,N_=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function ky(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function I_(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function __(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function R_(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),o=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function O_(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${li(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=yr(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function A_(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),o=s*Math.ceil(n[n.length-2]/2);let i=o,a="",c="b, r, c";for(let u=2;u<n.length-1;u++)i*=n[n.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,c=`b${u}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${c});
    }
  `}function D_(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${li(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=yr(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function P_(n,e){const t=yr(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function F_(n,e){const t=yr(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function L_(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Me(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function M_(n,e,t){return Me(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function xr(n){return`offset${n}`}function B_(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ct();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function V_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,o]=n.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=xr(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;const[a,c]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${c}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function U_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,o=ct();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function z_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Jr(n)}
      }
    `;const s=n.shapeInfo.texShape,o=s[0],i=s[1];if(i===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=xr(t);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function W_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],c=ct();if(o!=null&&Me(t,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${c.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${c.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `}function G_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(o!=null&&Me(t,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const p=o[0],d=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:a}=zn(t),c=i;if(c.length<t.length){const p=es(n,c),d=["row","col"];return`
      ${Zr(p,e)}
      float ${s}(int row, int col) {
        return ${s}(${ts(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Jr(n)}
      }
    `;const u=o[0],l=o[1],h=xr(r);return l===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${l}, index);
    return sampleTexture(${r}, uv);
  }
`}function j_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const p=t.slice(1),d=[1,2],m=es(n,p),g=["b","row","col"];return`
        ${Ey(m,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${ts(g,d)});
        }
      `}const a=ct();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const c=i[0],u=i[1],l=Math.ceil(t[2]/2),h=l*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${u}, ${h}, ${l}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function H_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[1]*t[2],i=t[2],{newShape:a,keptDims:c}=zn(t),u=a;if(u.length<t.length){const g=es(n,u),y=["row","col","depth"];return`
        ${Zr(g,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${ts(y,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Jr(n)}
      }
    `;const l=n.shapeInfo.texShape,h=l[0],p=l[1],d=n.shapeInfo.flatOffset;if(p===o&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const m=xr(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${h}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function K_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=ct();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=c[0],l=c[1],h=Math.ceil(o[i-1]/2);let p=h*Math.ceil(o[i-2]/2),d="int b, int row, int col",m=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<i-1;g++)d=`int b${g}, `+d,p*=o[i-g-1],m=`b${g} * ${p} + `+m;return`
    vec4 ${r}(${d}) {
      int index = ${m};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${u});
      return ${s.texture2D}(${t}, uv);
    }
  `}function q_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[3],i=t[2]*o,a=t[1]*i,{newShape:c,keptDims:u}=zn(t);if(c.length<t.length){const w=es(n,c),S=["row","col","depth","depth2"];return`
      ${Zr(w,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${ts(S,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Jr(n)}
      }
    `;const l=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],d=h[1],m=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&l==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===o&&l==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;const x=xr(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${d}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function X_(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],o=e[3]*s,i=e[2]*o,a=e[1]*i,{newShape:c,keptDims:u}=zn(e);if(c.length<e.length){const g=es(n,c),y=["row","col","depth","depth2","depth3"];return`
      ${Zr(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${ts(y,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${s})) +
          depth3;
        ${Jr(n)}
      }
    `;const l=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],d=h[1];if(d===a&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===s&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=xr(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${s} + depth3 + ${m};
      vec2 uv = uvFromFlat(${p}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Y_(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:o}=zn(e);if(s.length<e.length){const y=es(n,s),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${Zr(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${ts(x,o)});
      }
    `}const i=e[5],a=e[4]*i,c=e[3]*a,u=e[2]*c,l=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${u}, ${c}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Jr(n)}
      }
    `;const h=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],m=p[1];if(m===l&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${c}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===i&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=xr(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${u} + depth * ${c} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${d}, ${m}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Jr(n){const e=n.name,t=G(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Q_(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=$y(n.shapeInfo.logicalShape,e.logicalShape),c=ke(i),u=i-o;let l;const h=["x","y","z","w","u","v"];o===0?l="":i<2&&a.length>=1?l="coords = 0;":l=a.map(w=>`coords.${h[w+u]} = 0;`).join(`
`);let p="";i<2&&o>0?p="coords":p=n.shapeInfo.logicalShape.map((w,S)=>`coords.${h[S+u]}`).join(", ");let d="return outputValue;";const g=G(n.shapeInfo.logicalShape)===1,x=G(e.logicalShape)===1;if(o===1&&!g&&!x)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!x)i===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){const w=o-2,S=o-1;a.indexOf(w)>-1&&a.indexOf(S)>-1?d="return vec4(outputValue.x);":a.indexOf(w)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(S)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${c} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${r}(${p});
      ${d}
    }
  `}function Z_(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===c&&n.shapeInfo.flatOffset==null&&Me(i,o))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=ke(c),l=$y(n.shapeInfo.logicalShape,e.logicalShape),h=c-a;let p;const d=["x","y","z","w","u","v"];a===0?p="":c<2&&l.length>=1?p="coords = 0;":p=l.map(g=>`coords.${d[g+h]} = 0;`).join(`
`);let m="";return c<2&&a>0?m="coords":m=n.shapeInfo.logicalShape.map((g,y)=>`coords.${d[y+h]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${p}
      return get${r}(${m});
    }
  `}function ke(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Yc(n,e,t){const{newShape:r,keptDims:s}=zn(e),o=e.length,i=n&&o===3&&e[0]===1,a=i?e.slice(1):r,c=!n&&o>1&&!Me(e,t)&&r.length<o||i;return{useSqueezeShape:c,uniformShape:c?a:e,keptDims:s}}function es(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function ts(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(n,e,t,r){const s=t.map((l,h)=>{const p={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(p.flatOffset=l.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:p}}),o=s.map(l=>l.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=y_(s,i,e),c=HI(n.gl,a),u=n.createProgram(c);return M().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:c,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:c,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},Ny(n,e,u))}function Ny(n,e,t){const r={},s={},o={},i=[];let a,c,u,l=null,h=null;h=n.getUniformLocation(t,"NAN",!1),M().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const p=!1;for(let d=0;d<e.variableNames.length;d++){const m=e.variableNames[d];r[m]=n.getUniformLocation(t,m,p),r[`offset${m}`]=n.getUniformLocation(t,`offset${m}`,p),e.enableShapeUniforms&&(s[`${m}Shape`]=n.getUniformLocation(t,`${m}Shape`,p),o[`${m}TexShape`]=n.getUniformLocation(t,`${m}TexShape`,p))}return e.enableShapeUniforms&&(a=n.getUniformLocation(t,"outShape",p),u=n.getUniformLocation(t,"outShapeStrides",p),c=n.getUniformLocation(t,"outTexShape",p)),e.customUniforms&&e.customUniforms.forEach((d,m)=>{i[m]=n.getUniformLocation(t,d.name,p)}),{uniformLocations:r,customUniformLocations:i,infLoc:l,nanLoc:h,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:c}}function Zl(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,o=e[r],i=o.shape;if(!Me(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(t.isUniform&&o.isUniform)return;const a=t.texShape,c=o.isUniform?null:o.texData.texShape;if(!Me(a,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${c} must match`)})}function eR(n,e,t,r,s){e.program.enableShapeUniforms||(Zl(e.inShapeInfos,t),Zl([e.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(e.webGLProgram),M().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((c,u)=>{const l=e.program.variableNames[u],h=e.uniformLocations[l],p=e.uniformLocations[`offset${l}`],d=e.inShapesLocations[`${l}Shape`],m=e.inTexShapesLocations[`${l}TexShape`];if(d){const{uniformShape:g}=Yc(e.program.packedInputs,c.shape,c.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(d,new Int32Array(g));break;case 2:n.gl.uniform2iv(d,new Int32Array(g));break;case 3:n.gl.uniform3iv(d,new Int32Array(g));break;case 4:n.gl.uniform4iv(d,new Int32Array(g));break}}if(m&&n.gl.uniform2i(m,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if(G(c.shape)<2)n.gl.uniform1f(h,c.uniformValues[0]);else{let g=c.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(h,g)}return}c.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,h,u)}});const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const c=qe(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(c));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s&&e.program.customUniforms.forEach((c,u)=>{const l=e.customUniformLocations[u],h=s[u];if(c.type==="float")n.gl.uniform1fv(l,h);else if(c.type==="vec2")n.gl.uniform2fv(l,h);else if(c.type==="vec3")n.gl.uniform3fv(l,h);else if(c.type==="vec4")n.gl.uniform4fv(l,h);else if(c.type==="int")n.gl.uniform1iv(l,h);else if(c.type==="ivec2")n.gl.uniform2iv(l,h);else if(c.type==="ivec3")n.gl.uniform3iv(l,h);else if(c.type==="ivec4")n.gl.uniform4iv(l,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}),n.executeProgram()}function tR(n,e,t){let r="";e.concat(t).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const c=i.texData.texShape,{useSqueezeShape:u,uniformShape:l,keptDims:h}=Yc(n.packedInputs,i.shape,c);let p="",d="",m="";if(l.length===1&&n.packedInputs){const N=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];p=`${N[0]>1}_${N[1]>1}`}else if(l.length===2&&!n.packedInputs)d=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!n.packedInputs){const N=qe(l);m=`${N[0]===c[1]}_${N[N.length-1]===c[1]}`}const g=i.shape.length,y=l.length===2&&Me(i.shape,c),x=G(i.shape)===1,w=Do(i.shape,t.shape),S=!n.packedInputs&&g===t.shape.length&&Me(c,t.texData.texShape),$=n.packedInputs||l.length>2?"":`${c[0]>1}_${c[1]>1}`;r+=`${g}_${S}_${u?h:""}_${l.length}_${x}_${w}_${y}_${p}_${d}_${m}_${$}_${a}`}else{const c=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${c}_${a}`}});const s=n.userCode;let o=n.constructor.name;return o+="_"+r+"_"+s+`${M().getNumber("WEBGL_VERSION")}`,o}function ut(n){return M().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nR{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ds.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ct();this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?li(["r","c","d"],e):yr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rR{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ds.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ct();this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?li(["r","c","d"],e):yr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sR{constructor(e){this.variableNames=["A"],this.outTexUsage=St.DOWNLOAD;const t=ct();this.outputShape=e,this.userCode=`
      ${Ty}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oR{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=St.DOWNLOAD;const t=ct();this.outputShape=e,this.userCode=`
      ${Ty}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iR{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ct();this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Xc():qc(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aR{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ct();this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length);let s="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const c=i*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Xc():qc(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(n){const e=ct(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return jI(n,t)}function uR(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return YI(n,e)}function lR(n){const e=new Uint16Array([0,1,2,2,1,3]);return QI(n,e)}function Gs(n,e,t,r,s,o){JI(e,t);const i=ZI(n),a=n.TEXTURE_2D;return Q(n,()=>n.bindTexture(a,i)),Q(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Q(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Q(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Q(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),M().getNumber("WEBGL_VERSION")===1?Q(n,()=>n.texImage2D(a,0,r,e,t,0,s,o,null)):Q(n,()=>n.texStorage2D(a,1,r,e,t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function Iy(n){return n.internalFormatFloat}function hR(n,e,t,r){const[s,o]=zs(e,t);return Gs(n,s,o,Iy(r),r.textureFormatFloat,n.FLOAT)}function _y(n){return n.internalFormatHalfFloat}function pR(n,e,t,r){const[s,o]=zs(e,t);return Gs(n,s,o,_y(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Ry(n){return n.downloadTextureFormat}function dR(n,e,t,r){const[s,o]=zs(e,t);return Gs(n,s,o,Ry(r),n.RGBA,n.UNSIGNED_BYTE)}function Oy(n){return n.internalFormatPackedFloat}function fR(n,e,t,r){const[s,o]=Qr(e,t);return Gs(n,s,o,Oy(r),n.RGBA,n.FLOAT)}function Ay(n){return n.internalFormatPackedHalfFloat}function mR(n,e,t,r){const[s,o]=Qr(e,t);return Gs(n,s,o,Ay(r),n.RGBA,r.textureTypeHalfFloat)}function gR(n,e,t){return Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Xl(n,e,"clipSpacePos",t,3,20,0)&&Xl(n,e,"uv",t,2,20,12)}function yR(n,e,t,r,s,o){Q(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,a,c;s instanceof Uint8Array?(i=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,c=n.RGBA):(i=new Float32Array(t*r*4),a=n.FLOAT,c=o.internalFormatPackedFloat),i.set(s),M().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,i)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,t,r,0,n.RGBA,a,i)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function xR(n,e,t){Q(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?M().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):M().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function bR(n,e,t,r){const s=n.createBuffer();Q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=4*4*e*t;return Q(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Q(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function vR(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function wR(n,e,t,r){const[s,o]=zs(e,t),i=4,a=new Uint8Array(MI(e*t,i));return Q(n,()=>n.readPixels(0,0,s,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function CR(n,e,t,r,s,o,i,a){const c=n,u=new Float32Array(BI(o,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,e),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,u),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),u}function SR(n,e,t){const r=new Float32Array(e*t*4);return Q(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xi{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=M().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,PI(t,e)):this.gl=en(t);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),M().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=ao(this.gl,o),Ut(this.gl,i))this.textureHalfFloatExtension=ao(this.gl,i);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Ut(this.gl,s))this.colorBufferHalfFloatExtension=ao(this.gl,s);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Ut(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Ut(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=uR(this.gl),this.indexBuffer=lR(this.gl),this.framebuffer=e_(this.gl),this.textureConfig=Kc(this.gl,this.textureHalfFloatExtension)}get debug(){return M().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Q(e,()=>e.finish()),Q(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Q(e,()=>e.deleteFramebuffer(this.framebuffer)),Q(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Q(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Q(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),hR(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),pR(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),dR(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),xR(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),yR(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),mR(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),fR(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Yl(this.gl,this.framebuffer),this.outputTexture=null),Q(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>wR(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,o,i){return CR(this.gl,e,t,r,s,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return vR(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=bR(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(M().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},t=o}else M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>SR(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=cR(t));const r=qI(t);return Q(t,()=>t.attachShader(r,this.vertexShader)),Q(t,()=>t.attachShader(r,e)),XI(t,r),this.debug&&Gi(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=gR(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&Q(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Gi(this.gl,this.program),Q(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?n_(this.gl,e,t):r_(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Q(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),s_(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,o]=Qr(t,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Gi(this.gl,this.program),co(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),Q(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Q(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ao(this.gl,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await zu(()=>this.disposed||this.isQueryAvailable(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=TR(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in M().platform&&(r=M().platform.setTimeoutCustom.bind(M().platform)),zu(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),ji(this.gl,e,this.framebuffer),this.debug&&co(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(ji(this.gl,this.outputTexture,this.framebuffer),this.debug&&co(this.gl)):Yl(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;ji(s,e,this.framebuffer),this.debug&&co(s),this.outputTexture=e,Q(s,()=>s.viewport(0,0,t,r)),Q(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),Q(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function TR(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kt(n){return(e,t,r,s,o)=>{const i=me(e,t),a=i.length,c=qe(i),u=G(i),l=Cn(o,u),h=e.length,p=t.length,d=qe(e),m=qe(t),g=Do(e,i),y=Do(t,i);if(g.length+y.length===0)for(let x=0;x<l.length;++x)l[x]=n(r[x%r.length],s[x%s.length]);else for(let x=0;x<l.length;++x){const w=cc(x,a,c),S=w.slice(-h);g.forEach(O=>S[O]=0);const $=na(S,h,d),N=w.slice(-p);y.forEach(O=>N[O]=0);const _=na(N,p,m);l[x]=n(r[$],s[_])}return[l,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(n,e,t,r){if(r==="int32"){const s=Int32Array.from(n);return[e,"int32",s]}if(r==="bool"){const s=Qo([0],t),[o,i]=kt((a,c)=>a!==c?1:0)(e,[],n,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR=kt((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NR(n,e,t,r,s){const o=G(r),i=Mn(s,t);for(let a=0;a<n.length;a++){const c=n[a];if(c<0)throw new Error("Input x must be non-negative!");c>=s||(o>0?i[c]+=e[a]:i[c]+=1)}return i}function IR(n,e,t,r=!1){const s=n.shape[0],o=n.shape[1],i=Le([s,t],e.dtype);for(let a=0;a<s;a++)for(let c=0;c<o;c++){const u=n.get(a,c);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(r?i.set(1,a,u):e.size>0?i.set(i.get(a,u)+e.get(a,c),a,u):i.set(i.get(a,u)+1,a,u))}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(n){return(e,t,r)=>{const s=Cn(t,e.length);for(let o=0;o<e.length;++o)s[o]=n(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _R=jn(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n,e,t,r){const s=pt(t,G(e));if(r&&t!=="string"){let o=0;n.forEach(i=>{const a=G(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a=t==="string"?Rs(i.vals):i.vals;let c=0;for(let u=0;u<i.shape[0];++u){const l=u*e[1]+o;for(let h=0;h<i.shape[1];++h)s[l+h]=a[c++]}o+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OR=kt((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AR=jn(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DR=jn(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PR=jn(n=>Math.floor(n));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FR(n,e,t,r,s,o,i,a,c){const u=Le([r,o],t);for(let l=0;l<r;l++){const h=[];let p=0;for(let d=0;d<s;d++){const m=n[l*s+d];p+=m*i[d],h.push(m)}if(p<0||p>=c/o)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<o;d++)u.values[l*o+d]=e.get(...e.indexToLoc(p*o+d))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(n,e,t){const r=Le(t,n.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),a=i[0],c=i[2],u=e.locToIndex([a,c]);i[2]=e.values[u];const l=n.locToIndex(i);0<=l&&l<n.values.length&&(r.values[s]=n.values[l])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MR=kt((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=kt((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VR=kt((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UR=kt((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zR(n,e,t){const r=(e-n)/(t-1),s=Mn(t,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WR=jn(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(n,e,t,r){const s=Cn(r,G(t));for(let o=0;o<s.length;++o){const i=o*e;let a=n[i];for(let c=0;c<e;++c){const u=n[i+c];(Number.isNaN(u)||u>a)&&(a=u)}s[o]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jR=kt((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HR=kt((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dy=kt((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KR(n,e,t){const r=qr(-1,t);return Dy([],e,r,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qR=kt((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XR(n,e,t,r,s){const o=e.length,i=G(e),a=qe(e),c=qe(s),u=Cn(t,G(s));for(let l=0;l<i;++l){const h=cc(l,o,a),p=new Array(h.length);for(let m=0;m<p.length;m++)p[m]=h[r[m]];const d=na(p,o,c);u[d]=n[l]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(n,e,t,r){const[s,o]=fn(n,r),i=pn(e,"int32"),a=Mn(G(s),i),c=G(o);for(let u=0;u<a.length;++u){const l=u*c;let h=1;for(let p=0;p<c;++p)h*=t[l+p];a[u]=h}return{outVals:a,outShape:s,outDtype:i}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QR(n,e,t){n.forEach((r,s)=>{if(r<0||r>=t){const o=cc(s,e.length,qe(e)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${t})`)}})}function ZR(n,e){for(let t=0;t<n.length;++t){const r=n[t],s=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}function JR(n,e,t,r){const s=[];let o=0;const i=e.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);ZR(t,r);let c=1;for(let u=0;u<e.length-1;++u){c*=e[u];const l=e[u+1];for(let h=1;h<c+1;++h)a[u].push(h*l)}for(let u=0;u<n.length;++u){let l=n[u],h=n[u]+1;for(let p=0;p<t.length;++p){const d=t[p],m=p+e.length-1;if(m>=0){const g=a[m],y=g[g.length-1]-d[l];for(let x=l;x<h;++x)a[m].push(d[x+1]+y)}l=d[l],h=d[h]}h!==l&&(s.push([l,h]),o+=h-l)}return{outSplits:a,valueSlices:s,numValues:o}}function eO(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,s=pt("int32",r);e.push(s),n[t].forEach((o,i)=>s[i]=o)}return e}function Jl(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function tO(n,e,t,r,s,o){const i=Jl(e,2)[1],a=Jl(o,2)[1];let c=0;for(const u of t)for(let l=u[0];l<u[1];++l){for(let h=0;h<r;++h)s[c*a+h]=n[l*i+h];++c}}function nO(n,e,t,r,s){const o=e.slice();o[0]=s;const i=pt(t,G(o)),a=n.length,c=a===0?0:a/e[0];return tO(n,e,r,c,i,o),[i,o]}function rO(n,e,t,r,s,o,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const c=e[0][0]-1;if(QR(o,i,c),r.length===0)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:l,valueSlices:h,numValues:p}=JR(o,i,n,u),d=eO(l),m=nO(t,r,s,h,p);return[d,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ot=Zt;class Go{constructor(e,t,r,s,o,i,a,c,u,l){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=c,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=bg(l),this.raggedRank=vg(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ot.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ot.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ot.VALUE_ROWIDS:return Go.getMaxWidthValueRowID(t);case Ot.ROW_SPLITS:return Go.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ot[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let s=0;s<t-1;++s){const o=e[s+1]-e[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,s=e[0],o=0;for(let i=1;i<t;++i){const a=e[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(t-r,o)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return th(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;wg(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=xg(this.raggedRank,s,t);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,t,r){const s=Math.min(e,r),o=[];let i=0;for(let a=0;a<s;++a,i+=t)o.push(i);for(let a=s;a<e;++a)o.push(-1);return k(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,r,s){const o=e.length,i=[];for(let a=0;a<o-1;++a){const c=e[a+1]-e[a];let u=Math.min(s,c),l=t[a];l===-1&&(u=0);for(let h=0;h<u;++h)i.push(l),l+=r;for(let h=0;h<c-u;++h)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,r,s){const o=e.length,i=[];if(o===0)return[];let a=0,c=e[0];if(c>=t.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${t.length}`);let u=t[c];i.push(u);for(let l=1;l<o;++l){const h=e[l];if(h===c)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,c=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}i.push(u)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,r,s){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Ot.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,r,s);case Ot.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,r,s);default:throw new Error(`Unsupported partition type: ${Ot[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Ot.FIRST_DIM_SIZE:return e[0];case Ot.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ot.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ot[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let c=s.length-2;c>=0;--c)s[c]=s[c+1]*r[c+1];const o=th(r,!1),i=pt(this.valuesDType,G(o));if(s[0]*r[0]>0){let c=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)c=this.calculateOutputIndex(u-1,c,s[u],r[u]);this.setOutput(this.raggedRank,c,i,o)}return[o,i]}setOutput(e,t,r,s){if(r.length===0)return;const o=this.values,i=r;let a=s.slice();a=a.slice(e+1);const c=G(a),u=t.length;let l=this.defaultValue;if(l.length!==c&&l.length!==1){const m=this.defaultValueShape;we(()=>{const g=V(l,m);l=Cs(g,a).dataSync()})}let h=0,p=0,d=0;for(let m=0;m<=u;++m){let g=m<u?t[m]:-1;if(g===d){++d;continue}if(p<d){const y=o.subarray(h*c),x=i.subarray(p*c),w=(d-p)*c;eh(x,y,w)}if(m>=u){const y=r.length;g=Math.floor(y/c)}if(g>d)if(this.defaultValue.length===1)i.subarray(d*c,g*c).fill(this.defaultValue[0]),d=g;else for(;g>d;){const y=i.slice(d*c);eh(y,l,c),++d}g<0?(h=m+1,p=d):(h=m,p=d,d=p+1)}}}function eh(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function th(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function sO(n,e,t,r,s,o,i,a,c,u){return new Go(n,e,t,r,s,o,i,a,c,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(n,e,t,r){const s=n===e,o=n<e&&t<0,i=e<n&&t>1;if(s||o||i)return Mn(0,r);const a=Math.abs(Math.ceil((e-n)/t)),c=Mn(a,r);e<n&&t===1&&(t=-1),c[0]=n;for(let u=1;u<c.length;u++)c[u]=c[u-1]+t;return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iO=jn(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aO(n,e,t,r,s,o,i,a,c,u){const l=[r/s,s],h=n.values,p=e.values;if(r===0)return Le(t,e.dtype);const d=Le(l,e.dtype);typeof c=="string"||typeof c=="number"?d.values.fill(c):typeof c=="boolean"&&d.values.fill(+c);for(let m=0;m<o;m++){const g=[];let y=0;for(let x=0;x<i;x++){const w=h[m*i+x];g.push(w),y+=w*a[x]}if(y<0||y>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let x=0;x<s;x++)u?d.values[y*s+x]+=p[m*s+x]:d.values[y*s+x]=e.rank===0?p[0]:p[m*s+x]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cO=jn(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(n,e,t,r,s){const o=Tc(r,e,t),i=G(t),a=qe(r);if(o){const h=$c(e,a);return s==="string"?n.slice(h,h+i):n.subarray(h,h+i)}const c=s==="string"?Rs(n):n,u=Le(r,s,c),l=Le(t,s);for(let h=0;h<l.size;++h){const p=l.indexToLoc(h),d=p.map((m,g)=>m+e[g]);l.set(u.get(...d),...p)}return s==="string"?Jg(l.values):l.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lO(n,e,t,r,s,o,i){const a=e[0],c=o[0],u=new Array(c),l=new Array(a),h=e[1];if(c===0){if(a!==0)throw new Error(Bg(a));const y=pt(t,0),x=pt(s,0);return[y,[0,h],x,u,l]}let p=!0,d=0;const m=new Array(c).fill(0);for(let y=0;y<a;++y){const x=n[y*h];if(x<0)throw new Error(Vg(y,x));if(x>=c)throw new Error(Ug(y,x,c));++m[x],p=p&&x>=d,d=x}let g=!0;for(let y=0;y<c;++y){const x=m[y]===0;u[y]=x,g=g&&!x,m[y]=Math.max(m[y],1),y>0&&(m[y]+=m[y-1])}if(g&&p){const y=n,x=r;for(let w=0;w<a;++w)l[w]=w;return[y,[a,h],x,u,l]}else{const y=m[c-1],x=pt(t,y*h),w=pt(s,y),S=new Array(c).fill(0);for(let $=0;$<a;++$){const N=n[$*h],_=S[N],O=(N===0?0:m[N-1])+_;S[N]++;for(let D=0;D<h;++D)x[O*h+D]=n[$*h+D];w[O]=r[$],l[$]=O}for(let $=0;$<c;++$)if(S[$]===0){const _=$===0?0:m[$-1];x[_*h+0]=$;for(let O=1;O<h;++O)x[_*h+O]=0;w[_]=i}return[x,[y,h],w,u,l]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hO(n,e,t,r,s){const o=G(r),i=e[0],a=s.length,c=[];let u=1,l=-1;for(let y=0;y<a;++y){const x=s[y];if(x===-1){if(l!==-1)throw new Error(zg(l,y));l=y,c.push(1)}else{if(x<0)throw new Error(Wg(y,x));u*=x,c.push(x)}}if(l!==-1){if(u<=0)throw new Error(Gg());const y=Math.trunc(o/u);if(u*y!==o)throw new Error(jg(r,c));c[l]=y}if(G(c)!==o)throw new Error(Hg(r,c));const p=r.length,d=[];if(p>0){d[p-1]=1;for(let y=p-2;y>=0;--y)d[y]=d[y+1]*r[y+1]}const m=[];if(a>0){m[a-1]=1;for(let y=a-2;y>=0;--y)m[y]=m[y+1]*c[y+1]}const g=pt(t,i*a);for(let y=0;y<i;++y){let x=0;for(let w=0;w<p;++w)x+=n[y*p+w]*d[w];for(let w=0;w<a;++w)g[y*a+w]=Math.trunc(x/m[w]),x%=m[w]}return[g,[i,a],c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pO(n,e,t,r,s,o=!1,i=0){const a=r.length,c=[e[0],n.length/e[0]],u=c[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(Na());const p=e.slice();p[0]=h;const d=p.reduce((S,$)=>S*$,1),m=pt(t,d);if(a===0)return h>0&&m.fill(i),[m,p];if(h<=0)throw new Error(Na());let g=0,y=1,x=0,w=s[g];for(;;){let S=0;if(y<a){if(S=s[y],w===S){++y;continue}if(w>=S)throw new Error(Kg())}if(w<0||w>=h)throw new Error(qg(w,h));w>x&&m.fill(i,x*u,w*u);for(let $=g;$<y;++$){const N=r[$];if(N<0||N>=c[0])throw new Error(Xg($,r[$],c[0]));for(let _=0;_<u;_++)m[w*u+_]+=n[N*u+_]}if(o)for(let $=0;$<u;$++)m[w*u+$]/=y-g;if(g=y,++y,x=w+1,w=S,y>a)break}return x<h&&m.fill(i,x*u,h*u),[m,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dO=jn(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fO=kt((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mO(n,e,t,r){const s=Le(n,e.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let c=0;c<a.length;c++)a[c]=i[c]*t[c]+r[c];s.set(e.get(...a),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gO{constructor(e,t,r,s,o,i){this.separator=sr(e),this.nGramWidths=t,this.leftPad=sr(r),this.rightPad=sr(s),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,o,i){for(let a=0;a<o;++a){const c=this.getPadWidth(i),u=Math.max(0,c-a),l=Math.max(0,c-(o-(a+1))),h=i-(u+l),p=t+(u>0?0:a-c);let d=0;d+=u*this.leftPad.length;for(let w=0;w<h;++w)d+=e[p+w].length;d+=l*this.rightPad.length,d+=(u+l+h-1)*this.separator.length,r[s+a]=new Uint8Array(d);const g=r[s+a];let y=0;const x=w=>w.forEach(S=>g[y++]=S);for(let w=0;w<u;++w)x(this.leftPad),x(this.separator);for(let w=0;w<h-1;++w)x(e[p+w]),x(this.separator);if(h>0){x(e[p+h-1]);for(let w=0;w<l;++w)x(this.separator),x(this.rightPad)}else{for(let w=0;w<l-1;++w)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let u=1;u<s;++u){let l=t[u]>=c;if(l=l&&t[u]<=r,!l)throw new Error(`Invalid split value ${t[u]}, must be in [${c}, ${r}]`);c=t[u]}if(c!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${c}`)}const o=s-1,i=pt("int32",s);if(r===0||s===0){const c=new Array(r);for(let u=0;u<=o;++u)i[u]=0;return[c,i]}i[0]=0;for(let c=1;c<=o;++c){const u=t[c]-t[c-1];let l=0;this.nGramWidths.forEach(h=>{l+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&l===0&&(l=1),i[c]=i[c-1]+l}const a=new Array(i[o]);for(let c=0;c<o;++c){const u=t[c];let l=i[c];if(this.nGramWidths.forEach(h=>{const p=t[c+1]-t[c],d=this.getNumNGrams(p,h);this.createNGrams(e,u,a,l,d,h),l+=d}),this.preserveShort&&l===i[c]){const h=t[c+1]-t[c];if(h===0)continue;const p=h+2*this.padWidth,d=1;this.createNGrams(e,u,a,l,d,p)}}return[a,i]}}function yO(n,e,t,r,s,o,i,a){return new gO(t,r,s,o,i,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xO(n,e,t,r){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=n.indexOf(o);for(;i!==-1;){const a=n.subarray(0,i);(!t||a.length!==0)&&r.push(a),n=n.subarray(i+1),i=n.indexOf(o)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const i=n.subarray(s,o);(!t||i.length!==0)&&r.push(i),s=o+1}}function bO(n,e,t){const r=n.length,s=[];let o=0,i=0;const a=new Array(r);for(let p=0;p<r;++p){const d=s.length;xO(n[p],e,t,s);const m=s.length-d;a[p]=m,o+=m,i=Math.max(i,m)}const c=pt("int32",o*2),u=new Array(o),l=[r,i];let h=0;for(let p=0;p<r;++p)for(let d=0;d<a[p];++d)c[h*2]=p,c[h*2+1]=d,u[h]=s[h],++h;return[c,u,l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vO(n,e){const t=pt("int32",n.length);for(let r=0;r<n.length;++r)t[r]=D1(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wO=kt((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Le(t,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(n.rank);for(let c=0;c<i.length;c++)i[c]=o[c]%n.shape[c];const a=n.locToIndex(i);r.values[s]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xs=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Py(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,c=e-t+1,u=Math.log(a),l=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*l*(a-l)/a)*Math.sign(c-a/2),p=Math.max(t,Math.floor(e-c*l/a+h)),d=Math.min(r,Math.floor(e+(a-c)*l/a+h));Py(n,e,p,d)}const s=n[e];let o=t,i=r;for(hs(n,t,e),xs(n[r],s)>0&&hs(n,t,r);o<i;){for(hs(n,o,i),o++,i--;xs(n[o],s)<0;)o=o+1;for(;xs(n[i],s)>0;)i=i-1}xs(n[t],s)===0?hs(n,t,i):(i=i+1,hs(n,i,r)),i<=e&&(t=i+1),e<=i&&(r=i-1)}}function SO(n,e,t,r,s){const o=e[e.length-1],[i,a]=[n.length/o,o],c=Cn(t,i*r),u=Cn("int32",i*r);for(let h=0;h<i;h++){const p=h*a,d=n.subarray(p,p+a);let m=new Array(d.length);d.forEach((w,S)=>m[S]={value:w,index:S}),r<m.length&&(Py(m,r),m=m.slice(0,r)),s&&m.sort(xs);const g=h*r,y=c.subarray(g,g+r),x=u.subarray(g,g+r);for(let w=0;w<r;w++)y[w]=m[w].value,x[w]=m[w].index}const l=e.slice();return l[l.length-1]=r,[Le(l,t,c),Le(l,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(n,e,t,r){const s=je(e,t)[0],o=[1,t[0],1];for(let m=0;m<s;m++)o[0]*=t[m];o[1]=t[s];for(let m=s+1;m<t.length;m++)o[2]*=t[m];const i={},a=new Int32Array(t[s]),c=new $s(o,r,n),u=[],l=o[0]===1&&o[2]===1;for(let m=0;m<t[s];m++){let g;if(l)g=n[m].toString();else{const y=[];for(let x=0;x<o[0];x++)for(let w=0;w<o[2];w++)y.push(c.get(x,m,w));g=y.join(",")}if(i[g]!==void 0)a[m]=i[g];else{const y=Object.keys(i).length;i[g]=y,a[m]=y,u.push(m)}}const h=o.slice();h[1]=Object.keys(i).length;const p=new $s(h,r);u.forEach((m,g)=>{for(let y=0;y<o[0];y++)for(let x=0;x<o[2];x++)p.set(c.get(y,m,x),y,g,x)});const d=t.slice();return d[s]=h[1],{outputValues:p.values,outputShape:d,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $O=Object.freeze(Object.defineProperty({__proto__:null,simpleAbsImpl:$R,addImpl:kR,bincountImpl:NR,bincountReduceImpl:IR,castImpl:ER,ceilImpl:_R,concatImpl:RR,equalImpl:OR,expImpl:AR,expm1Impl:DR,floorImpl:PR,gatherNdImpl:FR,gatherV2Impl:LR,greaterImpl:MR,greaterEqualImpl:BR,lessImpl:VR,lessEqualImpl:UR,linSpaceImpl:zR,logImpl:WR,maxImpl:GR,maximumImpl:jR,minimumImpl:HR,multiplyImpl:Dy,negImpl:KR,notEqualImpl:qR,prodImpl:YR,raggedGatherImpl:rO,raggedTensorToTensorImpl:sO,rangeImpl:oO,rsqrtImpl:iO,scatterImpl:aO,sigmoidImpl:cO,sliceImpl:uO,sparseFillEmptyRowsImpl:lO,sparseReshapeImpl:hO,sparseSegmentReductionImpl:pO,sqrtImpl:dO,squaredDifferenceImpl:fO,stridedSliceImpl:mO,stringNGramsImpl:yO,stringSplitImpl:bO,stringToHashBucketFastImpl:vO,subImpl:wO,tileImpl:CO,topKImpl:SO,transposeImpl:XR,uniqueImpl:TO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:EO,bincountImpl:Fy,bincountReduceImpl:kO,castImpl:NO,ceilImpl:IO,concatImpl:_O,equalImpl:RO,expImpl:OO,expm1Impl:AO,floorImpl:DO,gatherNdImpl:PO,gatherV2Impl:FO,greaterImpl:LO,greaterEqualImpl:MO,lessImpl:BO,lessEqualImpl:VO,linSpaceImpl:UO,logImpl:zO,maxImpl:WO,maximumImpl:GO,minimumImpl:jO,multiplyImpl:HO,negImpl:KO,notEqualImpl:qO,prodImpl:XO,raggedGatherImpl:YO,raggedTensorToTensorImpl:QO,rangeImpl:ZO,rsqrtImpl:JO,scatterImpl:eA,sigmoidImpl:tA,simpleAbsImpl:Ly,sliceImpl:nA,sparseFillEmptyRowsImpl:rA,sparseReshapeImpl:sA,sparseSegmentReductionImpl:My,sqrtImpl:oA,stridedSliceImpl:iA,stringNGramsImpl:aA,stringSplitImpl:cA,stringToHashBucketFastImpl:uA,subImpl:lA,tileImpl:hA,topKImpl:pA,transposeImpl:Qc,uniqueImpl:dA}=$O;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function By(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function it(n,e){return e===1?[n]:By(n,e)}function fA(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mA{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ut(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=it("rc",this.rank),r=ke(this.rank),s=this.getOutOfBoundsCondition(t),o=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vy{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2===1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${gA(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Xc():qc(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function gA(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?g_(["r","c","d"],"inputShape"):yr(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yA{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,r){const s=rh(t,r),o=sh(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=nh(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const c=this.freeTextures[o].shift();return this.usedTextures[o].push(c),c}let a;return s===Ke.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===Ke.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===Ke.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===Ke.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===Ke.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const o=rh(r,s),i=sh(t,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=nh(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),c=M().get("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function xA(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function nh(n,e,t,r,s){const o=bA(e,r);let i;if(s){const[c,u]=Qr(n[0],n[1]);i=c*u}else{const[c,u]=zs(n[0],n[1]);i=c*u}const a=xA(t,o);return i*a}function bA(n,e){switch(n){case Ke.PACKED_2X2_FLOAT32:return Oy(e);case Ke.PACKED_2X2_FLOAT16:return Ay(e);case Ke.UNPACKED_FLOAT32:return Iy(e);case Ke.UNPACKED_FLOAT16:return _y(e);case Ke.PACKED_4X1_UNSIGNED_BYTE:return Ry(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function vA(n){return M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ke.PACKED_2X2_FLOAT32:Ke.UNPACKED_FLOAT32:n?Ke.PACKED_2X2_FLOAT16:Ke.UNPACKED_FLOAT16}function rh(n,e){if(n===St.UPLOAD)return Ke.PACKED_2X2_FLOAT32;if(n===St.RENDER||n==null)return vA(e);if(n===St.DOWNLOAD||n===St.PIXELS)return Ke.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function sh(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ht="if (isnan(x)) return x;",wA="return x;",oh="return abs(x);",CA="return (x >= 0.0) ? x : (exp(x) - 1.0);",SA=Ht+`
  return (x < 0.0) ? 0.0 : x;
`,TA=Ht+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Tr="return x;",$A="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EA="return x;",kA=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,NA=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,IA=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_A="return 1.0 / (1.0 + exp(-1.0 * x));";class rr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length);const t=e.length,r=it("rc",t),s=ke(t),o=fA(t,r),i=r.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OA=ug,AA=1e-7,DA=1e-4,lo={};function PA(n){return n in lo||(lo[n]={}),lo[n]}const FA=M().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),LA=600;function MA(){return M().global.screen==null?1024:M().global.screen.height*M().global.screen.width*window.devicePixelRatio*LA/1024/1024}class hi extends Ah{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!M().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Xi)t=e;else{const r=en(M().getNumber("WEBGL_VERSION"),e);t=new Xi(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=en(M().getNumber("WEBGL_VERSION"));t=new Xi(r),this.binaryCache=PA(M().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new yA(this.gpgpu),this.numMBBeforeWarning=MA(),this.texData=new e1(this,On())}nextDataId(){return hi.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,r){if((M().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||M().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:St.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,o){if(M().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:St.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:i,shape:a,isPacked:c}=t;if(i!=null){let p;c?p=new rr(a,Tr):p=new xn(a,Tr);const d=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:s}],s),m=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),m}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const u=this.activeTimers!=null;let l;u&&(l=Yt());let h;if(s==="complex64"){const p=this.readSync(o.real.dataId),d=this.readSync(o.imag.dataId);h=ka(p,d)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Yt()-l),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const m=this.pendingRead.get(e);return new Promise(g=>m.push(g))}const t=this.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:c}=t;if(o!=null){let m;c?m=new rr(s,Tr):m=new xn(s,Tr);const g=this.runWebGLProgram(m,[{dataId:e,shape:s,dtype:i}],i),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(M().getBool("DEBUG")&&!M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&M().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,l;if(i!=="complex64"&&M().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const m=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(m.texture.texture,...io(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const m=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=m[0],y=m[1];h=ka(g,y)}else if(u==null)h=this.getValuesFromTexture(e);else{const m=G(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,m)}if(l!=null&&this.disposeIntermediateTensorInfo(l),u!=null){const m=this.gpgpu.gl;Q(m,()=>m.deleteBuffer(u))}const p=this.convertAndCacheOnCPU(e,h),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(m=>m(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&On().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:o,slice:i,dtype:a,isPacked:c,texture:u}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let d;c?d=new rr(o,Tr):d=new xn(o,Tr);const m=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:a}],a),g=this.readToGPU(m,t);return this.disposeIntermediateTensorInfo(m),g}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),h=On().makeTensorFromTensorInfo(l),p=this.texData.get(l.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>Br(s));return Le(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Le(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!WI(r))throw M().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),o=G(t);if(M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),d=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...io(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),m}const i=M().getBool("WEBGL_PACK")&&s===!0,a=i?Hi(t):t,c=i?new oR(a):new sR(a),u=this.runWebGLProgram(c,[{shape:a,dtype:r,dataId:e}],"float32"),l=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=Pr(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),i=Pr(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(o);a.kernelMs=t1(c),a.getExtraProfileInfo=()=>c.map((u,l)=>({name:i[l],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Yt(),endMs:null}}endTimer(e){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Yt(),e)}async getQueryTime(e){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:o,isPacked:i,slice:a}=this.texData.get(e),c=a&&a.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,o,i)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=FA){return M().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&G(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Jt("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return OA(e.shape,t)}packedUnaryOp(e,t,r){const s=new rr(e.shape,t),o=this.compileAndRun(s,[e],r);return On().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=Ly(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(M().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,oh,e.dtype);const t=new xn(e.shape,oh),r=this.compileAndRun(t,[e]);return On().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&qo(r[0])){const o=r.map(i=>sr(i));s=this.write(o,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){return On().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new RA(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new mA(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[Gr(e.shape),...jr(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Gr(t),...jr(t)],i=new Vy(o,r),a=!0,c=[r],u=this.runWebGLProgram(i,[s],e.dtype,c,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r;if(t!=null){const p=G(o),d=t[0]*t[1]*4;k(p<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Hi(o);let c;s?c=new rR(a):c=new nR(a);const u=!0,l=[t!=null?t:io(a)],h=this.runWebGLProgram(c,[{shape:a,dtype:i,dataId:e}],i,l,u,t);return{dtype:i,shape:o,dataId:h.dataId}}runWebGLProgram(e,t,r,s,o=!1,i){const a=this.makeTensorInfo(e.outputShape,r),c=this.texData.get(a.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Ds.DENSE){const x=i!=null?i:io(e.outputShape);c.texShape=x.map(w=>w*2)}if(e.outTexUsage!=null&&(c.usage=e.outTexUsage),G(a.shape)===0)return c.values=Cn(a.dtype,0),a;const u=[],l=t.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(x.dataId);if(w.texture==null){if(!e.packedInputs&&G(x.shape)<=M().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!w.isPacked!=!!e.packedInputs)x=w.isPacked?this.unpackTensor(x):this.packTensor(x),u.push(x),w=this.texData.get(x.dataId);else if(w.isPacked&&!Wo(w.shape,x.shape)){const S=x,$=x.shape;x.shape=w.shape,x=this.packedReshape(x,$),u.push(x),w=this.texData.get(x.dataId),S.shape=$}return{shape:x.shape,texData:w,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:c,isUniform:!1},p=tR(e,l,h),d=this.getAndSaveBinary(p,()=>J_(this.gpgpu,e,l,h)),m=this.activeTimers!=null;let g;m&&(g=this.startTimer()),M().get("ENGINE_COMPILE_ONLY")||eR(this.gpgpu,d,l,h,s),u.forEach(x=>this.disposeIntermediateTensorInfo(x)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=M().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const x=Yt();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!M().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&o===!1){const x=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),x}return a}compileAndRun(e,t,r,s,o=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(M().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=we(()=>{if(!M().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=M().getBool("DEBUG");M().set("DEBUG",!1);const t=this.abs(he(1e-8)).dataSync()[0];if(M().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?AA:DA}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:o,texture:i,usage:a,isPacked:c}=t;if(i!=null)return;const u=this.activeTimers!=null;let l;u&&(l=Yt());let h=t.texShape;if(h==null&&(h=a_(r,c),t.texShape=h),o!=null){const p=Hi(r);let d,m=h[1],g=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!y)&&([m,g]=Qr(h[0],h[1])),c?d=new aR(p,y):d=new iR(p,y);const x=y?[g,m]:h,w=this.makeTensorInfo(x,s),S=this.texData.get(w.dataId);y?S.usage=St.PIXELS:S.usage=St.UPLOAD,S.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),m,g,o);const $=[[g,m]],N=!0,_=this.runWebGLProgram(d,[w],s,$,N),O=this.texData.get(_.dataId);t.texShape=O.texShape,t.isPacked=O.isPacked,t.usage=O.usage,M().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(t.texture=O.texture,t.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(w),u&&(this.uploadWaitMs+=Yt()-l)}else{const p=this.acquireTexture(h,a,s,c);t.texture=p}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return this.releaseGPUData(e),t!=null&&(r.values=BA(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*Ji(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(t),s(!0)}catch(o){throw o}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await DE(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Sy(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:r,infLoc:s,nanLoc:o,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:c,outShapeStridesLocation:u,outTexShapeLocation:l}=Ny(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=o,e.inShapesLocations=i,e.inTexShapesLocations=a,e.outShapeLocation=c,e.outShapeStridesLocation=u,e.outTexShapeLocation=l}}}hi.nextDataId=0;function BA(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Lf()&&sm("webgl",()=>new hi,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zc=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Hr{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=me(t,r),this.enableShapeUniforms=ut(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const js=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Hs{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=me(t,r);const o=this.outputShape.length;this.enableShapeUniforms=ut(o);let i="";if(s)if(o===0||G(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ke(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=it("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${c[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${c[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${c[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${c[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yt(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const VA={kernelName:pc,backendName:"webgl",kernelFunc:yt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hn(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,o=t.makeTensorInfo(r.shape,"complex64"),i=t.texData.get(o.dataId),a=yt({inputs:{x:r},backend:t}),c=yt({inputs:{x:s},backend:t});return i.complexTensorInfos={real:a,imag:c},o}const UA={kernelName:ip,backendName:"webgl",kernelFunc:Hn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uy="return (a < 0.) ? b * a : a;",zy=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function zA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:o}=r,i=t.makeTensorInfo([],"float32",qr(o,"float32")),a=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hs(zy,s.shape,i.shape):new Hr(Uy,s.shape,i.shape),c=t.runWebGLProgram(a,[s,i],"float32");return t.disposeIntermediateTensorInfo(i),c}const WA={kernelName:Xp,backendName:"webgl",kernelFunc:zA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wy="return (a < 0.) ? b * a : a;",Gy=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function GA(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,o=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hs(Gy,r.shape,s.shape):new Hr(Wy,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],"float32")}const jA={kernelName:kd,backendName:"webgl",kernelFunc:GA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ns="if (isnan(x)) return x;";function pe({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,c=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){const h=a.texData.get(i.dataId),p=t(h.values,c);return a.makeTensorInfo(i.shape,c,p)}const u=M().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let l;return u?l=new rr(i.shape,e):l=new xn(i.shape,n),a.runWebGLProgram(l,[i],c)}}function Xe({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:c,b:u}=i,l=a;if(r&&c.dtype==="complex64"){const m=l.texData.get(c.dataId),g=l.texData.get(u.dataId),[y,x]=[[m.complexTensorInfos.real,g.complexTensorInfos.real],[m.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(S=>{const[$,N]=S,_={dataId:$.dataId,dtype:$.dtype,shape:c.shape},O={dataId:N.dataId,dtype:N.dtype,shape:u.shape},D=new Hr(n,c.shape,u.shape);return l.runWebGLProgram(D,[_,O],pn($.dtype,N.dtype))}),w=Hn({inputs:{real:y,imag:x},backend:l});return l.disposeIntermediateTensorInfo(y),l.disposeIntermediateTensorInfo(x),w}const h=o||pn(c.dtype,u.dtype);if((c.dtype==="string"||u.dtype==="string"||l.shouldExecuteOnCPU([c,u]))&&s!=null){const m=l.texData.get(c.dataId).values,g=l.texData.get(u.dataId).values,y=c.dtype==="string"?Rs(m):m,x=c.dtype==="string"?Rs(g):g,[w,S]=s(c.shape,u.shape,y,x,h),$=l.makeTensorInfo(S,h),N=l.texData.get($.dataId);return N.values=w,$}const p=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return p?d=new Hs(e,c.shape,u.shape,t):d=new Hr(n,c.shape,u.shape),l.runWebGLProgram(d,[c,u],h)}}function Ps(n,e=!1){if(n==="linear")return e?EA:wA;if(n==="relu")return e?NA:SA;if(n==="elu")return e?kA:CA;if(n==="relu6")return e?IA:TA;if(n==="prelu")return e?Gy:Wy;if(n==="leakyrelu")return e?zy:Uy;if(n==="sigmoid")return e?_A:$A;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jy{constructor(e,t,r,s=!1,o=!1,i=!1,a=null,c=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ut(this.outputShape.length);const l=s?e[1]:e[2],h=Math.ceil(l/2),p=s?"i * 2, rc.y":"rc.y, i * 2",d=o?"rc.z, i * 2":"i * 2, rc.z",m=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",x="";a&&(c?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");const w=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let S="rc.x",$="rc.x";e[0]<t[0]?S=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&($=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${h}; i++) {
          int batchA = ${S};
          int batchB = ${$};
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${g[0]});
          result += (${m[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${x}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ih={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class ah{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=me(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ch="return a * b;";function Jc(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,o=pn(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=t.texData.get(r.dataId),c=t.texData.get(s.dataId),u=new ah(ih.REAL,r.shape,s.shape),l=new ah(ih.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:s.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:s.shape}],p=t.runWebGLProgram(u,h,"float32"),d=t.runWebGLProgram(l,h,"float32"),m=Hn({inputs:{real:p,imag:d},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),m}if(t.shouldExecuteOnCPU([r,s])){const a=t.texData.get(r.dataId),c=t.texData.get(s.dataId),[u,l]=HO(r.shape,s.shape,a.values,c.values,o),h=t.makeTensorInfo(l,o),p=t.texData.get(h.dataId);return p.values=u,h}let i;return M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Hs(ch,r.shape,s.shape):i=new Hr(ch,r.shape,s.shape),t.runWebGLProgram(i,[r,s],o)}const HA={kernelName:gd,backendName:"webgl",kernelFunc:Jc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(n,e,t){const r=[Gr(n.shape),...jr(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},o=[Gr(e),...jr(e)],i=new Vy(o,r),a=!0,c=[r],u=t.runWebGLProgram(i,[s],n.dtype,c,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:o}=r,i=t,a=G(s.shape),c=n1(o,a),u=G(c);k(a===u,()=>`The new shape (${c}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const l=i.texData.get(s.dataId);return l.isPacked&&!Wo(s.shape,c)&&!(l.texture!==null&&Wo(l.shape,c))?KA(s,c,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:c,dtype:s.dtype})}const qA={kernelName:Pd,backendName:"webgl",kernelFunc:q};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uh{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];const a=Math.floor(r/4)*4,c=r%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${Fr(h)?h.toPrecision(2):h}, ones);`}let l="";o%r>0&&(l=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XA{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];let a="0.0",c="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",c="min"):t==="max"&&(a="-1.0 / 1e-20",c="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const l=Math.floor(r/4)*4,h=r%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let m="";o%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${l};
        if (${h===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=ui(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function br(n,e,t,r){const s=YA(n.shape);let o=n;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:c,outSize:u}=s[i];let l,h;t==="mean"?l=i===0?new uh({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u},a):new uh({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u}):l=new XA({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u},t),h=o,o=r.runWebGLProgram(l,[o],e),h.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(h)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QA{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[t[i]];this.outputShape=r,this.rank=r.length;const s=ke(this.rank),o=ZA(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function ZA(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JA{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let l=0;l<r.length;l++)r[l]=e[t[l]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=ke(this.rank),o=By("rc",this.rank),i=new Array(this.rank);for(let l=0;l<t.length;l++)i[t[l]]=o[l];const a=`vec2(${i.slice(-2).join()})`,c=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${c}) {
        result[1] = ${u};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${c}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pi(n,e,t){const r=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JA(n.shape,e):new QA(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eD(n,e,t,r){const s=e,o=n.shape.length,i=je(s,n.shape);let a=i;const c=Gt(a,o),u=c!=null;let l=n;u&&(l=pi(n,c,r),a=jt(a.length,o)),nn("sum",a,o);const[h,p]=fn(l.shape,a);let d=h;t&&(d=Et(h,i));const m=G(p),y=G(n.shape)/m,x=q({inputs:{x:l},attrs:{shape:[y,m]},backend:r}),w=mc(n.dtype),S=br(x,w,"sum",r),$=q({inputs:{x:S},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(S),u&&r.disposeIntermediateTensorInfo(l),$}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function di(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r;return eD(s,o,i,t)}const tD={kernelName:Jd,backendName:"webgl",kernelFunc:di};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function at(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:o}=r,i=t,a=s.shape.length,c=new Array(a);for(let l=0;l<c.length;l++)c[l]=s.shape[o[l]];let u;if(i.shouldExecuteOnCPU([s])){const h=i.texData.get(s.dataId).values,p=Qc(h,s.shape,s.dtype,o,c);u=i.makeTensorInfo(c,s.dtype);const d=i.texData.get(u.dataId);d.values=p}else u=pi(s,o,i);return u}const nD={kernelName:po,backendName:"webgl",kernelFunc:at};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hy=1e3;function jo({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:c=null}){const u=n.shape.length,l=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],p=r?e.shape[l-1]:e.shape[l-2],d=t?n.shape[u-1]:n.shape[u-2],m=r?e.shape[l-2]:e.shape[l-1],g=n.shape.slice(0,-2),y=e.shape.slice(0,-2),x=G(g),w=G(y),$=me(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,m]);k(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const N=t?[x,h,d]:[x,d,h],_=r?[w,m,p]:[w,p,m],O=q({inputs:{x:n},backend:s,attrs:{shape:N}}),D=q({inputs:{x:e},backend:s,attrs:{shape:_}}),F=[O,D],L=Math.max(x,w),z=t?O.shape[1]:O.shape[2],j=o!=null,K=i!=null,Y=c==="leakyrelu",te=c!=null?Ps(c,!0):null,re=j||K||Y||te!=null;let ae;if((d===1||m===1)&&z>Hy&&re===!1){let Ve=O,Kt=D;t&&(Ve=at({inputs:{x:O},backend:s,attrs:{perm:[0,2,1]}}),F.push(Ve)),r&&(Kt=at({inputs:{x:D},backend:s,attrs:{perm:[0,2,1]}}),F.push(Kt));const Nn=m!==1,Kn=m===1;let os=Ve;Nn&&(os=q({inputs:{x:Ve},backend:s,attrs:{shape:[L,z,1]}}),F.push(os));const Xs=m===1?2:1;let vr=Kt;Kn&&(vr=q({inputs:{x:Kt},backend:s,attrs:{shape:[L,1,z]}}),F.push(vr));const In=Jc({inputs:{a:os,b:vr},backend:s});ae=di({inputs:{x:In},backend:s,attrs:{axis:Xs,keepDims:!0}}),F.push(In)}else{const Ve=pn(n.dtype,e.dtype),Kt=new jy(N,_,[L,d,m],t,r,j,te,K,Y),Nn=[O,D];if(o!=null&&Nn.push(o),K&&Nn.push(i),Y){const Kn=s.makeTensorInfo([],"float32",qr(a,"float32"));Nn.push(Kn),F.push(Kn)}ae=s.runWebGLProgram(Kt,Nn,Ve)}const be=q({inputs:{x:ae},backend:s,attrs:{shape:$}});F.push(ae);for(const Ve of F)s.disposeIntermediateTensorInfo(Ve);return be}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:c,transposeB:u,activation:l,leakyreluAlpha:h}=r;return jo({a:s,b:o,transposeA:c,transposeB:u,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:l})}const sD={kernelName:sa,backendName:"webgl",kernelFunc:rD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lh="return abs(x);";function oD(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=t.texData.get(r.dataId),i=Ly(o.values);return t.makeTensorInfo(r.shape,r.dtype,i)}let s;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new rr(r.shape,lh):s=new xn(r.shape,lh),t.runWebGLProgram(s,[r],r.dtype)}const iD={kernelName:Bh,backendName:"webgl",kernelFunc:oD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aD=Ht+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,cD=pe({opSnippet:aD}),uD={kernelName:Vh,backendName:"webgl",kernelFunc:cD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lD=Ht+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,hD=pe({opSnippet:lD}),pD={kernelName:Uh,backendName:"webgl",kernelFunc:hD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hh="return a + b;",dD=Xe({opSnippet:hh,packedOpSnippet:hh,supportsComplex:!0,cpuKernelImpl:EO}),fD={kernelName:lc,backendName:"webgl",kernelFunc:dD};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mD{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gD{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xo(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return yt({inputs:{x:r[0]},backend:t});if(r.length>M().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(r.length/2),u=xo({inputs:r.slice(0,c),backend:t}),l=xo({inputs:r.slice(c),backend:t});return xo({inputs:[u,l],backend:t})}const s=r.map(c=>c.dtype).reduce((c,u)=>pn(c,u)),o=r.map(c=>c.shape),a=M().getBool("WEBGL_PACK")?new gD(r[0].shape,o):new mD(r[0].shape,o);return t.runWebGLProgram(a,r,s)}const yD={kernelName:zh,backendName:"webgl",kernelFunc:xo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,c=je(o,s.shape);let u=c;const l=Gt(u,a);let h=s;l!=null&&(h=at({inputs:{x:s},backend:t,attrs:{perm:l}}),u=jt(u.length,a)),nn("all",u,a);const[p,d]=fn(h.shape,u),m=G(d),g=q({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),y=br(g,g.dtype,"all",t);let x;if(i){const w=Et(p,c);x=q({inputs:{x:y},backend:t,attrs:{shape:w}})}else x=q({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),l!=null&&t.disposeIntermediateTensorInfo(h),x}const bD={kernelName:Wh,backendName:"webgl",kernelFunc:xD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,c=je(o,s.shape);let u=c;const l=Gt(u,a);let h=s;l!=null&&(h=at({inputs:{x:s},backend:t,attrs:{perm:l}}),u=jt(u.length,a)),nn("any",u,a);const[p,d]=fn(h.shape,u),m=G(d),g=q({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),y=br(g,g.dtype,"any",t);let x;if(i){const w=Et(p,c);x=q({inputs:{x:y},backend:t,attrs:{shape:w}})}else x=q({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),l!=null&&t.disposeIntermediateTensorInfo(h),x}const wD={kernelName:Gh,backendName:"webgl",kernelFunc:vD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CD{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=t==="max"?">":"<",c=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SD{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,k(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,c=a.length,u=ke(c),l=it("coords",c);let h,p;if(i===1){p=c+1;const D=ke(p);h=`
        ${D} sourceLocR = ${D}(${l.join()}, 0);
        ++${l[c-1]};
        ${D} sourceLocG = ${D}(${l.join()}, 0);
        ++${l[c-2]};
        ${D} sourceLocA = ${D}(${l.join()}, 0);
        --${l[c-1]};
        ${D} sourceLocB = ${D}(${l.join()}, 0);
        --${l[c-2]};`}else p=c,h=`
        ${u} sourceLocR = coords;
        ++${l[c-1]};
        ${u} sourceLocG = coords;
        ++${l[c-2]};
        ${u} sourceLocA = coords;
        --${l[c-1]};
        ${u} sourceLocB = coords;
        --${l[c-2]};`;const d=["x","y","z","w","u","v"].slice(0,p),m="."+d[p-1],g=d.map(D=>"int "+D),y=it("sourceLocR",p-1).concat("inIdx.r"),x=it("sourceLocG",p-1).concat("inIdx.g"),w=it("sourceLocB",p-1).concat("inIdx.b"),S=it("sourceLocA",p-1).concat("inIdx.a"),$=r==="max"?"greaterThan":"lessThan",N=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()})));`,_=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,O=s?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${O}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${l[c-1]} < ${a[c-1]-1};
        bool hasNextRow = ${l[c-2]} < ${a[c-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(n,e,t,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const i=ui(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},c=new CD(a,t,r==null),u=[e];r!=null&&u.push(r);const l=n.runWebGLProgram(c,u,"int32");if(l.shape[1]===1)return l;const h=Ky(n,e,t,l);return n.disposeIntermediateTensorInfo(l),h}function qy(n,e,t,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],i=ui(o),a=new SD(s,i,t,r==null),c=r==null?[e]:[e,r],u=n.runWebGLProgram(a,c,"int32");if(u.shape.length===e.shape.length){const l=qy(n,e,t,u);return n.disposeIntermediateTensorInfo(u),l}return u}function Xy(n,e,t,r){const s=[t];if(nn("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!M().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=n.texData.get(e.dataId),a=i!==null&&i.isPacked;let c=e;a&&(c=n.unpackTensor(e),o.push(c));const[u,l]=fn(c.shape,s),h=G(l),p=q({inputs:{x:c},backend:n,attrs:{shape:[-1,h]}});o.push(p);const d=Ky(n,p,r);o.push(d);const m=q({inputs:{x:d},backend:n,attrs:{shape:u}});return o.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}return qy(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let i=je(o,s.shape);const a=Gt(i,s.shape.length);let c=s;const u=[];a!=null&&(c=at({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(c),i=jt(i.length,c.shape.length)),nn("argMax",[i[0]],c.shape.length);const l=Xy(t,c,i[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),l}const $D={kernelName:jh,backendName:"webgl",kernelFunc:TD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let i=je(o,s.shape);const a=Gt(i,s.shape.length);let c=s;const u=[];a!=null&&(c=at({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(c),i=jt(i.length,c.shape.length)),nn("argMin",[i[0]],c.shape.length);const l=Xy(t,c,i[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),l}const kD={kernelName:Hh,backendName:"webgl",kernelFunc:ED};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ND=Ht+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ID=pe({opSnippet:ND}),_D={kernelName:Kh,backendName:"webgl",kernelFunc:ID};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RD=Ht+"return log(x + sqrt(x * x + 1.0));",OD=pe({opSnippet:RD}),AD={kernelName:qh,backendName:"webgl",kernelFunc:OD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DD=Ht+`
  return atan(x);
`,PD=pe({opSnippet:DD}),FD={kernelName:Xh,backendName:"webgl",kernelFunc:PD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LD=Zc+`
  return atan(a, b);
`,MD=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,BD=Xe({opSnippet:LD,packedOpSnippet:MD}),VD={kernelName:Qh,backendName:"webgl",kernelFunc:BD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UD=Ht+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,zD=pe({opSnippet:UD}),WD={kernelName:Yh,backendName:"webgl",kernelFunc:zD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fs{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let w="0.0";if(g||(w="-1.0 / 1e-20"),r){const D=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${c});
        const ivec2 pads = ivec2(${d}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?y:x:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let $=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&($="avgValue / count");const N=Math.floor(i/4)*4,_=i%4,O=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${c});
      const ivec2 pads = ivec2(${d}, ${m});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${O}
          }

          int xC = xCCorner + ${N};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${O}
          }
        }
        setOutput(${$});
      }
    `}}class eu{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,c=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,h=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,m=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=e.padInfo.front,x=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;const S=t==="avg";let $="0.0";if(S||($="-1.0 / 1e-20"),r){const L=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${c}, ${u});
        const ivec3 pads = ivec3(${y}, ${x}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${L} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / count");const O=Math.floor(i/4)*4,D=i%4,F=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${c}, ${u});
      const ivec3 pads = ivec3(${y}, ${x}, ${w});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${O}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${O};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${F}
            }
          }
          setOutput(${_});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Ws(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:c}=r,u=1;k(bt(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const l=fr(s.shape,o,i,u,a,c);if(l.filterWidth===1&&l.filterHeight===1&&Me(l.inShape,l.outShape))return yt({inputs:{x:s},backend:t});const h=new Fs(l,"avg",!1);return t.runWebGLProgram(h,[s],"float32")}const jD={kernelName:Zh,backendName:"webgl",kernelFunc:GD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:c,dataFormat:u}=r,l=[1,1,1],h=Bs(s.shape,o,i,l,a,c,u),p=new eu(h,"avg",!1);return t.runWebGLProgram(p,[s],"float32")}const KD={kernelName:Jh,backendName:"webgl",kernelFunc:HD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qD{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=c-1-e.padInfo.top,h=u-1-e.padInfo.left,p=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${h});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class XD{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,m=h-1-e.padInfo.front,g=p-1-e.padInfo.top,y=d-1-e.padInfo.left,x=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YD(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o,{filterSize:a,strides:c,pad:u,dimRoundingMode:l}=r,h=[1,1,1],p=Bs(i.shape,a,c,h,u,l),d=new XD(p);return t.runWebGLProgram(d,[s],i.dtype)}const QD={kernelName:g1,backendName:"webgl",kernelFunc:YD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZD(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o;Ws([s,o],"avgPoolGrad");const{filterSize:a,strides:c,pad:u}=r,l=fr(i.shape,a,c,1,u),h=new qD(l);return t.runWebGLProgram(h,[s],i.dtype)}const JD={kernelName:m1,backendName:"webgl",kernelFunc:ZD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eP(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return jo({a:s,b:o,transposeA:i,transposeB:a,backend:t})}const tP={kernelName:ep,backendName:"webgl",kernelFunc:eP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nP{constructor(e,t,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],me(e,t),me(e,r);let a="0.0";s!=null&&(me(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="1.0";o!=null&&(me(e,o),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rP{constructor(e,t,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],me(e,t),me(e,r);let a="vec4(0.0)";s!=null&&(me(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="vec4(1.0)";o!=null&&(me(e,o),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sP=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=n;k(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);const u=[r,s,o];let l=null;i!=null&&(l=i.shape,u.push(i));let h=null;a!=null&&(h=a.shape,u.push(a));const p=M().getBool("WEBGL_PACK_NORMALIZATION")?new rP(r.shape,s.shape,o.shape,l,h,c):new nP(r.shape,s.shape,o.shape,l,h,c);return e.runWebGLProgram(p,u,u[0].dtype)},oP={kernelName:Bp,backendName:"webgl",kernelFunc:sP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iP{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=ke(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=aP(this.rank);let s;const o=e.map((i,a)=>`sourceLoc.${Ka[a]} = start[${a}] + coords.${Ka[a]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const Ka=["x","y","z","w","u","v"];function aP(n){if(n===1)return"sourceLoc";if(n<=6)return Ka.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cP{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=ke(this.rank),r=it("coords",this.rank),s=it("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((l,h)=>`start[${h}]`).join()});`:e.map((l,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uP(n,e,t,r){const s=r.texData.get(n.dataId),o=r.makeTensorInfo(t,n.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=t,i.dtype=n.dtype;let a=$c(e,qe(n.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const c=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,c+1),o}function rs(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,size:i}=r,[a,c]=vm(s,o,i);if(lm(s,a,c),G(c)===0)return t.makeTensorInfo(c,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.texData.get(s.dataId),p=nA(h.values,a,c,s.shape,s.dtype);return t.makeTensorInfo(c,s.dtype,p)}const{isPacked:u}=t.texData.get(s.dataId),l=Tc(s.shape,a,c);if(u||!l){const h=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cP(c):new iP(c),p=[a];return t.runWebGLProgram(h,[s],s.dtype,p)}return t.uploadToGPU(s.dataId),uP(s,a,c,t)}const lP={kernelName:Hd,backendName:"webgl",kernelFunc:rs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hP=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,crops:i}=r;k(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((w,S)=>w*S),c=zc(s.shape,o,a),u=Wc(c.length,o.length),l=Gc(s.shape,o,a),h=Sg(i,o.length),p=Tg(l,i,o.length),d=[],m=q({inputs:{x:s},backend:t,attrs:{shape:c}}),g=at({inputs:{x:m},backend:t,attrs:{perm:u}}),y=q({inputs:{x:g},backend:t,attrs:{shape:l}}),x=rs({inputs:{x:y},backend:t,attrs:{begin:h,size:p}});return d.push(m),d.push(g),d.push(y),d.forEach(w=>t.disposeIntermediateTensorInfo(w)),x},pP={kernelName:tp,backendName:"webgl",kernelFunc:hP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dP(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:i}=r,a=t.readSync(s.dataId),c=t.readSync(o.dataId),u=Fy(a,c,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}const fP={kernelName:np,backendName:"webgl",kernelFunc:dP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mP(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,o=t.readSync(r.dataId),i=t.readSync(s.dataId),a=me(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const gP={kernelName:rp,backendName:"webgl",kernelFunc:mP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP="return float(a != b);",Yy=Xe({opSnippet:yP,cpuKernelImpl:qO,dtype:"bool"}),xP={kernelName:xd,backendName:"webgl",kernelFunc:Yy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return yt({inputs:{x:s.complexTensorInfos.real},backend:t})}const bP={kernelName:Od,backendName:"webgl",kernelFunc:Ks};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP="return float(int(x));";function wP(n,e){const t=new xn(n.shape,vP),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qa(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return yt({inputs:{x:s},backend:t});const i=Vn(s.shape),a=qa({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),c=Hn({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),c}if(s.dtype==="complex64"){const i=Ks({inputs:{input:s},backend:t}),a=qa({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(i),a}if(!o1(s.dtype,o)){const i=yt({inputs:{x:s},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId).values,[a,c,u]=NO(i,s.shape,s.dtype,o);return t.makeTensorInfo(a,c,u)}if(o==="int32")return wP(s,t);if(o==="bool"){const i=t.makeTensorInfo([],"bool",Cn("bool",1)),c=Yy({inputs:{a:s,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),c}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const CP={kernelName:hc,backendName:"webgl",kernelFunc:qa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ph="return ceil(x);",SP=pe({opSnippet:ph,packedOpSnippet:ph,cpuKernelImpl:IO}),TP={kernelName:sp,backendName:"webgl",kernelFunc:SP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $P{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EP{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kP(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;M().getBool("WEBGL_PACK_CLIP")?a=new EP(s.shape):a=new $P(s.shape);const c=[[o],[i]];return t.runWebGLProgram(a,[s],s.dtype,c)}const NP={kernelName:op,backendName:"webgl",kernelFunc:kP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IP{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dh(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function _P(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),o=new IP(r.shape),i=[dh(r,s.complexTensorInfos.real),dh(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}const RP={kernelName:ap,backendName:"webgl",kernelFunc:_P};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OP{constructor(e){this.outputShape=[],this.outputShape=hr(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const a=t[i-1];r.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const s=t.length,o=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AP{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=hr(e,t);const r=this.outputShape,s=r.length,o=ke(s),i=it("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((g,y)=>`T${y}`);const c=new Array(e.length-1);c[0]=e[0][t];for(let g=1;g<c.length;g++)c[g]=c[g-1]+e[g][t];const u=a[t],l=a.slice(-2),h=a.join();let p=`if (${u} < ${c[0]}) {
        return getChannel(
            getT0(${h}), vec2(${l.join()}));
        }`;for(let g=1;g<c.length;g++){const y=c[g-1];p+=`
        if (${u} < ${c[g]}  && ${u} >= ${c[g-1]}) {
          return getChannel(
            getT${g}(${ho(a,u,y)}),
            vec2(${ho(l,u,y)}));
        }`}const d=c.length,m=c[c.length-1];p+=`
        return getChannel(
          getT${d}(${ho(a,u,m)}),
          vec2(${ho(l,u,m)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function ho(n,e,t){const r=n.indexOf(e);return n.map((o,i)=>i===r?`${o} - ${t}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fi(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return yt({inputs:{x:s.complexTensorInfos.imag},backend:t})}const DP={kernelName:jp,backendName:"webgl",kernelFunc:fi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bs(n,e,t){const r=n[0].dtype;if(r==="complex64"){const h=n.map(y=>Ks({inputs:{input:y},backend:t})),p=n.map(y=>fi({inputs:{input:y},backend:t})),d=bs(h,e,t),m=bs(p,e,t),g=Hn({inputs:{real:d,imag:m},backend:t});return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),p.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),g}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const h=n.map(w=>{const S=G(w.shape.slice(e));return q({inputs:{x:w},backend:t,attrs:{shape:[-1,S]}})}),p=h.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),d=hr(h.map(w=>w.shape),1),m=h[0].shape[0]===1,g=_O(p,d,r,m),y=hr(n.map(w=>w.shape),e),x=t.makeTensorInfo(y,r,g);return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const o=M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(n.length>o){const h=[];for(let d=0;d<n.length;d+=o){const m=n.slice(d,d+o);h.push(bs(m,e,t))}const p=bs(h,e,t);for(const d of h)t.disposeIntermediateTensorInfo(d);return p}if(M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const h=new AP(n.map(p=>p.shape),e);return t.runWebGLProgram(h,n,r)}const{tensors2D:i,outShape:a}=PP(n,e,t),c=new OP(i.map(h=>h.shape)),u=t.runWebGLProgram(c,i,r);i.forEach(h=>t.disposeIntermediateTensorInfo(h));const l=q({inputs:{x:u},attrs:{shape:a},backend:t});return t.disposeIntermediateTensorInfo(u),l}function PP(n,e,t){const r=hr(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>q({inputs:{x:o},attrs:{shape:[-1,G(o.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qy(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,o=je(s,e[0].shape)[0],i=e.map(u=>u.shape);yg(i,o);const a=hr(e.map(u=>u.shape),o);if(G(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const c=e.filter(u=>G(u.shape)>0);return c.length===1?yt({inputs:{x:c[0]},backend:t}):bs(c,o,t)}const FP={kernelName:cp,backendName:"webgl",kernelFunc:Qy};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zy{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,c=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,h=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,m=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,y=e.dataFormat==="channelsLast",x=y?1:2,w=y?2:3,S=y?3:1;let $="",N="";r&&(s?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:$=`
          float activation(float x) {
            ${r}
          }
        `,N="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${c}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${N}
        setOutput(result);
      }
    `}}class LP{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,h=e.filterDepth,p=e.filterHeight,d=e.filterWidth,m=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jy{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ut(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,l=e.filterWidth,h=l;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<l;y++)p+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;p+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<l;y++)p+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(h+1)/2;y++){const x=y*2;if(p+=`
           xC = xCCorner + ${x*c};
           `,a===1){if(x<l&&(i%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,c===1&&x>0?p+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<l)){const w=i%2===0?ac(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,c>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:p+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):w===1?p+=`
                     xC${x+1} = xTexelC${x};
                     `:p+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<l&&(i%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<l&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<l&&(p+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<l&&(p+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<l&&(p+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let d="",m="";r&&(s?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:o?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${m}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ut(this.outputShape.length);const{dataFormat:r}=t,s=ct(),o=r==="channelsLast",i=o?1:2,a=o?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let l=0;l<=1;l++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${l};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${l*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ho(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function ex({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const c=n.shape,u=r.texData.get(n.dataId),l=t.inChannels,h=c[0]*c[1]*c[2],p=t.outChannels,d=t.dataFormat==="channelsLast",m=!1,g=!1;let y;const x=[];if(o!=null){const $=Ho(o.shape,d);$!=null&&(o=q({inputs:{x:o},backend:r,attrs:{shape:$}}),x.push(o))}if(s!=null){const $=Ho(s.shape,d);$!=null&&(s=q({inputs:{x:s},backend:r,attrs:{shape:$}}),x.push(s))}if(!((h===1||p===1)&&l>Hy)&&u.isPacked&&d&&u.texture!=null&&c[2]%2!==0&&Me(u.shape.slice(-3),c.slice(-3))){const $=c[0]*c[1]*(c[2]+1),N={dataId:n.dataId,shape:[1,$,t.inChannels],dtype:n.dtype},_=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,k(Wo(u.shape,N.shape),()=>`packed reshape ${u.shape} to ${N.shape} isn't free`);const O=q({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push(O);const D=jo({a:N,b:O,backend:r,transposeA:m,transposeB:g,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),F=r.texData.get(D.dataId);k(F.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=_,F.shape=t.outShape,y=yt({inputs:{x:D},backend:r}),y.shape=t.outShape,x.push(D)}else{const $=t.outHeight*t.outWidth,N=q({inputs:{x:n},backend:r,attrs:{shape:d?[t.batchSize,$,t.inChannels]:[t.batchSize,t.inChannels,$]}}),_=q({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),O=jo({a:d?N:_,b:d?_:N,transposeA:!d,transposeB:g,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});y=q({inputs:{x:O},backend:r,attrs:{shape:t.outShape}}),x.push(N),x.push(_),x.push(O)}for(const $ of x)r.disposeIntermediateTensorInfo($);return y}function tx({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:c,filterHeight:u,inChannels:l,outWidth:h,outHeight:p,dataFormat:d}=t,m=d==="channelsLast",g=c*u*l,y=p*h,x=[t.batchSize,g,y],w=!0,S=!1,$=[];if(o!=null){const be=Ho(o.shape,m);be!=null&&(o=q({inputs:{x:o},backend:r,attrs:{shape:be}}),$.push(o))}if(s!=null){const be=Ho(s.shape,m);be!=null&&(s=q({inputs:{x:s},backend:r,attrs:{shape:be}}),$.push(s))}const N=q({inputs:{x:e},backend:r,attrs:{shape:[1,g,G(e.shape)/g]}});$.push(N);const _=new MP(x,t),O=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],D=r.runWebGLProgram(_,[n],"float32",O),F=q({inputs:{x:D},backend:r,attrs:{shape:x}});$.push(D),$.push(F);const L=s!=null,z=o!=null,j=a==="leakyrelu",K=a?Ps(a,!0):null,Y=new jy(m?F.shape:N.shape,m?N.shape:F.shape,m?[t.batchSize,y,t.outChannels]:[t.batchSize,t.outChannels,y],w,S,L,K,z,j),te=m?[F,N]:[N,F];if(s&&te.push(s),z&&te.push(o),j){const be=r.makeTensorInfo([],"float32",qr(i,"float32"));te.push(be),$.push(be)}const re=r.runWebGLProgram(Y,te,"float32"),ae=q({inputs:{x:re},backend:r,attrs:{shape:t.outShape}});$.push(re);for(const be of $)r.disposeIntermediateTensorInfo(be);return ae}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BP(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:c,dilations:u,dimRoundingMode:l}=r,h=Xr(c),p=$t(s.shape,o.shape,i,u,a,l,!1,h);let d;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))d=ex({x:s,filter:o,convInfo:p,backend:t});else if(p.strideWidth<=2&&h==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){const g=new Jy(p),y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];d=t.runWebGLProgram(g,[s,o],"float32",y)}else if(M().getBool("WEBGL_CONV_IM2COL"))d=tx({x:s,filter:o,convInfo:p,backend:t});else{const g=new Zy(p);d=t.runWebGLProgram(g,[s,o],"float32")}const m=q({inputs:{x:d},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(d),m}const VP={kernelName:up,backendName:"webgl",kernelFunc:BP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,c=r-1-e.padInfo.left,u=i?1:2,l=i?2:3,h=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class WP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class GP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=t-1-e.padInfo.front,u=r-1-e.padInfo.top,l=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${u}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jP(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:c,dimRoundingMode:u,filterShape:l}=r,h=Xr(c),p=$t(s.shape,l,i,1,a,u,!1,h),d=new UP(p);return t.runWebGLProgram(d,[s,o],"float32")}const HP={kernelName:lp,backendName:"webgl",kernelFunc:jP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KP(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:c,dataFormat:u,dimRoundingMode:l}=r,h=Xr(u),p=$t(i,o.shape,a,1,c,l,!1,h),d=new zP(p);return t.runWebGLProgram(d,[s,o],"float32")}const qP={kernelName:hp,backendName:"webgl",kernelFunc:KP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XP(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:c}=r,u=Vs(s.shape,o.shape,i,c,a),l=new LP(u);return t.runWebGLProgram(l,[s,o],"float32")}const YP={kernelName:pp,backendName:"webgl",kernelFunc:XP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:c}=r,u=Vs(s.shape,c,i,1,a),l=new WP(u);return t.runWebGLProgram(l,[s,o],"float32")}const ZP={kernelName:y1,backendName:"webgl",kernelFunc:QP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JP(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{pad:i,strides:a,inputShape:c}=r,u=Vs(c,o.shape,a,1,i),l=new GP(u);return t.runWebGLProgram(l,[s,o],"float32")}const eF={kernelName:dp,backendName:"webgl",kernelFunc:JP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tF=ns+`
  return cos(x);
`,nF=pe({opSnippet:tF}),rF={kernelName:fp,backendName:"webgl",kernelFunc:nF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sF=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,oF=pe({opSnippet:sF}),iF={kernelName:mp,backendName:"webgl",kernelFunc:oF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aF{constructor(e,t,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,c,u]=e,[l]=t,[h,p]=r;this.outputShape=[l,h,p,u];const d=s==="bilinear"?1:0,[m,g]=[`${a-1}.0`,`${c-1}.0`],[y,x,w]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[S,$,N]=p>1?[`${(c-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${$};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:c,extrapolationValue:u}=r,l=new aF(s.shape,o.shape,a,c,u);return t.runWebGLProgram(l,[s,o,i],"float32")},uF={kernelName:xp,backendName:"webgl",kernelFunc:cF};var Ls;(function(n){n.Prod="*",n.Sum="+"})(Ls||(Ls={}));class fh{constructor(e,t,r,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===Ls.Prod?"1.0":"0.0",a=r?i:`getX(${mh(o,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let u="",l="";r?(u=s?`end != ${c-1}`:"end != 0",l=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${c}`:"end >= pow2",l=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ke(o)} coords = getOutputCoords();
        int end = ${gh(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${l};
          ${gh(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${mh(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function mh(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function gh(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nx(n,e,t,r,s,o){const i=e.shape.length,a=Gt([r],i);let c=e;a!=null&&(c=at({inputs:{x:e},backend:t,attrs:{perm:a}}));const u=jt(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const l=c.shape[u];let h=yt({inputs:{x:c},backend:t});for(let p=0;p<=Math.ceil(Math.log2(l))-1;p++){const d=new fh(n,c.shape,!1,o),m=[[p]],g=h;h=t.runWebGLProgram(d,[h],h.dtype,m),t.disposeIntermediateTensorInfo(g)}if(s){const p=new fh(n,c.shape,s,o),d=h;h=t.runWebGLProgram(p,[h],h.dtype),t.disposeIntermediateTensorInfo(d)}if(a!=null){const p=_c(a),d=at({inputs:{x:h},backend:t,attrs:{perm:p}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(c),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return nx(Ls.Prod,s,t,o,i,a)}const hF={kernelName:gp,backendName:"webgl",kernelFunc:lF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return nx(Ls.Sum,s,t,o,i,a)}const dF={kernelName:yp,backendName:"webgl",kernelFunc:pF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r;if(s.shape.length===1){const c=t.readSync(s.dataId),u=t.readSync(o.dataId),l=Fy(c,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,l)}else if(s.shape.length===2){const c=t.bufferSync(s),u=t.bufferSync(o),l=kO(c,u,i,a);return t.makeTensorInfo(l.shape,o.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const mF={kernelName:bp,backendName:"webgl",kernelFunc:fF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gF{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],c=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],l=i==="NHWC"?s.shape[3]:s.shape[1],h=c*o,p=u*o,d=l/(o*o),m=i==="NHWC"?[a,h,p,d]:[a,d,h,p],g=new gF(m,o,i);return t.runWebGLProgram(g,[s],s.dtype)}const xF={kernelName:vp,backendName:"webgl",kernelFunc:yF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rx{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ut(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,c=e.outChannels/e.inChannels;let u="",l="";r&&(s?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,l="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sx{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ut(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,c=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,h=e.filterWidth,p=h;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<h;x++)d+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;d+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let x=0;x<h;x++)d+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(p+1)/2;x++){const w=x*2;if(d+=`
          xC = xCCorner + ${w*u};
          `,c===1){if(w<h&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,u===1&&w>0?d+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<h)){const S=a%2===0?ac(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,u>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:d+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):S===1?d+=`
                    xC${w+1} = xTexelC${w};
                    `:d+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<h&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<h&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<h&&(d+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<h&&(d+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<h&&(d+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let m="",g="";r&&(s?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:m=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:c,dimRoundingMode:u}=r;let l=c;l==null&&(l=[1,1]),k(bt(i,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const h=$t(s.shape,o.shape,i,l,a,u,!0);let p;M().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?p=new sx(h):p=new rx(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(p,[s,o],"float32",d)}const vF={kernelName:wp,backendName:"webgl",kernelFunc:bF};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wF{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class CF{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.top,a=r-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:u,filterShape:l}=r,h=$t(s.shape,l,i,a,c,u,!0),p=new wF(h);return t.runWebGLProgram(p,[s,o],"float32")}const TF={kernelName:Cp,backendName:"webgl",kernelFunc:SF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $F(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:u,inputShape:l}=r,h=$t(l,o.shape,i,a,c,u,!0),p=new CF(h);return t.runWebGLProgram(p,[s,o],"float32")}const EF={kernelName:Sp,backendName:"webgl",kernelFunc:$F};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kF{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NF(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],o=G(r.shape),i=q({inputs:{x:r},backend:t,attrs:{shape:[o]}}),a=new kF(o),c=t.runWebGLProgram(a,[i],i.dtype),u=q({inputs:{x:c},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),u}const IF={kernelName:Tp,backendName:"webgl",kernelFunc:NF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _F{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:c,dilationHeight:u,dilationWidth:l}=e,{top:h,left:p}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${h}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:c}=r,u=Tm(s.shape,o.shape,i,a,"NHWC",c);let l;const h=new _F(u);l=t.runWebGLProgram(h,[s,o],"float32");const p=q({inputs:{x:l},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(l),p}const OF={kernelName:$p,backendName:"webgl",kernelFunc:RF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:c}=Ag(s,o.length);Pg(i.length,c,o);const{path:u,steps:l}=Fg(a,c),h=l.length;let p=null,d=i.length;const m=[];for(let g=0;g<h;++g){for(const y of l[g]){const{permutationIndices:x,expandDims:w}=Dg(d,c[y]);let S;Lg(x)?S=o[y]:(S=at({inputs:{x:o[y]},backend:t,attrs:{perm:x}}),m.push(S));const $=S.shape.slice();for(let N=0;N<w.length;++N)$.splice(w[N],0,1);Me(S.shape,$)||(S=q({inputs:{x:S},backend:t,attrs:{shape:$}}),m.push(S)),p===null?p=S:(p=Jc({inputs:{a:S,b:p},backend:t}),m.push(p))}g<h-1&&(u[g]>=0&&(p=di({inputs:{x:p},backend:t,attrs:{axis:u[g]-(i.length-d),keepDims:!1}}),m.push(p)),d--)}for(const g of m)g!==p&&t.disposeIntermediateTensorInfo(g);return p}const DF={kernelName:kp,backendName:"webgl",kernelFunc:AF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PF="return (x >= 0.0) ? x : (exp(x) - 1.0);",FF=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,LF=pe({opSnippet:PF,packedOpSnippet:FF}),MF={kernelName:Np,backendName:"webgl",kernelFunc:LF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BF="return (b >= 1.0) ? a : a * (b + 1.0);",VF=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,UF=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,o=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hs(VF,r.shape,s.shape):new Hr(BF,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],r.dtype)},zF={kernelName:x1,backendName:"webgl",kernelFunc:UF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WF=`
  return vec4(equal(a, b));
`,GF="return float(a == b);",jF=Xe({opSnippet:GF,packedOpSnippet:WF,dtype:"bool",cpuKernelImpl:RO}),HF={kernelName:_p,backendName:"webgl",kernelFunc:jF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KF=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${kg};
  float a1 = ${Ng};
  float a2 = ${Ig};
  float a3 = ${_g};
  float a4 = ${Rg};
  float a5 = ${Og};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,qF=pe({opSnippet:KF}),XF={kernelName:Ip,backendName:"webgl",kernelFunc:qF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YF=ns+`
  return exp(x);
`,QF=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ox=pe({opSnippet:YF,packedOpSnippet:QF,cpuKernelImpl:OO,dtype:"float32"}),ZF={kernelName:Rp,backendName:"webgl",kernelFunc:ox};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:o}=e,i=o.shape.length,a=o.shape.slice();let c=s;return s<0&&(k(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),c=i+s+1),a.splice(c,0,1),q({inputs:{x:o},backend:r,attrs:{shape:a}})}const JF={kernelName:Op,backendName:"webgl",kernelFunc:Xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yh="return exp(x) - 1.0;",e3=pe({opSnippet:yh,packedOpSnippet:yh,cpuKernelImpl:AO}),t3={kernelName:Ap,backendName:"webgl",kernelFunc:e3};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xh{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ix(n,e,t){const r=t.texData.get(n.dataId),s=G(n.shape),o=n.shape[n.shape.length-1],i=s/o,a=q({inputs:{x:n},backend:t,attrs:{shape:[i,o]}}),c=a.shape,u=new xh("real",c,e),l=new xh("imag",c,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],p=t.runWebGLProgram(u,h,"float32"),d=t.runWebGLProgram(l,h,"float32"),m=Hn({inputs:{real:p,imag:d},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d);const g=q({inputs:{x:m},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(m),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3(n){const{inputs:e,backend:t}=n,{input:r}=e;return ix(r,!1,t)}const r3={kernelName:Dp,backendName:"webgl",kernelFunc:n3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s3{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:o}=t;if(o=o||Xo(s),o==="string"){const i=pt(o,G(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new s3(r,s),a=[[s]];return e.runWebGLProgram(i,[],o,a)}}const o3={kernelName:Pp,backendName:"webgl",kernelFunc:qs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i3{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3={kernelName:Fp,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new i3(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bh="return floor(x);",c3=pe({opSnippet:bh,packedOpSnippet:bh,cpuKernelImpl:DO}),u3={kernelName:Lp,backendName:"webgl",kernelFunc:c3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l3=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,h3=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,p3=Xe({opSnippet:l3,packedOpSnippet:h3,dtype:"int32"}),d3={kernelName:Mp,backendName:"webgl",kernelFunc:p3};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f3{constructor(e){this.variableNames=["A"];const t=ct(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m3{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ct(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g3={kernelName:ra,backendName:"webgl",kernelFunc:y3};let $r,Yi=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function y3(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[c,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],l=[u,c],h=[u,c,o];if(a||i){const g=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");($r==null||g!==Yi)&&(Yi=g,$r=document.createElement("canvas").getContext("2d",{willReadFrequently:Yi})),$r.canvas.width=c,$r.canvas.height=u,$r.drawImage(s,0,0,c,u),s=$r.canvas}const p=t.makeTensorInfo(l,"int32");t.texData.get(p.dataId).usage=St.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),s);const d=M().getBool("WEBGL_PACK")?new m3(h):new f3(h),m=t.runWebGLProgram(d,[p],"int32");return t.disposeData(p.dataId),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:c,pad:u,dataFormat:l,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:m}=r,g=Xr(l),y=$t(s.shape,o.shape,c,h,u,p,!1,g);let x;const w=[],S=i!=null,$=a!=null,N=d==="leakyrelu",_=()=>{const D=[s,o],F=(L,z)=>{if(z==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){const j=q({inputs:{x:L},backend:t,attrs:{shape:[L.shape[0],1,1]}});return w.push(j),j}return L};if(S&&D.push(F(i,l)),$&&D.push(F(a,l)),N){const L=t.makeTensorInfo([],"float32",qr(m,"float32"));D.push(L),w.push(L)}return D};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))x=ex({x:s,filter:o,convInfo:y,backend:t,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:m});else if(y.strideWidth<=2&&g==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){const D=d?Ps(d,!0):null,F=new Jy(y,S,D,$,N),L=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],z=_();x=t.runWebGLProgram(F,z,"float32",L)}else if(M().getBool("WEBGL_CONV_IM2COL"))x=tx({x:s,filter:o,convInfo:y,backend:t,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:m});else{const D=d?Ps(d,!1):null,F=new Zy(y,S,D,$,N),L=_();x=t.runWebGLProgram(F,L,"float32")}const O=q({inputs:{x},backend:t,attrs:{shape:y.outShape}});return w.push(x),w.forEach(D=>t.disposeIntermediateTensorInfo(D)),O}const b3={kernelName:oa,backendName:"webgl",kernelFunc:x3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:c,pad:u,dilations:l,dimRoundingMode:h,activation:p,leakyreluAlpha:d}=r,m=[];let g=l;g==null&&(g=[1,1]),k(bt(c,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${g}'`);const y=$t(s.shape,o.shape,c,g,u,h,!0),x=M().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,w=p?Ps(p,x):null,S=[s,o],$=i!=null,N=a!=null,_=p==="leakyrelu";if($&&S.push(i),N&&S.push(a),_){const L=t.makeTensorInfo([],"float32",qr(d,"float32"));S.push(L),m.push(L)}let O;x?O=new sx(y,$,w,N,_):O=new rx(y,$,w,N,_);const D=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],F=t.runWebGLProgram(O,S,"float32",D);return m.forEach(L=>t.disposeIntermediateTensorInfo(L)),F}const w3={kernelName:ia,backendName:"webgl",kernelFunc:v3};class C3{constructor(e,t,r,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=ke(r.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=G(r.shape),[c,u,l,h]=am(r,s),p=q({inputs:{x:s},backend:t,attrs:{shape:[u,i]}}),d=q({inputs:{x:r},backend:t,attrs:{shape:[G(r.shape)/l,l]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const x=t.readSync(s.dataId),w=t.bufferSync(r),S=PO(x,w,r.dtype,u,i,l,h,r.shape,a);return t.makeTensorInfo(c,r.dtype,S.values)}const m=new C3(i,h,[u,l],r.shape),g=t.runWebGLProgram(m,[d,p],d.dtype),y=q({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),y}const T3={kernelName:Up,backendName:"webgl",kernelFunc:S3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $3{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=ke(this.rank),s=E3(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function E3(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ax(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,c=je(i,s.shape)[0];if(M().get("DEBUG")){const w=t.readSync(o.dataId),S=s.shape[c];for(let $=0;$<w.length;++$){const N=w[$];k(N<=S-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${S-1}]`)}}const u=Zg(s,o,c,a),l=G(o.shape),h=[],p=q({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=q({inputs:{x:o},backend:t,attrs:{shape:[u.batchSize,l/u.batchSize]}});h.push(p),h.push(d);const m=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const w=t.bufferSync(d),S=t.bufferSync(p),$=FO(S,w,m);return h.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.makeTensorInfo(u.outputShape,$.dtype,$.values)}const g=new $3(p.shape,m),y=t.runWebGLProgram(g,[p,d],p.dtype);h.push(y);const x=q({inputs:{x:y},backend:t,attrs:{shape:u.outputShape}});return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const k3={kernelName:Vp,backendName:"webgl",kernelFunc:ax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N3="return float(a > b);",I3=`
  return vec4(greaterThan(a, b));
`,_3=Xe({opSnippet:N3,packedOpSnippet:I3,cpuKernelImpl:LO,dtype:"bool"}),R3={kernelName:zp,backendName:"webgl",kernelFunc:_3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O3="return float(a >= b);",A3=`
  return vec4(greaterThanEqual(a, b));
`,D3=Xe({opSnippet:O3,packedOpSnippet:A3,dtype:"bool",cpuKernelImpl:MO}),P3={kernelName:Wp,backendName:"webgl",kernelFunc:D3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F3(n){const{inputs:e,backend:t}=n,{input:r}=e;return ix(r,!0,t)}const L3={kernelName:Gp,backendName:"webgl",kernelFunc:F3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M3="return float(!isnan(x) && !isinf(x));",B3=pe({opSnippet:M3,dtype:"bool"}),V3={kernelName:Hp,backendName:"webgl",kernelFunc:B3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3="return float(isinf(x));",z3=pe({opSnippet:U3,dtype:"bool"}),W3={kernelName:Kp,backendName:"webgl",kernelFunc:z3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G3="return float(isnan(x));",j3=pe({opSnippet:G3,dtype:"bool"}),H3={kernelName:qp,backendName:"webgl",kernelFunc:j3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K3="return float(a < b);",q3=`
  return vec4(lessThan(a, b));
`,X3=Xe({opSnippet:K3,packedOpSnippet:q3,cpuKernelImpl:BO,dtype:"bool"}),Y3={kernelName:Yp,backendName:"webgl",kernelFunc:X3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q3="return float(a <= b);",Z3=`
  return vec4(lessThanEqual(a, b));
`,J3=Xe({opSnippet:Q3,packedOpSnippet:Z3,cpuKernelImpl:VO,dtype:"bool"}),eL={kernelName:Qp,backendName:"webgl",kernelFunc:J3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tL(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:o}=t,i=UO(r,s,o);return e.makeTensorInfo([i.length],"float32",i)}const nL={kernelName:Zp,backendName:"webgl",kernelFunc:tL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rL=ns+`
  return x < 0.0 ? 0./0. : log(x);
`,sL=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,oL=pe({opSnippet:rL,packedOpSnippet:sL,cpuKernelImpl:zO}),iL={kernelName:Jp,backendName:"webgl",kernelFunc:oL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aL=ns+`
  return log(1.0 + x);
`,cL=pe({opSnippet:aL}),uL={kernelName:ed,backendName:"webgl",kernelFunc:cL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lL="return float(a >= 1.0 && b >= 1.0);",hL=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,pL=Xe({opSnippet:lL,packedOpSnippet:hL,dtype:"bool"}),dL={kernelName:td,backendName:"webgl",kernelFunc:pL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fL="return float(!(x >= 1.0));",mL=pe({opSnippet:fL}),gL={kernelName:nd,backendName:"webgl",kernelFunc:mL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yL="return float(a >= 1.0 || b >= 1.0);",xL=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,bL=Xe({opSnippet:yL,packedOpSnippet:xL,dtype:"bool"}),vL={kernelName:rd,backendName:"webgl",kernelFunc:bL};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wL{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=t,a=e[3]-1;this.outputShape=e;let c;const u=`float(${r}) + float(${s}) * sum`;o===.5?c=`inversesqrt(${u})`:o===1?c=`1.0/(${u})`:c=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CL{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=e[3]-1;this.outputShape=e;let c;const u=`float(${r}) + float(${s}) * sum`;o===.5?c=`inversesqrt(${u})`:o===1?c=`1.0/(${u})`:c=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SL=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:c}=r,u=M().getBool("WEBGL_PACK_NORMALIZATION")?new CL(s.shape,o,i,a,c):new wL(s.shape,o,i,a,c);return t.runWebGLProgram(u,[s],s.dtype)},TL={kernelName:sd,backendName:"webgl",kernelFunc:SL};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $L{constructor(e,t,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EL=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:c,alpha:u,beta:l}=r,h=new $L(s.shape,a,c,u,l);return t.runWebGLProgram(h,[s,o,i],s.dtype)},kL={kernelName:b1,backendName:"webgl",kernelFunc:EL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NL(n,e,t,r){const s=G(e),i=G(n.shape)/s,a=q({inputs:{x:n},attrs:{shape:[i,s]},backend:r}),c=br(a,n.dtype,"max",r),u=q({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,c=je(o,s.shape);let u=c;const l=Gt(u,a),h=l!=null,p=t.shouldExecuteOnCPU([s]);let d=s;if(h){if(p){const S=t.texData.get(d.dataId).values,$=new Array(a);for(let O=0;O<$.length;O++)$[O]=s.shape[l[O]];const N=Qc(S,s.shape,s.dtype,l,$);d=t.makeTensorInfo($,s.dtype);const _=t.texData.get(d.dataId);_.values=N}else d=pi(s,l,t);u=jt(u.length,a)}nn("max",u,a);const[m,g]=fn(d.shape,u);let y=m;i&&(y=Et(m,c));let x;if(p){const S=t.texData.get(d.dataId).values,$=WO(S,G(g),y,s.dtype);x=t.makeTensorInfo(y,s.dtype);const N=t.texData.get(x.dataId);N.values=$}else x=NL(d,g,y,t);return h&&t.disposeIntermediateTensorInfo(d),x}const IL={kernelName:od,backendName:"webgl",kernelFunc:cx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _L=Zc+`
  return max(a, b);
`,RL=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,OL=Xe({opSnippet:_L,packedOpSnippet:RL,cpuKernelImpl:GO}),AL={kernelName:id,backendName:"webgl",kernelFunc:OL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Ws(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:c}=r,u=1;k(bt(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const l=fr(s.shape,o,i,u,a,c);if(l.filterWidth===1&&l.filterHeight===1&&Me(l.inShape,l.outShape))return yt({inputs:{x:s},backend:t});const h=new Fs(l,"max",!1);return t.runWebGLProgram(h,[s],s.dtype)}const PL={kernelName:ad,backendName:"webgl",kernelFunc:DL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:c,dimRoundingMode:u}=r,l=[1,1,1],h=Bs(s.shape,o,i,l,a,u,c),p=new eu(h,"max",!1);return t.runWebGLProgram(p,[s],s.dtype)}const LL={kernelName:cd,backendName:"webgl",kernelFunc:FL};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ML{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,c=i-1-e.padInfo.left,u=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class BL{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,h=c-1-e.padInfo.front,p=u-1-e.padInfo.top,d=l-1-e.padInfo.left,m=c*u*l-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${p}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VL(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o,{filterSize:a,strides:c,pad:u,dimRoundingMode:l}=r,h=[1,1,1],p=Bs(i.shape,a,c,h,u,l),d=new eu(p,"max",!0),m=t.runWebGLProgram(d,[i],i.dtype),g=new BL(p),y=t.runWebGLProgram(g,[s,m],i.dtype);return t.disposeIntermediateTensorInfo(m),y}const UL={kernelName:w1,backendName:"webgl",kernelFunc:VL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o,output:i}=e,a=o;Ws([o,i],"maxPoolGrad");const{filterSize:c,strides:u,pad:l,dimRoundingMode:h}=r,p=fr(a.shape,c,u,1,l,h),d=!0,m=new Fs(p,"max",d),g=t.runWebGLProgram(m,[a],a.dtype),y=new ML(p),x=t.runWebGLProgram(y,[s,g],a.dtype);return t.disposeIntermediateTensorInfo(g),x}const WL={kernelName:v1,backendName:"webgl",kernelFunc:zL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n,e,t,r){let s=new Fs(t,"max",!1);const o=r.runWebGLProgram(s,[n],"float32");s=new Fs(t,"max",!0,!0,e);const i=r.runWebGLProgram(s,[n],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jL={kernelName:ud,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=e,c=t;k(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];k(bt(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const l=fr(r.shape,s,o,u,i),[h,p]=GL(r,a,l,c);return[h,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HL(n,e,t,r){const s=G(e),i=G(n.shape)/s,a=q({inputs:{x:n},attrs:{shape:[i,s]},backend:r}),c=br(a,"float32","mean",r),u=q({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KL={kernelName:ld,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:o}=e,i=t,a=r.shape.length,c=je(o,r.shape);let u=c;const l=Gt(u,a),h=l!=null,p=i.shouldExecuteOnCPU([r]),d=[];let m=r;if(h){if(p){const $=i.texData.get(m.dataId).values,N=new Array(a);for(let D=0;D<N.length;D++)N[D]=r.shape[l[D]];const _=Qc($,r.shape,r.dtype,l,N);m=i.makeTensorInfo(N,r.dtype);const O=i.texData.get(m.dataId);O.values=_}else m=pi(r,l,i);d.push(m),u=jt(u.length,a)}nn("sum",u,a);const[g,y]=fn(m.shape,u);let x=g;s&&(x=Et(g,c));const w=HL(m,y,x,i);for(const S of d)i.disposeIntermediateTensorInfo(S);return w}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,c=je(o,s.shape);let u=c;const l=Gt(u,a);let h=s;l!=null&&(h=at({inputs:{x:s},backend:t,attrs:{perm:l}}),u=jt(u.length,s.shape.length)),nn("min",u,a);const[p,d]=fn(h.shape,u),m=G(d),g=q({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),y=br(g,g.dtype,"min",t);let x;if(i){const w=Et(p,c);x=q({inputs:{x:y},backend:t,attrs:{shape:w}})}else x=q({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),l!=null&&t.disposeIntermediateTensorInfo(h),x}const XL={kernelName:hd,backendName:"webgl",kernelFunc:qL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YL=Zc+`
  return min(a, b);
`,QL=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,ZL=Xe({opSnippet:YL,packedOpSnippet:QL,cpuKernelImpl:jO}),JL={kernelName:pd,backendName:"webgl",kernelFunc:ZL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eM{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((l,h)=>l[0]+e[h]+l[1]);const s=e.length,o=ke(s),i=t.map(l=>l[0]).join(","),a=t.map((l,h)=>l[0]+e[h]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tM{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const s=e.length,o=ke(s),i=t.map(m=>m[0]).join(","),a=t.map((m,g)=>m[0]+e[g]).join(","),c=it("rc",s),u=it("source",s),l=`${c[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${u.slice(-2).join()})`,p=r==="reflect"?0:1;let d="";if(s===1){const m=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${c[s-1]} += 1;
        if(${l}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const m=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${c[s-1]} += 1;
        if(${l}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${c[s-2]} += 1;
        if(${c[s-2]} < ${this.outputShape[s-2]}) {
          ${m}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${c[s-1]} += 1;
          if(${l}) {
            ${m}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nM=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:o}=t,i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tM(r.shape,s,o):new eM(r.shape,s,o);return e.runWebGLProgram(i,[r],r.dtype)},rM={kernelName:dd,backendName:"webgl",kernelFunc:nM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sM=`if (b == 0.0) return NAN;
  return mod(a, b);`,oM=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+js+`
  return result;
`,iM=Xe({opSnippet:sM,packedOpSnippet:oM}),aM={kernelName:fd,backendName:"webgl",kernelFunc:iM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cM{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uM=`
if (a == b) {
  return 1.0;
};
return a / b;`,lM=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,ux=Xe({opSnippet:uM,packedOpSnippet:lM,checkOutOfBounds:!0}),hM={kernelName:Ep,backendName:"webgl",kernelFunc:ux};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vh="return a - b;",lx=Xe({opSnippet:vh,packedOpSnippet:vh,supportsComplex:!0,cpuKernelImpl:lA}),pM={kernelName:ff,backendName:"webgl",kernelFunc:lx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hx(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:o}=r,i=je([o],s.shape),a=cx({inputs:{x:s},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),c=Et(a.shape,i),u=q({inputs:{x:a},backend:t,attrs:{shape:c}}),l=lx({inputs:{a:s,b:u},backend:t}),h=ox({inputs:{x:l},backend:t}),p=di({inputs:{x:h},backend:t,attrs:{axis:i,keepDims:!1}}),d=q({inputs:{x:p},backend:t,attrs:{shape:c}}),m=ux({inputs:{a:h,b:d},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),m}const dM={kernelName:nf,backendName:"webgl",kernelFunc:hx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fM(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,c=a?s:hx({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),u=c.shape[0],l=c.shape[1],h=new cM(u,l,o),p=[[i]],d=t.runWebGLProgram(h,[c],"int32",p);return a||t.disposeIntermediateTensorInfo(c),d}const mM={kernelName:md,backendName:"webgl",kernelFunc:fM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gM=Ht+`
  return -x;
`,yM=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function xM(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId),[i,a]=KO(o.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,i)}let s;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new rr(r.shape,yM):s=new xn(r.shape,gM),t.runWebGLProgram(s,[r],r.dtype)}const bM={kernelName:yd,backendName:"webgl",kernelFunc:xM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM=fg;function wM(n){Jt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c}=r,u=t.readSync(s.dataId),l=t.readSync(o.dataId),{selectedIndices:h}=vM(u,l,i,a,c);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const CM={kernelName:bd,backendName:"webgl",kernelFunc:wM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SM=mg;function TM(n){Jt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:u}=r,l=t.readSync(s.dataId),h=t.readSync(o.dataId),{selectedIndices:p,validOutputs:d}=SM(l,h,i,a,c,u);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const $M={kernelName:vd,backendName:"webgl",kernelFunc:TM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EM=gg;function kM(n){Jt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,softNmsSigma:u}=r,l=t.readSync(s.dataId),h=t.readSync(o.dataId),p=i,d=a,m=c,g=u,{selectedIndices:y,selectedScores:x}=EM(l,h,p,d,m,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const NM={kernelName:wd,backendName:"webgl",kernelFunc:kM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IM{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _M=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:c}=r,u=G(s.shape),l=new IM(u,i,a,c),h=q({inputs:{x:s},backend:t,attrs:{shape:[u]}}),p=t.runWebGLProgram(l,[h],o);t.disposeIntermediateTensorInfo(h);const d=[...s.shape,i],m=q({inputs:{x:p},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(p),m},RM={kernelName:Sd,backendName:"webgl",kernelFunc:_M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ko(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=Ks({inputs:{input:r},backend:t}),o=Ko({inputs:{x:s},backend:t}),i=fi({inputs:{input:r},backend:t}),a=Ko({inputs:{x:i},backend:t}),c=Hn({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return qs({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const OM={kernelName:Cf,backendName:"webgl",kernelFunc:Ko};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function px(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=Ks({inputs:{input:r},backend:t}),o=px({inputs:{x:s},backend:t}),i=fi({inputs:{input:r},backend:t}),a=Ko({inputs:{x:i},backend:t}),c=Hn({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return qs({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const AM={kernelName:Cd,backendName:"webgl",kernelFunc:px};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DM(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return Xa({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(l=>{Tt(o,l.shape,"All tensors passed to stack must have matching shapes"),k(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=e.map(l=>{const h=Xa({inputs:{input:l},backend:t,attrs:{dim:s}});return a.push(h),h}),u=Qy({inputs:c,backend:t,attrs:{axis:s}});return a.forEach(l=>t.disposeIntermediateTensorInfo(l)),u}const PM={kernelName:Td,backendName:"webgl",kernelFunc:DM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FM{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,l)=>u[0]+e[l]+u[1]);const s=e.length,o=ke(s),i=t.map(u=>u[0]).join(","),a=t.map((u,l)=>u[0]+e[l]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LM{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);const s=e.length,o=ke(s),i=t.map(g=>g[0]).join(","),a=t.map((g,y)=>g[0]+e[y]).join(","),c=it("rc",s),u=it("source",s),l=`${c[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${u.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${c[s-1]} += 1;
       if(${l}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${c[s-2]} += 1;
       if(${c[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${c[s-1]} += 1;
         if(${l}) {`],d=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let g=0,y=s===1?2:4;g<y;g++)m+=`
        ${p[g]}
        if (${d}) {
          result[${g}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${h});
        }
      `;m+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dx=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:o,constantValue:i}=r;if(G(s.shape)===0){const u=o.map((l,h)=>l[0]+s.shape[h]+l[1]);return qs({backend:t,attrs:{shape:u,value:i,dtype:s.dtype}})}const a=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new LM(s.shape,o,i):new FM(s.shape,o,i),c=[[i]];return t.runWebGLProgram(a,[s],s.dtype,c)},MM={kernelName:$d,backendName:"webgl",kernelFunc:dx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BM=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,VM=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+js+`
  return result;
`,UM=Xe({opSnippet:BM,packedOpSnippet:VM}),zM={kernelName:Ed,backendName:"webgl",kernelFunc:UM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WM(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,c=[],u=je(o,s.shape);let l=u;const h=Gt(l,a);let p=s;h!=null&&(p=at({inputs:{x:s},backend:t,attrs:{perm:h}}),l=jt(l.length,a),c.push(p)),nn("prod",l,a);let d;if(t.shouldExecuteOnCPU([p])){const m=t.texData.get(p.dataId).values,{outVals:g,outShape:y,outDtype:x}=XO(p.shape,p.dtype,m,l);d=t.makeTensorInfo(y,x,g)}else{const[m,g]=fn(p.shape,l),y=G(g),x=q({inputs:{x:p},backend:t,attrs:{shape:[-1,y]}}),w=mc(s.dtype),S=br(x,w,"prod",t);d=q({inputs:{x:S},backend:t,attrs:{shape:m}}),c.push(x),c.push(S)}if(i){c.push(d);const m=Et(d.shape,u);d=q({inputs:{x:d},backend:t,attrs:{shape:m}})}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),d}const GM={kernelName:Nd,backendName:"webgl",kernelFunc:WM};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jM(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=r,c=s.map(x=>t.readSync(x.dataId)),u=s.map(x=>x.shape),l=t.readSync(o.dataId),h=t.readSync(i.dataId),[p,d,m]=YO(c,u,l,o.shape,o.dtype,h,i.shape,a),g=p.map(x=>t.makeTensorInfo([x.length],"int32",x)),y=t.makeTensorInfo(m,o.dtype,d);return g.concat([y])}const HM={kernelName:Id,backendName:"webgl",kernelFunc:jM};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KM(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:c}=r,u=t.readSync(s.dataId),l=t.readSync(o.dataId),h=t.readSync(i.dataId),p=a.map(y=>t.readSync(y.dataId)),d=a.map(y=>y.shape),[m,g]=QO(u,s.shape,l,o.shape,o.dtype,h,i.shape,p,d,c);return t.makeTensorInfo(m,o.dtype,g)}const qM={kernelName:_d,backendName:"webgl",kernelFunc:KM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fx=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:o,dtype:i}=t,a=ZO(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},XM={kernelName:Rd,backendName:"webgl",kernelFunc:fx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YM="return 1.0 / x;",QM=pe({opSnippet:YM}),ZM={kernelName:Ad,backendName:"webgl",kernelFunc:QM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JM=Ht+`
  return (x < 0.0) ? 0.0 : x;
`,eB=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tB=pe({opSnippet:JM,packedOpSnippet:eB}),nB={kernelName:Dd,backendName:"webgl",kernelFunc:tB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rB=Ht+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,sB=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,oB=pe({opSnippet:rB,packedOpSnippet:sB}),iB={kernelName:Md,backendName:"webgl",kernelFunc:oB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aB{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,c,u]=e;this.outputShape=[i,t,r,u];const l=[s&&t>1?a-1:a,s&&r>1?c-1:c],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/h[0]},
          ${l[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cB{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,c,u]=e;this.outputShape=[i,t,r,u];const l=[s&&t>1?a-1:a,s&&r>1?c-1:c],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/h[0]},
          ${l[1]/h[1]},
          ${l[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[c,u]=a,l=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new cB(s.shape,c,u,o,i):new aB(s.shape,c,u,o,i);return t.runWebGLProgram(l,[s],"float32")}const lB={kernelName:Ld,backendName:"webgl",kernelFunc:uB};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hB{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,i,a]=e,c=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=c[0]/u[0],h=c[1]/u[1],p=1/l,d=1/h,m=Math.ceil(p)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pB(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:i}=r,a=new hB(o.shape,s.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const dB={kernelName:S1,backendName:"webgl",kernelFunc:pB};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fB{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,c,u]=e;this.outputShape=[i,t,r,u];const l=[s&&t>1?a-1:a,s&&r>1?c-1:c],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],p=s?"0.5":"0.0";let d;o?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/h[0]},
          ${l[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mB{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,c,u]=e;this.outputShape=[i,t,r,u];const l=[s&&t>1?a-1:a,s&&r>1?c-1:c],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],p=s?"0.5":"0.0";let d;o?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/h[0]},
          ${l[1]/h[1]},
          ${l[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[c,u]=a,l=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mB(s.shape,c,u,o,i):new fB(s.shape,c,u,o,i);return t.runWebGLProgram(l,[s],s.dtype)}const yB={kernelName:Fd,backendName:"webgl",kernelFunc:gB};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xB{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,i,a]=e,c=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=c[0]/u[0],h=c[1]/u[1],p=1/l,d=1/h,m=Math.ceil(p)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bB(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:i}=r,a=new xB(o.shape,s.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const vB={kernelName:C1,backendName:"webgl",kernelFunc:bB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wB{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,c)=>s(c)).join(","),i=ke(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CB{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=it("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ke(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(s.slice())};
          if(${o}){
            result.g = ${u(s.slice())};
          }
          if(${i}) {
            result.b = ${l(s.slice())};
            if(${o}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(m){return p(m)}function u(m){return m[r-1]="("+m[r-1]+" + 1)",p(m)}function l(m){return m[r-2]="("+m[r-2]+" + 1)",p(m)}function h(m){return m[r-1]="("+m[r-1]+" + 1)",m[r-2]="("+m[r-2]+" + 1)",p(m)}function p(m){const g=e.map((w,S)=>d(S,m)),y=g.join(","),x=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${x}))`}function d(m,g){return t.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${g[m]} - 1`:`${g[m]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SB(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:o}=r,i=s.shape.length,a=je(o,s.shape);if(i===0)return yt({inputs:{x:s},backend:t});const c=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CB(s.shape,a):new wB(s.shape,a);return t.runWebGLProgram(c,[s],s.dtype)}const TB={kernelName:Bd,backendName:"webgl",kernelFunc:SB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $B{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EB={kernelName:Tf,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=e,a=t,c=new $B(r.shape,o),[u,l]=Cg(i,r.shape[1],r.shape[2]),h=[[u,l,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(c,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kB=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,NB=pe({opSnippet:kB}),IB={kernelName:Vd,backendName:"webgl",kernelFunc:NB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _B="return inversesqrt(x);",RB=pe({opSnippet:_B,cpuKernelImpl:JO}),OB={kernelName:Ud,backendName:"webgl",kernelFunc:RB};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mx{constructor(e,t,r,s,o,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=ke(o.length),u=ke(i.length);let l="";r===1?l="i":r===2&&(l="i, j");const h=`getIndices(${l})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const d=`getUpdates(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${m};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:c,sliceSize:u,strides:l,outputSize:h}=Sc(o,s,i),p=[h/u,u];if(h===0)return t.makeTensorInfo(i,s.dtype);const d=q({inputs:{x:s},backend:t,attrs:{shape:[c,a]}}),m=q({inputs:{x:o},backend:t,attrs:{shape:[c,u]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0])),y=new mx(c,a,d.shape.length,m.shape.length,l,p),x=t.runWebGLProgram(y,[m,d,g],m.dtype),w=q({inputs:{x},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(g),w}const DB={kernelName:zd,backendName:"webgl",kernelFunc:AB};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PB{constructor(e,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=M().getNumber("WEBGL_VERSION")===2?o:i,c=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:o}=e,{side:i}=r,a=new PB(s.shape[0],s.shape[1],o.shape[1],i),c=[[s.shape[1]]];return t.runWebGLProgram(a,[s,o],"int32",c)}const LB={kernelName:Wd,backendName:"webgl",kernelFunc:FB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MB{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],u=[];for(let l=0;l<t.length;l++)u.push(`${a[l]}`),l<e&&c.push(`${a[l]}`);s=c.join(),o=u.join()}const i=ke(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:o}=e,i=new MB(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(i,[r,s,o],pn(s.dtype,o.dtype))}const VB={kernelName:Gd,backendName:"webgl",kernelFunc:BB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UB=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${$g};
  float scale = ${Eg};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,zB=pe({opSnippet:UB}),WB={kernelName:jd,backendName:"webgl",kernelFunc:zB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GB=ns+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,jB=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HB=pe({opSnippet:GB,packedOpSnippet:jB,cpuKernelImpl:tA}),KB={kernelName:Yd,backendName:"webgl",kernelFunc:HB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qB=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,XB=pe({opSnippet:qB}),YB={kernelName:Xd,backendName:"webgl",kernelFunc:XB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QB=ns+`
  return sin(x);
`,ZB=pe({opSnippet:QB}),JB={kernelName:Kd,backendName:"webgl",kernelFunc:ZB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e4=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,t4=pe({opSnippet:e4}),n4={kernelName:qd,backendName:"webgl",kernelFunc:t4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r4=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,s4=pe({opSnippet:r4}),o4={kernelName:Qd,backendName:"webgl",kernelFunc:s4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i4=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,paddings:i}=r;k(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((x,w)=>x*w),c=[[0,0]];c.push(...i);for(let x=1+o.length;x<s.shape.length;++x)c.push([0,0]);const u=[],l=dx({inputs:{x:s},backend:t,attrs:{paddings:c,constantValue:0}}),h=zc(l.shape,o,a,!1),p=Wc(h.length,o.length,!1),d=Gc(l.shape,o,a,!1),m=q({inputs:{x:l},backend:t,attrs:{shape:h}}),g=at({inputs:{x:m},backend:t,attrs:{perm:p}}),y=q({inputs:{x:g},backend:t,attrs:{shape:d}});return u.push(l),u.push(m),u.push(g),u.forEach(x=>t.disposeIntermediateTensorInfo(x)),y},a4={kernelName:ef,backendName:"webgl",kernelFunc:i4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c4(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=t.readSync(r.dataId),c=t.readSync(s.dataId),u=t.readSync(o.dataId),l=t.readSync(i.dataId)[0],[h,p,d,m,g]=rA(a,r.shape,r.dtype,c,s.dtype,u,l);return[t.makeTensorInfo(p,r.dtype,h),t.makeTensorInfo([p[0]],s.dtype,d),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),t.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const u4={kernelName:rf,backendName:"webgl",kernelFunc:c4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.readSync(s.dataId)),a=t.readSync(r.dataId),c=Array.from(t.readSync(o.dataId)),[u,l,h]=sA(a,r.shape,r.dtype,i,c);return[t.makeTensorInfo(l,r.dtype,u),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const h4={kernelName:sf,backendName:"webgl",kernelFunc:l4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=t.readSync(r.dataId),a=t.readSync(s.dataId),c=t.readSync(o.dataId),[u,l]=My(i,r.shape,r.dtype,a,c,!0);return t.makeTensorInfo(l,r.dtype,u)}const d4={kernelName:of,backendName:"webgl",kernelFunc:p4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=t.readSync(r.dataId),a=t.readSync(s.dataId),c=t.readSync(o.dataId),[u,l]=My(i,r.shape,r.dtype,a,c);return t.makeTensorInfo(l,r.dtype,u)}const m4={kernelName:af,backendName:"webgl",kernelFunc:f4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:c,numUpdates:u,sliceSize:l,strides:h,outputSize:p}=Sc(o,s,a),d=!1;if(o.dtype==="string"){const x=t.bufferSync(s),w=t.bufferSync(o),S=Br(t.readSync(i.dataId)[0]),$=eA(x,w,a,p,l,u,c,h,S,d);return t.makeTensorInfo(a,$.dtype,$.values)}const m=new mx(u,c,s.shape.length,o.shape.length,h,[p,1],d),g=t.runWebGLProgram(m,[o,s,i],o.dtype),y=q({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),y}const y4={kernelName:cf,backendName:"webgl",kernelFunc:g4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x4(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=je(i,s.shape)[0],c=Mg(s,o,a),u=s.shape.length,l=new Array(u).fill(0),h=s.shape.slice();return c.map(p=>{const d=[...h];d[a]=p;const m=rs({inputs:{x:s},backend:t,attrs:{begin:l,size:d}});return l[a]+=p,m})}const b4={kernelName:tf,backendName:"webgl",kernelFunc:x4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wh="return sqrt(x);",v4=pe({opSnippet:wh,packedOpSnippet:wh,cpuKernelImpl:oA}),w4={kernelName:Zd,backendName:"webgl",kernelFunc:v4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C4="return x * x;",S4=pe({opSnippet:C4}),T4={kernelName:T1,backendName:"webgl",kernelFunc:S4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ch="return (a - b) * (a - b);",$4=Xe({opSnippet:Ch,packedOpSnippet:Ch}),E4={kernelName:uf,backendName:"webgl",kernelFunc:$4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k4({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=Ht+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new xn(r.shape,s);return t.runWebGLProgram(o,[r],r.dtype)}const N4={kernelName:Sf,backendName:"webgl",kernelFunc:k4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I4{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=ke(r.length),i=ke(r.length);let a="";if(s===1)a="coords * strides + begin";else{let c=0;a=r.map((u,l)=>(c++,r.length===1?`coords * strides[${l}] + begin[${l}]`:`coords[${c-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _4(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,end:i,strides:a,beginMask:c,endMask:u,ellipsisMask:l,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:d,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:w,end:S,strides:$}=wm(s.shape,o,i,a,c,u,l,h,p);let N;if(g)N=q({inputs:{x:s},backend:t,attrs:{shape:m}});else if(y||x){k(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const O=hm(w,S,$),D=rs({inputs:{x:s},backend:t,attrs:{begin:w,size:O}});N=q({inputs:{x:D},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(D)}else if(t.shouldExecuteOnCPU([s])){const D=t.readSync(s.dataId),F=Le(s.shape,s.dtype,D),L=iA(d,F,$,w);N=t.makeTensorInfo(m,s.dtype,L.values)}else{const D=new I4(w,$,d);N=t.runWebGLProgram(D,[s],s.dtype)}const _=q({inputs:{x:N},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(N),_}const R4={kernelName:lf,backendName:"webgl",kernelFunc:_4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O4(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:c,preserveShortSequences:u}=r,{data:l,dataSplits:h}=e,p=t.readSync(l.dataId),d=t.readSync(h.dataId),[m,g]=aA(p,d,s,o,i,a,c,u);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(h.shape,"int32",g)]}const A4={kernelName:hf,backendName:"webgl",kernelFunc:O4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.readSync(o.dataId),c=t.readSync(i.dataId)[0],[u,l,h]=cA(a,c,s),p=l.length;return[t.makeTensorInfo([p,2],"int32",u),t.makeTensorInfo([p],"string",l),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const P4={kernelName:pf,backendName:"webgl",kernelFunc:D4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F4(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=t.readSync(o.dataId),a=uA(i,s);return t.makeTensorInfo(o.shape,"int32",a)}const L4={kernelName:df,backendName:"webgl",kernelFunc:F4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M4="return tan(x);",B4=pe({opSnippet:M4}),V4={kernelName:mf,backendName:"webgl",kernelFunc:B4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U4=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,z4=pe({opSnippet:U4}),W4={kernelName:gf,backendName:"webgl",kernelFunc:z4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G4{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*t[i];this.outputShape=r,this.rank=r.length;const s=ke(this.rank),o=j4(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function j4(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gx(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const c=t.readSync(s.dataId),u=s.dtype==="string"?c.map(p=>Br(p)):c,l=Le(s.shape,s.dtype,u),h=hA(l,o);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new G4(s.shape,o);return t.runWebGLProgram(i,[s],s.dtype)}const H4={kernelName:dc,backendName:"webgl",kernelFunc:gx};class K4{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class q4{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xn(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Sh(n){let e=1;for(;e<n;)e*=2;return e}function X4(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:o,sorted:i}=r,a=M().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=M().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,l=u[u.length-1];if(t.shouldExecuteOnCPU([s])||l<a||o>c){const L=t.readSync(s.dataId),[z,j]=pA(L,u,s.dtype,o,i);return[t.makeTensorInfo(z.shape,z.dtype,z.values),t.makeTensorInfo(j.shape,j.dtype,j.values)]}if(o===0)return u[u.length-1]=0,[t.makeTensorInfo(u,s.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(l===1)return[s,qs({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(s.dataId),p=h!==null&&h.isPacked,d=p?t.unpackTensor(s):s,g=G(u)/l,y=q({inputs:{x:d},attrs:{shape:[g,l]},backend:t});p&&Xn(t,d);const x=Sh(o),w=Sh(l);let S=null;const $=()=>S===null?[y,y]:[y,S],N=(L,z,j)=>{const K=$(),Y=new K4(j),re=[[l],[S===null?1:0],[Number.NEGATIVE_INFINITY],[L],[z]],ae=S;S=t.runWebGLProgram(Y,K,"int32",re),Xn(t,ae)};for(let L=1;L<x;L*=2){const z=L*2;for(let j=L;j>=1;j/=2)N(z,j,[g,w])}for(let L=w;L>x;L/=2){const z=$(),j=new q4([g,L/2]),Y=[[l],[S===null?1:0],[x]],te=S;S=t.runWebGLProgram(j,z,"int32",Y),Xn(t,te);const re=x/2,ae=re*2;for(let be=re;be>=1;be/=2)N(ae,be,S.shape)}let _=S;S=rs({inputs:{x:S},backend:t,attrs:{begin:0,size:[g,o]}}),Xn(t,_);let O=ax({inputs:{x:y,indices:S},backend:t,attrs:{axis:1,batchDims:1}});Xn(t,y);const D=u.slice(0,-1);D.push(o),_=S,S=q({inputs:{x:S},attrs:{shape:D},backend:t}),Xn(t,_);const F=O;return O=q({inputs:{x:O},attrs:{shape:D},backend:t}),Xn(t,F),[O,S]}const Y4={kernelName:yf,backendName:"webgl",kernelFunc:X4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q4{constructor(e,t,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=r==="nearest"?1:2;let c;switch(s){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:c,outputShape:u}=r,[l,h,p,d]=s.shape,[m,g]=u!=null?u:[h,p],y=[l,m,g,d],x=new Q4(h,p,i,a,c,y);return t.runWebGLProgram(x,[s,o],"float32")}const J4={kernelName:xf,backendName:"webgl",kernelFunc:Z4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eV(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:o}=e;Ws(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:c,indices:u}=dA(i,s,o.shape,o.dtype);return[r.makeTensorInfo(c,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}const tV={kernelName:bf,backendName:"webgl",kernelFunc:eV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nV(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,c=s.shape[o],u=new Array(a-1);let l=0;for(let g=0;g<a;g++)g!==o&&(u[l++]=i.shape[g]);const h=[],p=new Array(a).fill(0),d=i.shape.slice();d[o]=1;const m=new Array(c);for(let g=0;g<m.length;g++){p[o]=g;const y=rs({inputs:{x:i},backend:t,attrs:{begin:p,size:d}}),x=q({inputs:{x:y},backend:t,attrs:{shape:u}});m[g]=x,h.push(y)}return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const rV={kernelName:vf,backendName:"webgl",kernelFunc:nV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sV{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c="0.0",u="sumValue",l=Math.floor(r/4)*4,h=r%4,p=`
        sumValue += dot(values, segFilter);
    `;let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let m="";o%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${l};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,c=[];let u=0;const l=Gt([u],a);let h=s;l!=null&&(h=at({inputs:{x:s},backend:t,attrs:{perm:l}}),c.push(h),u=jt(1,a)[0]);const p=Qg(h.shape,u,i),d=G([h.shape[u]]),m=q({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});c.push(m);const g=mc(s.dtype),y=($,N,_,O,D)=>{const F=$.shape[0],L=$.shape[1],z=Yg(L,D),j={windowSize:z,inSize:L,batchSize:F,numSegments:D},K=new sV(j,N),Y=t.compileAndRun(K,[$,_],O);if(c.push(Y),Y.shape[1]===D)return Y;const te=fx({backend:t,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),re=gx({inputs:{x:te},backend:t,attrs:{reps:[L/z]}});return c.push(te),c.push(re),y(Y,N,re,O,D)},x=y(m,"unsortedSegmentSum",o,g,i),w=q({inputs:{x},backend:t,attrs:{shape:p}});let S=w;if(l!=null){c.push(w);const $=_c(l);S=at({inputs:{x:S},backend:t,attrs:{perm:$}})}return c.forEach($=>t.disposeIntermediateTensorInfo($)),S}const iV={kernelName:wf,backendName:"webgl",kernelFunc:oV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aV=[sD,iD,uD,pD,fD,yD,bD,wD,$D,kD,_D,AD,FD,VD,WD,jD,KD,QD,JD,tP,oP,pP,fP,gP,CP,TP,NP,UA,RP,FP,VP,HP,qP,YP,ZP,eF,rF,iF,uF,hF,dF,mF,xF,vF,TF,EF,IF,OF,DF,MF,zF,HF,XF,ZF,JF,t3,r3,o3,a3,u3,d3,g3,b3,w3,T3,k3,R3,P3,VA,L3,DP,V3,W3,H3,WA,Y3,eL,nL,iL,uL,dL,gL,vL,TL,kL,IL,AL,PL,LL,UL,WL,jL,KL,XL,JL,rM,aM,mM,HA,bM,CM,$M,NM,xP,RM,AM,PM,MM,zM,jA,GM,HM,qM,XM,bP,hM,ZM,nB,iB,qA,lB,dB,yB,vB,TB,EB,IB,OB,DB,LB,VB,WB,KB,YB,JB,n4,lP,dM,o4,a4,u4,h4,d4,m4,y4,b4,w4,T4,E4,N4,R4,A4,P4,L4,pM,tD,V4,W4,H4,Y4,J4,nD,tV,rV,iV,OM];for(const n of aV)k1(n);function cV(){if(!navigator)return!1;if(/MicroMessenger/i.test(navigator.userAgent))wx.miniProgram.getEnv(n=>(console.log(n),!!n.miniprogram));else return!1}function uV(){return cV()?wx.getWindowInfo().pixelRatio:1}async function lV(n){const e=On();if(!(n in e.registryFactory))throw new Error(`${n} backend is not registed.`);if(n in e.registry){const t=Jb(n);Zb(n),sm(n,t)}return await Qb(n)}class hV{constructor(e,t,r=Ir.MoveNet){ue(this,"canvas");ue(this,"ctx");ue(this,"modelName");ue(this,"config",{scoreThreshold:.6,keypointRadius:8,lineWidth:5});ue(this,"colors",{primary:RI,left:OI,right:AI,white:DI});ue(this,"enabled",!0);var o;this.canvas=e;const s=(o=this.canvas)==null?void 0:o.getContext("2d");if(!s)throw new Error("PoseDrawer can");this.ctx=s,this.modelName=r,this.init(t)}init(e){const t=uV();this.width=e.width*t,this.height=e.height*t,this.ctx.scale(t,t),console.log(`[${this.constructor.name}] Canvas Size: ${e.width} x ${e.height} with dpr: ${t}`)}get width(){return this.canvas.width}set width(e){this.canvas.width=e}get height(){return this.canvas.height}set height(e){this.canvas.height=e}clearCtx(){return this.enabled?(this.ctx.clearRect(0,0,this.width,this.height),!0):!1}drawPoint(e,t,r,s,o=1){this.ctx.save(),this.ctx.fillStyle=s,this.ctx.globalAlpha=o,this.ctx.beginPath(),this.ctx.arc(e,t,r,0,2*Math.PI),this.ctx.closePath(),this.ctx.fill(),this.ctx.restore()}drawCircle(e,t,r,s,o=1){this.ctx.save(),this.ctx.strokeStyle=s,this.ctx.globalAlpha=o,this.ctx.beginPath(),this.ctx.arc(e,t,r,0,2*Math.PI),this.ctx.closePath(),this.ctx.stroke(),this.ctx.restore()}drawKeypoint({keypoint:e,radius:t=this.config.keypointRadius,color:r=this.colors.primary}){this.drawPoint(e.x,e.y,t,r,e.score||1)}drawKeypointsSimple(e,t={x:0,y:0},r=1){e.forEach(s=>{if(1>=this.config.scoreThreshold){const i=s.multiply(r).add(lt.fromObject(t));this.drawKeypoint({keypoint:i,radius:this.config.keypointRadius})}})}drawKeypoints(e){const t=Dr.getKeypointIndexBySide(this.modelName);this.ctx.strokeStyle=this.colors.white,this.ctx.lineWidth=this.config.lineWidth;for(const r of t.middle)this.drawKeypoint({keypoint:e[r],color:this.colors.primary});for(const r of t.left)this.drawKeypoint({keypoint:e[r],color:this.colors.left});for(const r of t.right)this.drawKeypoint({keypoint:e[r],color:this.colors.right})}drawSkeleton(e,t=this.colors.primary){this.ctx.fillStyle=t,this.ctx.strokeStyle=t,this.ctx.lineWidth=this.config.lineWidth,Dr.getAdjacentPairs(this.modelName).forEach(([r,s])=>{const o=e[r],i=e[s],a=o.score!==void 0?o.score:1,c=i.score!==void 0?i.score:1;this.drawConnection(o,i,this.colors.primary,Math.min(a,c))})}drawConnection(e,t,r=this.colors.primary,s=1){this.ctx.save(),this.ctx.globalAlpha=s,this.ctx.fillStyle=r,this.ctx.strokeStyle=r,this.ctx.lineWidth=this.config.lineWidth,this.ctx.beginPath(),this.ctx.moveTo(e.x,e.y),this.ctx.lineTo(t.x,t.y),this.ctx.closePath(),this.ctx.stroke(),this.ctx.restore()}drawConnectionByName(e,t,r,s=this.colors.primary){const[o,i]=Ga(r,[e,t],this.modelName);this.drawConnection(o,i,s)}drawKeypointsByName(e,t,r=this.colors.primary){const s=new Wr(e,this.modelName);t.forEach(o=>{const i=s.getKeypointByName(o);this.drawKeypoint({keypoint:i,color:r})})}drawAuxillaryPoints(e,t=this.colors.primary){const r=new Wr(e,this.modelName);[r.auxHeadCenter,r.auxTorsoCenter,r.auxHipCenter,r.auxShoulderCenter,r.auxAnkleCenter,r.auxToeCenter].forEach(s=>this.drawKeypoint({keypoint:s,color:t}))}drawPose(e,t=!1){t&&this.clearCtx(),this.enabled&&e!==void 0&&(this.drawKeypoints(e),this.drawSkeleton(e),this.drawAuxillaryPoints(e))}highlightKeypointsByName(e,t){Ga(e,t,this.modelName).forEach(s=>{this.drawCircle(s.x,s.y,15,"rgb(255, 0, 0)",.5)})}getImage(){return this.ctx.getImageData(0,0,this.width,this.height)}}let yx=!0,xx=!0;function bo(n,e,t){const r=n.match(e);return r&&r.length>=t&&parseInt(r[t],10)}function ss(n,e,t){if(!n.RTCPeerConnection)return;const r=n.RTCPeerConnection.prototype,s=r.addEventListener;r.addEventListener=function(i,a){if(i!==e)return s.apply(this,arguments);const c=u=>{const l=t(u);l&&(a.handleEvent?a.handleEvent(l):a(l))};return this._eventMap=this._eventMap||{},this._eventMap[e]||(this._eventMap[e]=new Map),this._eventMap[e].set(a,c),s.apply(this,[i,c])};const o=r.removeEventListener;r.removeEventListener=function(i,a){if(i!==e||!this._eventMap||!this._eventMap[e])return o.apply(this,arguments);if(!this._eventMap[e].has(a))return o.apply(this,arguments);const c=this._eventMap[e].get(a);return this._eventMap[e].delete(a),this._eventMap[e].size===0&&delete this._eventMap[e],Object.keys(this._eventMap).length===0&&delete this._eventMap,o.apply(this,[i,c])},Object.defineProperty(r,"on"+e,{get(){return this["_on"+e]},set(i){this["_on"+e]&&(this.removeEventListener(e,this["_on"+e]),delete this["_on"+e]),i&&this.addEventListener(e,this["_on"+e]=i)},enumerable:!0,configurable:!0})}function pV(n){return typeof n!="boolean"?new Error("Argument type: "+typeof n+". Please use a boolean."):(yx=n,n?"adapter.js logging disabled":"adapter.js logging enabled")}function dV(n){return typeof n!="boolean"?new Error("Argument type: "+typeof n+". Please use a boolean."):(xx=!n,"adapter.js deprecation warnings "+(n?"disabled":"enabled"))}function bx(){if(typeof window=="object"){if(yx)return;typeof console<"u"&&typeof console.log=="function"&&console.log.apply(console,arguments)}}function tu(n,e){!xx||console.warn(n+" is deprecated, please use "+e+" instead.")}function fV(n){const e={browser:null,version:null};if(typeof n>"u"||!n.navigator)return e.browser="Not a browser.",e;const{navigator:t}=n;if(t.mozGetUserMedia)e.browser="firefox",e.version=bo(t.userAgent,/Firefox\/(\d+)\./,1);else if(t.webkitGetUserMedia||n.isSecureContext===!1&&n.webkitRTCPeerConnection)e.browser="chrome",e.version=bo(t.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else if(n.RTCPeerConnection&&t.userAgent.match(/AppleWebKit\/(\d+)\./))e.browser="safari",e.version=bo(t.userAgent,/AppleWebKit\/(\d+)\./,1),e.supportsUnifiedPlan=n.RTCRtpTransceiver&&"currentDirection"in n.RTCRtpTransceiver.prototype;else return e.browser="Not a supported browser.",e;return e}function Th(n){return Object.prototype.toString.call(n)==="[object Object]"}function vx(n){return Th(n)?Object.keys(n).reduce(function(e,t){const r=Th(n[t]),s=r?vx(n[t]):n[t],o=r&&!Object.keys(s).length;return s===void 0||o?e:Object.assign(e,{[t]:s})},{}):n}function Ya(n,e,t){!e||t.has(e.id)||(t.set(e.id,e),Object.keys(e).forEach(r=>{r.endsWith("Id")?Ya(n,n.get(e[r]),t):r.endsWith("Ids")&&e[r].forEach(s=>{Ya(n,n.get(s),t)})}))}function $h(n,e,t){const r=t?"outbound-rtp":"inbound-rtp",s=new Map;if(e===null)return s;const o=[];return n.forEach(i=>{i.type==="track"&&i.trackIdentifier===e.id&&o.push(i)}),o.forEach(i=>{n.forEach(a=>{a.type===r&&a.trackId===i.id&&Ya(n,a,s)})}),s}const Eh=bx;function Cx(n,e){const t=n&&n.navigator;if(!t.mediaDevices)return;const r=function(a){if(typeof a!="object"||a.mandatory||a.optional)return a;const c={};return Object.keys(a).forEach(u=>{if(u==="require"||u==="advanced"||u==="mediaSource")return;const l=typeof a[u]=="object"?a[u]:{ideal:a[u]};l.exact!==void 0&&typeof l.exact=="number"&&(l.min=l.max=l.exact);const h=function(p,d){return p?p+d.charAt(0).toUpperCase()+d.slice(1):d==="deviceId"?"sourceId":d};if(l.ideal!==void 0){c.optional=c.optional||[];let p={};typeof l.ideal=="number"?(p[h("min",u)]=l.ideal,c.optional.push(p),p={},p[h("max",u)]=l.ideal,c.optional.push(p)):(p[h("",u)]=l.ideal,c.optional.push(p))}l.exact!==void 0&&typeof l.exact!="number"?(c.mandatory=c.mandatory||{},c.mandatory[h("",u)]=l.exact):["min","max"].forEach(p=>{l[p]!==void 0&&(c.mandatory=c.mandatory||{},c.mandatory[h(p,u)]=l[p])})}),a.advanced&&(c.optional=(c.optional||[]).concat(a.advanced)),c},s=function(a,c){if(e.version>=61)return c(a);if(a=JSON.parse(JSON.stringify(a)),a&&typeof a.audio=="object"){const u=function(l,h,p){h in l&&!(p in l)&&(l[p]=l[h],delete l[h])};a=JSON.parse(JSON.stringify(a)),u(a.audio,"autoGainControl","googAutoGainControl"),u(a.audio,"noiseSuppression","googNoiseSuppression"),a.audio=r(a.audio)}if(a&&typeof a.video=="object"){let u=a.video.facingMode;u=u&&(typeof u=="object"?u:{ideal:u});const l=e.version<66;if(u&&(u.exact==="user"||u.exact==="environment"||u.ideal==="user"||u.ideal==="environment")&&!(t.mediaDevices.getSupportedConstraints&&t.mediaDevices.getSupportedConstraints().facingMode&&!l)){delete a.video.facingMode;let h;if(u.exact==="environment"||u.ideal==="environment"?h=["back","rear"]:(u.exact==="user"||u.ideal==="user")&&(h=["front"]),h)return t.mediaDevices.enumerateDevices().then(p=>{p=p.filter(m=>m.kind==="videoinput");let d=p.find(m=>h.some(g=>m.label.toLowerCase().includes(g)));return!d&&p.length&&h.includes("back")&&(d=p[p.length-1]),d&&(a.video.deviceId=u.exact?{exact:d.deviceId}:{ideal:d.deviceId}),a.video=r(a.video),Eh("chrome: "+JSON.stringify(a)),c(a)})}a.video=r(a.video)}return Eh("chrome: "+JSON.stringify(a)),c(a)},o=function(a){return e.version>=64?a:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[a.name]||a.name,message:a.message,constraint:a.constraint||a.constraintName,toString(){return this.name+(this.message&&": ")+this.message}}},i=function(a,c,u){s(a,l=>{t.webkitGetUserMedia(l,c,h=>{u&&u(o(h))})})};if(t.getUserMedia=i.bind(t),t.mediaDevices.getUserMedia){const a=t.mediaDevices.getUserMedia.bind(t.mediaDevices);t.mediaDevices.getUserMedia=function(c){return s(c,u=>a(u).then(l=>{if(u.audio&&!l.getAudioTracks().length||u.video&&!l.getVideoTracks().length)throw l.getTracks().forEach(h=>{h.stop()}),new DOMException("","NotFoundError");return l},l=>Promise.reject(o(l))))}}}function mV(n,e){if(!(n.navigator.mediaDevices&&"getDisplayMedia"in n.navigator.mediaDevices)&&!!n.navigator.mediaDevices){if(typeof e!="function"){console.error("shimGetDisplayMedia: getSourceId argument is not a function");return}n.navigator.mediaDevices.getDisplayMedia=function(r){return e(r).then(s=>{const o=r.video&&r.video.width,i=r.video&&r.video.height,a=r.video&&r.video.frameRate;return r.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:s,maxFrameRate:a||3}},o&&(r.video.mandatory.maxWidth=o),i&&(r.video.mandatory.maxHeight=i),n.navigator.mediaDevices.getUserMedia(r)})}}}function Sx(n){n.MediaStream=n.MediaStream||n.webkitMediaStream}function Tx(n){if(typeof n=="object"&&n.RTCPeerConnection&&!("ontrack"in n.RTCPeerConnection.prototype)){Object.defineProperty(n.RTCPeerConnection.prototype,"ontrack",{get(){return this._ontrack},set(t){this._ontrack&&this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=t)},enumerable:!0,configurable:!0});const e=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(){return this._ontrackpoly||(this._ontrackpoly=r=>{r.stream.addEventListener("addtrack",s=>{let o;n.RTCPeerConnection.prototype.getReceivers?o=this.getReceivers().find(a=>a.track&&a.track.id===s.track.id):o={track:s.track};const i=new Event("track");i.track=s.track,i.receiver=o,i.transceiver={receiver:o},i.streams=[r.stream],this.dispatchEvent(i)}),r.stream.getTracks().forEach(s=>{let o;n.RTCPeerConnection.prototype.getReceivers?o=this.getReceivers().find(a=>a.track&&a.track.id===s.id):o={track:s};const i=new Event("track");i.track=s,i.receiver=o,i.transceiver={receiver:o},i.streams=[r.stream],this.dispatchEvent(i)})},this.addEventListener("addstream",this._ontrackpoly)),e.apply(this,arguments)}}else ss(n,"track",e=>(e.transceiver||Object.defineProperty(e,"transceiver",{value:{receiver:e.receiver}}),e))}function $x(n){if(typeof n=="object"&&n.RTCPeerConnection&&!("getSenders"in n.RTCPeerConnection.prototype)&&"createDTMFSender"in n.RTCPeerConnection.prototype){const e=function(s,o){return{track:o,get dtmf(){return this._dtmf===void 0&&(o.kind==="audio"?this._dtmf=s.createDTMFSender(o):this._dtmf=null),this._dtmf},_pc:s}};if(!n.RTCPeerConnection.prototype.getSenders){n.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};const s=n.RTCPeerConnection.prototype.addTrack;n.RTCPeerConnection.prototype.addTrack=function(a,c){let u=s.apply(this,arguments);return u||(u=e(this,a),this._senders.push(u)),u};const o=n.RTCPeerConnection.prototype.removeTrack;n.RTCPeerConnection.prototype.removeTrack=function(a){o.apply(this,arguments);const c=this._senders.indexOf(a);c!==-1&&this._senders.splice(c,1)}}const t=n.RTCPeerConnection.prototype.addStream;n.RTCPeerConnection.prototype.addStream=function(o){this._senders=this._senders||[],t.apply(this,[o]),o.getTracks().forEach(i=>{this._senders.push(e(this,i))})};const r=n.RTCPeerConnection.prototype.removeStream;n.RTCPeerConnection.prototype.removeStream=function(o){this._senders=this._senders||[],r.apply(this,[o]),o.getTracks().forEach(i=>{const a=this._senders.find(c=>c.track===i);a&&this._senders.splice(this._senders.indexOf(a),1)})}}else if(typeof n=="object"&&n.RTCPeerConnection&&"getSenders"in n.RTCPeerConnection.prototype&&"createDTMFSender"in n.RTCPeerConnection.prototype&&n.RTCRtpSender&&!("dtmf"in n.RTCRtpSender.prototype)){const e=n.RTCPeerConnection.prototype.getSenders;n.RTCPeerConnection.prototype.getSenders=function(){const r=e.apply(this,[]);return r.forEach(s=>s._pc=this),r},Object.defineProperty(n.RTCRtpSender.prototype,"dtmf",{get(){return this._dtmf===void 0&&(this.track.kind==="audio"?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}})}}function Ex(n){if(!n.RTCPeerConnection)return;const e=n.RTCPeerConnection.prototype.getStats;n.RTCPeerConnection.prototype.getStats=function(){const[r,s,o]=arguments;if(arguments.length>0&&typeof r=="function")return e.apply(this,arguments);if(e.length===0&&(arguments.length===0||typeof r!="function"))return e.apply(this,[]);const i=function(c){const u={};return c.result().forEach(h=>{const p={id:h.id,timestamp:h.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[h.type]||h.type};h.names().forEach(d=>{p[d]=h.stat(d)}),u[p.id]=p}),u},a=function(c){return new Map(Object.keys(c).map(u=>[u,c[u]]))};if(arguments.length>=2){const c=function(u){s(a(i(u)))};return e.apply(this,[c,r])}return new Promise((c,u)=>{e.apply(this,[function(l){c(a(i(l)))},u])}).then(s,o)}}function kx(n){if(!(typeof n=="object"&&n.RTCPeerConnection&&n.RTCRtpSender&&n.RTCRtpReceiver))return;if(!("getStats"in n.RTCRtpSender.prototype)){const t=n.RTCPeerConnection.prototype.getSenders;t&&(n.RTCPeerConnection.prototype.getSenders=function(){const o=t.apply(this,[]);return o.forEach(i=>i._pc=this),o});const r=n.RTCPeerConnection.prototype.addTrack;r&&(n.RTCPeerConnection.prototype.addTrack=function(){const o=r.apply(this,arguments);return o._pc=this,o}),n.RTCRtpSender.prototype.getStats=function(){const o=this;return this._pc.getStats().then(i=>$h(i,o.track,!0))}}if(!("getStats"in n.RTCRtpReceiver.prototype)){const t=n.RTCPeerConnection.prototype.getReceivers;t&&(n.RTCPeerConnection.prototype.getReceivers=function(){const s=t.apply(this,[]);return s.forEach(o=>o._pc=this),s}),ss(n,"track",r=>(r.receiver._pc=r.srcElement,r)),n.RTCRtpReceiver.prototype.getStats=function(){const s=this;return this._pc.getStats().then(o=>$h(o,s.track,!1))}}if(!("getStats"in n.RTCRtpSender.prototype&&"getStats"in n.RTCRtpReceiver.prototype))return;const e=n.RTCPeerConnection.prototype.getStats;n.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof n.MediaStreamTrack){const r=arguments[0];let s,o,i;return this.getSenders().forEach(a=>{a.track===r&&(s?i=!0:s=a)}),this.getReceivers().forEach(a=>(a.track===r&&(o?i=!0:o=a),a.track===r)),i||s&&o?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):s?s.getStats():o?o.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}return e.apply(this,arguments)}}function Nx(n){n.RTCPeerConnection.prototype.getLocalStreams=function(){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(i=>this._shimmedLocalStreams[i][0])};const e=n.RTCPeerConnection.prototype.addTrack;n.RTCPeerConnection.prototype.addTrack=function(i,a){if(!a)return e.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};const c=e.apply(this,arguments);return this._shimmedLocalStreams[a.id]?this._shimmedLocalStreams[a.id].indexOf(c)===-1&&this._shimmedLocalStreams[a.id].push(c):this._shimmedLocalStreams[a.id]=[a,c],c};const t=n.RTCPeerConnection.prototype.addStream;n.RTCPeerConnection.prototype.addStream=function(i){this._shimmedLocalStreams=this._shimmedLocalStreams||{},i.getTracks().forEach(u=>{if(this.getSenders().find(h=>h.track===u))throw new DOMException("Track already exists.","InvalidAccessError")});const a=this.getSenders();t.apply(this,arguments);const c=this.getSenders().filter(u=>a.indexOf(u)===-1);this._shimmedLocalStreams[i.id]=[i].concat(c)};const r=n.RTCPeerConnection.prototype.removeStream;n.RTCPeerConnection.prototype.removeStream=function(i){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[i.id],r.apply(this,arguments)};const s=n.RTCPeerConnection.prototype.removeTrack;n.RTCPeerConnection.prototype.removeTrack=function(i){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},i&&Object.keys(this._shimmedLocalStreams).forEach(a=>{const c=this._shimmedLocalStreams[a].indexOf(i);c!==-1&&this._shimmedLocalStreams[a].splice(c,1),this._shimmedLocalStreams[a].length===1&&delete this._shimmedLocalStreams[a]}),s.apply(this,arguments)}}function Ix(n,e){if(!n.RTCPeerConnection)return;if(n.RTCPeerConnection.prototype.addTrack&&e.version>=65)return Nx(n);const t=n.RTCPeerConnection.prototype.getLocalStreams;n.RTCPeerConnection.prototype.getLocalStreams=function(){const l=t.apply(this);return this._reverseStreams=this._reverseStreams||{},l.map(h=>this._reverseStreams[h.id])};const r=n.RTCPeerConnection.prototype.addStream;n.RTCPeerConnection.prototype.addStream=function(l){if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},l.getTracks().forEach(h=>{if(this.getSenders().find(d=>d.track===h))throw new DOMException("Track already exists.","InvalidAccessError")}),!this._reverseStreams[l.id]){const h=new n.MediaStream(l.getTracks());this._streams[l.id]=h,this._reverseStreams[h.id]=l,l=h}r.apply(this,[l])};const s=n.RTCPeerConnection.prototype.removeStream;n.RTCPeerConnection.prototype.removeStream=function(l){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},s.apply(this,[this._streams[l.id]||l]),delete this._reverseStreams[this._streams[l.id]?this._streams[l.id].id:l.id],delete this._streams[l.id]},n.RTCPeerConnection.prototype.addTrack=function(l,h){if(this.signalingState==="closed")throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");const p=[].slice.call(arguments,1);if(p.length!==1||!p[0].getTracks().find(g=>g===l))throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");if(this.getSenders().find(g=>g.track===l))throw new DOMException("Track already exists.","InvalidAccessError");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};const m=this._streams[h.id];if(m)m.addTrack(l),Promise.resolve().then(()=>{this.dispatchEvent(new Event("negotiationneeded"))});else{const g=new n.MediaStream([l]);this._streams[h.id]=g,this._reverseStreams[g.id]=h,this.addStream(g)}return this.getSenders().find(g=>g.track===l)};function o(u,l){let h=l.sdp;return Object.keys(u._reverseStreams||[]).forEach(p=>{const d=u._reverseStreams[p],m=u._streams[d.id];h=h.replace(new RegExp(m.id,"g"),d.id)}),new RTCSessionDescription({type:l.type,sdp:h})}function i(u,l){let h=l.sdp;return Object.keys(u._reverseStreams||[]).forEach(p=>{const d=u._reverseStreams[p],m=u._streams[d.id];h=h.replace(new RegExp(d.id,"g"),m.id)}),new RTCSessionDescription({type:l.type,sdp:h})}["createOffer","createAnswer"].forEach(function(u){const l=n.RTCPeerConnection.prototype[u],h={[u](){const p=arguments;return arguments.length&&typeof arguments[0]=="function"?l.apply(this,[m=>{const g=o(this,m);p[0].apply(null,[g])},m=>{p[1]&&p[1].apply(null,m)},arguments[2]]):l.apply(this,arguments).then(m=>o(this,m))}};n.RTCPeerConnection.prototype[u]=h[u]});const a=n.RTCPeerConnection.prototype.setLocalDescription;n.RTCPeerConnection.prototype.setLocalDescription=function(){return!arguments.length||!arguments[0].type?a.apply(this,arguments):(arguments[0]=i(this,arguments[0]),a.apply(this,arguments))};const c=Object.getOwnPropertyDescriptor(n.RTCPeerConnection.prototype,"localDescription");Object.defineProperty(n.RTCPeerConnection.prototype,"localDescription",{get(){const u=c.get.apply(this);return u.type===""?u:o(this,u)}}),n.RTCPeerConnection.prototype.removeTrack=function(l){if(this.signalingState==="closed")throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");if(!l._pc)throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");if(!(l._pc===this))throw new DOMException("Sender was not created by this connection.","InvalidAccessError");this._streams=this._streams||{};let p;Object.keys(this._streams).forEach(d=>{this._streams[d].getTracks().find(g=>l.track===g)&&(p=this._streams[d])}),p&&(p.getTracks().length===1?this.removeStream(this._reverseStreams[p.id]):p.removeTrack(l.track),this.dispatchEvent(new Event("negotiationneeded")))}}function Qa(n,e){!n.RTCPeerConnection&&n.webkitRTCPeerConnection&&(n.RTCPeerConnection=n.webkitRTCPeerConnection),!!n.RTCPeerConnection&&e.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(t){const r=n.RTCPeerConnection.prototype[t],s={[t](){return arguments[0]=new(t==="addIceCandidate"?n.RTCIceCandidate:n.RTCSessionDescription)(arguments[0]),r.apply(this,arguments)}};n.RTCPeerConnection.prototype[t]=s[t]})}function _x(n,e){ss(n,"negotiationneeded",t=>{const r=t.target;if(!((e.version<72||r.getConfiguration&&r.getConfiguration().sdpSemantics==="plan-b")&&r.signalingState!=="stable"))return t})}const kh=Object.freeze(Object.defineProperty({__proto__:null,shimMediaStream:Sx,shimOnTrack:Tx,shimGetSendersWithDtmf:$x,shimGetStats:Ex,shimSenderReceiverGetStats:kx,shimAddTrackRemoveTrackWithNative:Nx,shimAddTrackRemoveTrack:Ix,shimPeerConnection:Qa,fixNegotiationNeeded:_x,shimGetUserMedia:Cx,shimGetDisplayMedia:mV},Symbol.toStringTag,{value:"Module"}));function Rx(n,e){const t=n&&n.navigator,r=n&&n.MediaStreamTrack;if(t.getUserMedia=function(s,o,i){tu("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),t.mediaDevices.getUserMedia(s).then(o,i)},!(e.version>55&&"autoGainControl"in t.mediaDevices.getSupportedConstraints())){const s=function(i,a,c){a in i&&!(c in i)&&(i[c]=i[a],delete i[a])},o=t.mediaDevices.getUserMedia.bind(t.mediaDevices);if(t.mediaDevices.getUserMedia=function(i){return typeof i=="object"&&typeof i.audio=="object"&&(i=JSON.parse(JSON.stringify(i)),s(i.audio,"autoGainControl","mozAutoGainControl"),s(i.audio,"noiseSuppression","mozNoiseSuppression")),o(i)},r&&r.prototype.getSettings){const i=r.prototype.getSettings;r.prototype.getSettings=function(){const a=i.apply(this,arguments);return s(a,"mozAutoGainControl","autoGainControl"),s(a,"mozNoiseSuppression","noiseSuppression"),a}}if(r&&r.prototype.applyConstraints){const i=r.prototype.applyConstraints;r.prototype.applyConstraints=function(a){return this.kind==="audio"&&typeof a=="object"&&(a=JSON.parse(JSON.stringify(a)),s(a,"autoGainControl","mozAutoGainControl"),s(a,"noiseSuppression","mozNoiseSuppression")),i.apply(this,[a])}}}}function gV(n,e){n.navigator.mediaDevices&&"getDisplayMedia"in n.navigator.mediaDevices||!n.navigator.mediaDevices||(n.navigator.mediaDevices.getDisplayMedia=function(r){if(!(r&&r.video)){const s=new DOMException("getDisplayMedia without video constraints is undefined");return s.name="NotFoundError",s.code=8,Promise.reject(s)}return r.video===!0?r.video={mediaSource:e}:r.video.mediaSource=e,n.navigator.mediaDevices.getUserMedia(r)})}function Ox(n){typeof n=="object"&&n.RTCTrackEvent&&"receiver"in n.RTCTrackEvent.prototype&&!("transceiver"in n.RTCTrackEvent.prototype)&&Object.defineProperty(n.RTCTrackEvent.prototype,"transceiver",{get(){return{receiver:this.receiver}}})}function Za(n,e){if(typeof n!="object"||!(n.RTCPeerConnection||n.mozRTCPeerConnection))return;!n.RTCPeerConnection&&n.mozRTCPeerConnection&&(n.RTCPeerConnection=n.mozRTCPeerConnection),e.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(s){const o=n.RTCPeerConnection.prototype[s],i={[s](){return arguments[0]=new(s==="addIceCandidate"?n.RTCIceCandidate:n.RTCSessionDescription)(arguments[0]),o.apply(this,arguments)}};n.RTCPeerConnection.prototype[s]=i[s]});const t={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},r=n.RTCPeerConnection.prototype.getStats;n.RTCPeerConnection.prototype.getStats=function(){const[o,i,a]=arguments;return r.apply(this,[o||null]).then(c=>{if(e.version<53&&!i)try{c.forEach(u=>{u.type=t[u.type]||u.type})}catch(u){if(u.name!=="TypeError")throw u;c.forEach((l,h)=>{c.set(h,Object.assign({},l,{type:t[l.type]||l.type}))})}return c}).then(i,a)}}function Ax(n){if(!(typeof n=="object"&&n.RTCPeerConnection&&n.RTCRtpSender)||n.RTCRtpSender&&"getStats"in n.RTCRtpSender.prototype)return;const e=n.RTCPeerConnection.prototype.getSenders;e&&(n.RTCPeerConnection.prototype.getSenders=function(){const s=e.apply(this,[]);return s.forEach(o=>o._pc=this),s});const t=n.RTCPeerConnection.prototype.addTrack;t&&(n.RTCPeerConnection.prototype.addTrack=function(){const s=t.apply(this,arguments);return s._pc=this,s}),n.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}}function Dx(n){if(!(typeof n=="object"&&n.RTCPeerConnection&&n.RTCRtpSender)||n.RTCRtpSender&&"getStats"in n.RTCRtpReceiver.prototype)return;const e=n.RTCPeerConnection.prototype.getReceivers;e&&(n.RTCPeerConnection.prototype.getReceivers=function(){const r=e.apply(this,[]);return r.forEach(s=>s._pc=this),r}),ss(n,"track",t=>(t.receiver._pc=t.srcElement,t)),n.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)}}function Px(n){!n.RTCPeerConnection||"removeStream"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.removeStream=function(t){tu("removeStream","removeTrack"),this.getSenders().forEach(r=>{r.track&&t.getTracks().includes(r.track)&&this.removeTrack(r)})})}function Fx(n){n.DataChannel&&!n.RTCDataChannel&&(n.RTCDataChannel=n.DataChannel)}function Lx(n){if(!(typeof n=="object"&&n.RTCPeerConnection))return;const e=n.RTCPeerConnection.prototype.addTransceiver;e&&(n.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];let r=arguments[1]&&arguments[1].sendEncodings;r===void 0&&(r=[]),r=[...r];const s=r.length>0;s&&r.forEach(i=>{if("rid"in i&&!/^[a-z0-9]{0,16}$/i.test(i.rid))throw new TypeError("Invalid RID value provided.");if("scaleResolutionDownBy"in i&&!(parseFloat(i.scaleResolutionDownBy)>=1))throw new RangeError("scale_resolution_down_by must be >= 1.0");if("maxFramerate"in i&&!(parseFloat(i.maxFramerate)>=0))throw new RangeError("max_framerate must be >= 0.0")});const o=e.apply(this,arguments);if(s){const{sender:i}=o,a=i.getParameters();(!("encodings"in a)||a.encodings.length===1&&Object.keys(a.encodings[0]).length===0)&&(a.encodings=r,i.sendEncodings=r,this.setParametersPromises.push(i.setParameters(a).then(()=>{delete i.sendEncodings}).catch(()=>{delete i.sendEncodings})))}return o})}function Mx(n){if(!(typeof n=="object"&&n.RTCRtpSender))return;const e=n.RTCRtpSender.prototype.getParameters;e&&(n.RTCRtpSender.prototype.getParameters=function(){const r=e.apply(this,arguments);return"encodings"in r||(r.encodings=[].concat(this.sendEncodings||[{}])),r})}function Bx(n){if(!(typeof n=="object"&&n.RTCPeerConnection))return;const e=n.RTCPeerConnection.prototype.createOffer;n.RTCPeerConnection.prototype.createOffer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(()=>e.apply(this,arguments)).finally(()=>{this.setParametersPromises=[]}):e.apply(this,arguments)}}function Vx(n){if(!(typeof n=="object"&&n.RTCPeerConnection))return;const e=n.RTCPeerConnection.prototype.createAnswer;n.RTCPeerConnection.prototype.createAnswer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(()=>e.apply(this,arguments)).finally(()=>{this.setParametersPromises=[]}):e.apply(this,arguments)}}const Nh=Object.freeze(Object.defineProperty({__proto__:null,shimOnTrack:Ox,shimPeerConnection:Za,shimSenderGetStats:Ax,shimReceiverGetStats:Dx,shimRemoveStream:Px,shimRTCDataChannel:Fx,shimAddTransceiver:Lx,shimGetParameters:Mx,shimCreateOffer:Bx,shimCreateAnswer:Vx,shimGetUserMedia:Rx,shimGetDisplayMedia:gV},Symbol.toStringTag,{value:"Module"}));function Ux(n){if(!(typeof n!="object"||!n.RTCPeerConnection)){if("getLocalStreams"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!("addStream"in n.RTCPeerConnection.prototype)){const e=n.RTCPeerConnection.prototype.addTrack;n.RTCPeerConnection.prototype.addStream=function(r){this._localStreams||(this._localStreams=[]),this._localStreams.includes(r)||this._localStreams.push(r),r.getAudioTracks().forEach(s=>e.call(this,s,r)),r.getVideoTracks().forEach(s=>e.call(this,s,r))},n.RTCPeerConnection.prototype.addTrack=function(r,...s){return s&&s.forEach(o=>{this._localStreams?this._localStreams.includes(o)||this._localStreams.push(o):this._localStreams=[o]}),e.apply(this,arguments)}}"removeStream"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.removeStream=function(t){this._localStreams||(this._localStreams=[]);const r=this._localStreams.indexOf(t);if(r===-1)return;this._localStreams.splice(r,1);const s=t.getTracks();this.getSenders().forEach(o=>{s.includes(o.track)&&this.removeTrack(o)})})}}function zx(n){if(!(typeof n!="object"||!n.RTCPeerConnection)&&("getRemoteStreams"in n.RTCPeerConnection.prototype||(n.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!("onaddstream"in n.RTCPeerConnection.prototype))){Object.defineProperty(n.RTCPeerConnection.prototype,"onaddstream",{get(){return this._onaddstream},set(t){this._onaddstream&&(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=t),this.addEventListener("track",this._onaddstreampoly=r=>{r.streams.forEach(s=>{if(this._remoteStreams||(this._remoteStreams=[]),this._remoteStreams.includes(s))return;this._remoteStreams.push(s);const o=new Event("addstream");o.stream=s,this.dispatchEvent(o)})})}});const e=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(){const r=this;return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=function(s){s.streams.forEach(o=>{if(r._remoteStreams||(r._remoteStreams=[]),r._remoteStreams.indexOf(o)>=0)return;r._remoteStreams.push(o);const i=new Event("addstream");i.stream=o,r.dispatchEvent(i)})}),e.apply(r,arguments)}}}function Wx(n){if(typeof n!="object"||!n.RTCPeerConnection)return;const e=n.RTCPeerConnection.prototype,t=e.createOffer,r=e.createAnswer,s=e.setLocalDescription,o=e.setRemoteDescription,i=e.addIceCandidate;e.createOffer=function(u,l){const h=arguments.length>=2?arguments[2]:arguments[0],p=t.apply(this,[h]);return l?(p.then(u,l),Promise.resolve()):p},e.createAnswer=function(u,l){const h=arguments.length>=2?arguments[2]:arguments[0],p=r.apply(this,[h]);return l?(p.then(u,l),Promise.resolve()):p};let a=function(c,u,l){const h=s.apply(this,[c]);return l?(h.then(u,l),Promise.resolve()):h};e.setLocalDescription=a,a=function(c,u,l){const h=o.apply(this,[c]);return l?(h.then(u,l),Promise.resolve()):h},e.setRemoteDescription=a,a=function(c,u,l){const h=i.apply(this,[c]);return l?(h.then(u,l),Promise.resolve()):h},e.addIceCandidate=a}function Gx(n){const e=n&&n.navigator;if(e.mediaDevices&&e.mediaDevices.getUserMedia){const t=e.mediaDevices,r=t.getUserMedia.bind(t);e.mediaDevices.getUserMedia=s=>r(jx(s))}!e.getUserMedia&&e.mediaDevices&&e.mediaDevices.getUserMedia&&(e.getUserMedia=function(r,s,o){e.mediaDevices.getUserMedia(r).then(s,o)}.bind(e))}function jx(n){return n&&n.video!==void 0?Object.assign({},n,{video:vx(n.video)}):n}function Hx(n){if(!n.RTCPeerConnection)return;const e=n.RTCPeerConnection;n.RTCPeerConnection=function(r,s){if(r&&r.iceServers){const o=[];for(let i=0;i<r.iceServers.length;i++){let a=r.iceServers[i];!a.hasOwnProperty("urls")&&a.hasOwnProperty("url")?(tu("RTCIceServer.url","RTCIceServer.urls"),a=JSON.parse(JSON.stringify(a)),a.urls=a.url,delete a.url,o.push(a)):o.push(r.iceServers[i])}r.iceServers=o}return new e(r,s)},n.RTCPeerConnection.prototype=e.prototype,"generateCertificate"in e&&Object.defineProperty(n.RTCPeerConnection,"generateCertificate",{get(){return e.generateCertificate}})}function Kx(n){typeof n=="object"&&n.RTCTrackEvent&&"receiver"in n.RTCTrackEvent.prototype&&!("transceiver"in n.RTCTrackEvent.prototype)&&Object.defineProperty(n.RTCTrackEvent.prototype,"transceiver",{get(){return{receiver:this.receiver}}})}function qx(n){const e=n.RTCPeerConnection.prototype.createOffer;n.RTCPeerConnection.prototype.createOffer=function(r){if(r){typeof r.offerToReceiveAudio<"u"&&(r.offerToReceiveAudio=!!r.offerToReceiveAudio);const s=this.getTransceivers().find(i=>i.receiver.track.kind==="audio");r.offerToReceiveAudio===!1&&s?s.direction==="sendrecv"?s.setDirection?s.setDirection("sendonly"):s.direction="sendonly":s.direction==="recvonly"&&(s.setDirection?s.setDirection("inactive"):s.direction="inactive"):r.offerToReceiveAudio===!0&&!s&&this.addTransceiver("audio",{direction:"recvonly"}),typeof r.offerToReceiveVideo<"u"&&(r.offerToReceiveVideo=!!r.offerToReceiveVideo);const o=this.getTransceivers().find(i=>i.receiver.track.kind==="video");r.offerToReceiveVideo===!1&&o?o.direction==="sendrecv"?o.setDirection?o.setDirection("sendonly"):o.direction="sendonly":o.direction==="recvonly"&&(o.setDirection?o.setDirection("inactive"):o.direction="inactive"):r.offerToReceiveVideo===!0&&!o&&this.addTransceiver("video",{direction:"recvonly"})}return e.apply(this,arguments)}}function Xx(n){typeof n!="object"||n.AudioContext||(n.AudioContext=n.webkitAudioContext)}const Ih=Object.freeze(Object.defineProperty({__proto__:null,shimLocalStreamsAPI:Ux,shimRemoteStreamsAPI:zx,shimCallbacksAPI:Wx,shimGetUserMedia:Gx,shimConstraints:jx,shimRTCIceServerUrls:Hx,shimTrackEventTransceiver:Kx,shimCreateOfferLegacy:qx,shimAudioContext:Xx},Symbol.toStringTag,{value:"Module"}));var nu={exports:{}};(function(n){const e={};e.generateIdentifier=function(){return Math.random().toString(36).substr(2,10)},e.localCName=e.generateIdentifier(),e.splitLines=function(t){return t.trim().split(`
`).map(r=>r.trim())},e.splitSections=function(t){return t.split(`
m=`).map((s,o)=>(o>0?"m="+s:s).trim()+`\r
`)},e.getDescription=function(t){const r=e.splitSections(t);return r&&r[0]},e.getMediaSections=function(t){const r=e.splitSections(t);return r.shift(),r},e.matchPrefix=function(t,r){return e.splitLines(t).filter(s=>s.indexOf(r)===0)},e.parseCandidate=function(t){let r;t.indexOf("a=candidate:")===0?r=t.substring(12).split(" "):r=t.substring(10).split(" ");const s={foundation:r[0],component:{1:"rtp",2:"rtcp"}[r[1]]||r[1],protocol:r[2].toLowerCase(),priority:parseInt(r[3],10),ip:r[4],address:r[4],port:parseInt(r[5],10),type:r[7]};for(let o=8;o<r.length;o+=2)switch(r[o]){case"raddr":s.relatedAddress=r[o+1];break;case"rport":s.relatedPort=parseInt(r[o+1],10);break;case"tcptype":s.tcpType=r[o+1];break;case"ufrag":s.ufrag=r[o+1],s.usernameFragment=r[o+1];break;default:s[r[o]]===void 0&&(s[r[o]]=r[o+1]);break}return s},e.writeCandidate=function(t){const r=[];r.push(t.foundation);const s=t.component;s==="rtp"?r.push(1):s==="rtcp"?r.push(2):r.push(s),r.push(t.protocol.toUpperCase()),r.push(t.priority),r.push(t.address||t.ip),r.push(t.port);const o=t.type;return r.push("typ"),r.push(o),o!=="host"&&t.relatedAddress&&t.relatedPort&&(r.push("raddr"),r.push(t.relatedAddress),r.push("rport"),r.push(t.relatedPort)),t.tcpType&&t.protocol.toLowerCase()==="tcp"&&(r.push("tcptype"),r.push(t.tcpType)),(t.usernameFragment||t.ufrag)&&(r.push("ufrag"),r.push(t.usernameFragment||t.ufrag)),"candidate:"+r.join(" ")},e.parseIceOptions=function(t){return t.substr(14).split(" ")},e.parseRtpMap=function(t){let r=t.substr(9).split(" ");const s={payloadType:parseInt(r.shift(),10)};return r=r[0].split("/"),s.name=r[0],s.clockRate=parseInt(r[1],10),s.channels=r.length===3?parseInt(r[2],10):1,s.numChannels=s.channels,s},e.writeRtpMap=function(t){let r=t.payloadType;t.preferredPayloadType!==void 0&&(r=t.preferredPayloadType);const s=t.channels||t.numChannels||1;return"a=rtpmap:"+r+" "+t.name+"/"+t.clockRate+(s!==1?"/"+s:"")+`\r
`},e.parseExtmap=function(t){const r=t.substr(9).split(" ");return{id:parseInt(r[0],10),direction:r[0].indexOf("/")>0?r[0].split("/")[1]:"sendrecv",uri:r[1]}},e.writeExtmap=function(t){return"a=extmap:"+(t.id||t.preferredId)+(t.direction&&t.direction!=="sendrecv"?"/"+t.direction:"")+" "+t.uri+`\r
`},e.parseFmtp=function(t){const r={};let s;const o=t.substr(t.indexOf(" ")+1).split(";");for(let i=0;i<o.length;i++)s=o[i].trim().split("="),r[s[0].trim()]=s[1];return r},e.writeFmtp=function(t){let r="",s=t.payloadType;if(t.preferredPayloadType!==void 0&&(s=t.preferredPayloadType),t.parameters&&Object.keys(t.parameters).length){const o=[];Object.keys(t.parameters).forEach(i=>{t.parameters[i]!==void 0?o.push(i+"="+t.parameters[i]):o.push(i)}),r+="a=fmtp:"+s+" "+o.join(";")+`\r
`}return r},e.parseRtcpFb=function(t){const r=t.substr(t.indexOf(" ")+1).split(" ");return{type:r.shift(),parameter:r.join(" ")}},e.writeRtcpFb=function(t){let r="",s=t.payloadType;return t.preferredPayloadType!==void 0&&(s=t.preferredPayloadType),t.rtcpFeedback&&t.rtcpFeedback.length&&t.rtcpFeedback.forEach(o=>{r+="a=rtcp-fb:"+s+" "+o.type+(o.parameter&&o.parameter.length?" "+o.parameter:"")+`\r
`}),r},e.parseSsrcMedia=function(t){const r=t.indexOf(" "),s={ssrc:parseInt(t.substr(7,r-7),10)},o=t.indexOf(":",r);return o>-1?(s.attribute=t.substr(r+1,o-r-1),s.value=t.substr(o+1)):s.attribute=t.substr(r+1),s},e.parseSsrcGroup=function(t){const r=t.substr(13).split(" ");return{semantics:r.shift(),ssrcs:r.map(s=>parseInt(s,10))}},e.getMid=function(t){const r=e.matchPrefix(t,"a=mid:")[0];if(r)return r.substr(6)},e.parseFingerprint=function(t){const r=t.substr(14).split(" ");return{algorithm:r[0].toLowerCase(),value:r[1].toUpperCase()}},e.getDtlsParameters=function(t,r){const s=e.matchPrefix(t+r,"a=fingerprint:");return{role:"auto",fingerprints:s.map(e.parseFingerprint)}},e.writeDtlsParameters=function(t,r){let s="a=setup:"+r+`\r
`;return t.fingerprints.forEach(o=>{s+="a=fingerprint:"+o.algorithm+" "+o.value+`\r
`}),s},e.parseCryptoLine=function(t){const r=t.substr(9).split(" ");return{tag:parseInt(r[0],10),cryptoSuite:r[1],keyParams:r[2],sessionParams:r.slice(3)}},e.writeCryptoLine=function(t){return"a=crypto:"+t.tag+" "+t.cryptoSuite+" "+(typeof t.keyParams=="object"?e.writeCryptoKeyParams(t.keyParams):t.keyParams)+(t.sessionParams?" "+t.sessionParams.join(" "):"")+`\r
`},e.parseCryptoKeyParams=function(t){if(t.indexOf("inline:")!==0)return null;const r=t.substr(7).split("|");return{keyMethod:"inline",keySalt:r[0],lifeTime:r[1],mkiValue:r[2]?r[2].split(":")[0]:void 0,mkiLength:r[2]?r[2].split(":")[1]:void 0}},e.writeCryptoKeyParams=function(t){return t.keyMethod+":"+t.keySalt+(t.lifeTime?"|"+t.lifeTime:"")+(t.mkiValue&&t.mkiLength?"|"+t.mkiValue+":"+t.mkiLength:"")},e.getCryptoParameters=function(t,r){return e.matchPrefix(t+r,"a=crypto:").map(e.parseCryptoLine)},e.getIceParameters=function(t,r){const s=e.matchPrefix(t+r,"a=ice-ufrag:")[0],o=e.matchPrefix(t+r,"a=ice-pwd:")[0];return s&&o?{usernameFragment:s.substr(12),password:o.substr(10)}:null},e.writeIceParameters=function(t){let r="a=ice-ufrag:"+t.usernameFragment+`\r
a=ice-pwd:`+t.password+`\r
`;return t.iceLite&&(r+=`a=ice-lite\r
`),r},e.parseRtpParameters=function(t){const r={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},o=e.splitLines(t)[0].split(" ");for(let i=3;i<o.length;i++){const a=o[i],c=e.matchPrefix(t,"a=rtpmap:"+a+" ")[0];if(c){const u=e.parseRtpMap(c),l=e.matchPrefix(t,"a=fmtp:"+a+" ");switch(u.parameters=l.length?e.parseFmtp(l[0]):{},u.rtcpFeedback=e.matchPrefix(t,"a=rtcp-fb:"+a+" ").map(e.parseRtcpFb),r.codecs.push(u),u.name.toUpperCase()){case"RED":case"ULPFEC":r.fecMechanisms.push(u.name.toUpperCase());break}}}return e.matchPrefix(t,"a=extmap:").forEach(i=>{r.headerExtensions.push(e.parseExtmap(i))}),r},e.writeRtpDescription=function(t,r){let s="";s+="m="+t+" ",s+=r.codecs.length>0?"9":"0",s+=" UDP/TLS/RTP/SAVPF ",s+=r.codecs.map(i=>i.preferredPayloadType!==void 0?i.preferredPayloadType:i.payloadType).join(" ")+`\r
`,s+=`c=IN IP4 0.0.0.0\r
`,s+=`a=rtcp:9 IN IP4 0.0.0.0\r
`,r.codecs.forEach(i=>{s+=e.writeRtpMap(i),s+=e.writeFmtp(i),s+=e.writeRtcpFb(i)});let o=0;return r.codecs.forEach(i=>{i.maxptime>o&&(o=i.maxptime)}),o>0&&(s+="a=maxptime:"+o+`\r
`),r.headerExtensions&&r.headerExtensions.forEach(i=>{s+=e.writeExtmap(i)}),s},e.parseRtpEncodingParameters=function(t){const r=[],s=e.parseRtpParameters(t),o=s.fecMechanisms.indexOf("RED")!==-1,i=s.fecMechanisms.indexOf("ULPFEC")!==-1,a=e.matchPrefix(t,"a=ssrc:").map(p=>e.parseSsrcMedia(p)).filter(p=>p.attribute==="cname"),c=a.length>0&&a[0].ssrc;let u;const l=e.matchPrefix(t,"a=ssrc-group:FID").map(p=>p.substr(17).split(" ").map(m=>parseInt(m,10)));l.length>0&&l[0].length>1&&l[0][0]===c&&(u=l[0][1]),s.codecs.forEach(p=>{if(p.name.toUpperCase()==="RTX"&&p.parameters.apt){let d={ssrc:c,codecPayloadType:parseInt(p.parameters.apt,10)};c&&u&&(d.rtx={ssrc:u}),r.push(d),o&&(d=JSON.parse(JSON.stringify(d)),d.fec={ssrc:c,mechanism:i?"red+ulpfec":"red"},r.push(d))}}),r.length===0&&c&&r.push({ssrc:c});let h=e.matchPrefix(t,"b=");return h.length&&(h[0].indexOf("b=TIAS:")===0?h=parseInt(h[0].substr(7),10):h[0].indexOf("b=AS:")===0?h=parseInt(h[0].substr(5),10)*1e3*.95-50*40*8:h=void 0,r.forEach(p=>{p.maxBitrate=h})),r},e.parseRtcpParameters=function(t){const r={},s=e.matchPrefix(t,"a=ssrc:").map(a=>e.parseSsrcMedia(a)).filter(a=>a.attribute==="cname")[0];s&&(r.cname=s.value,r.ssrc=s.ssrc);const o=e.matchPrefix(t,"a=rtcp-rsize");r.reducedSize=o.length>0,r.compound=o.length===0;const i=e.matchPrefix(t,"a=rtcp-mux");return r.mux=i.length>0,r},e.writeRtcpParameters=function(t){let r="";return t.reducedSize&&(r+=`a=rtcp-rsize\r
`),t.mux&&(r+=`a=rtcp-mux\r
`),t.ssrc!==void 0&&t.cname&&(r+="a=ssrc:"+t.ssrc+" cname:"+t.cname+`\r
`),r},e.parseMsid=function(t){let r;const s=e.matchPrefix(t,"a=msid:");if(s.length===1)return r=s[0].substr(7).split(" "),{stream:r[0],track:r[1]};const o=e.matchPrefix(t,"a=ssrc:").map(i=>e.parseSsrcMedia(i)).filter(i=>i.attribute==="msid");if(o.length>0)return r=o[0].value.split(" "),{stream:r[0],track:r[1]}},e.parseSctpDescription=function(t){const r=e.parseMLine(t),s=e.matchPrefix(t,"a=max-message-size:");let o;s.length>0&&(o=parseInt(s[0].substr(19),10)),isNaN(o)&&(o=65536);const i=e.matchPrefix(t,"a=sctp-port:");if(i.length>0)return{port:parseInt(i[0].substr(12),10),protocol:r.fmt,maxMessageSize:o};const a=e.matchPrefix(t,"a=sctpmap:");if(a.length>0){const c=a[0].substr(10).split(" ");return{port:parseInt(c[0],10),protocol:c[1],maxMessageSize:o}}},e.writeSctpDescription=function(t,r){let s=[];return t.protocol!=="DTLS/SCTP"?s=["m="+t.kind+" 9 "+t.protocol+" "+r.protocol+`\r
`,`c=IN IP4 0.0.0.0\r
`,"a=sctp-port:"+r.port+`\r
`]:s=["m="+t.kind+" 9 "+t.protocol+" "+r.port+`\r
`,`c=IN IP4 0.0.0.0\r
`,"a=sctpmap:"+r.port+" "+r.protocol+` 65535\r
`],r.maxMessageSize!==void 0&&s.push("a=max-message-size:"+r.maxMessageSize+`\r
`),s.join("")},e.generateSessionId=function(){return Math.random().toString().substr(2,21)},e.writeSessionBoilerplate=function(t,r,s){let o;const i=r!==void 0?r:2;return t?o=t:o=e.generateSessionId(),`v=0\r
o=`+(s||"thisisadapterortc")+" "+o+" "+i+` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`},e.getDirection=function(t,r){const s=e.splitLines(t);for(let o=0;o<s.length;o++)switch(s[o]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return s[o].substr(2)}return r?e.getDirection(r):"sendrecv"},e.getKind=function(t){return e.splitLines(t)[0].split(" ")[0].substr(2)},e.isRejected=function(t){return t.split(" ",2)[1]==="0"},e.parseMLine=function(t){const s=e.splitLines(t)[0].substr(2).split(" ");return{kind:s[0],port:parseInt(s[1],10),protocol:s[2],fmt:s.slice(3).join(" ")}},e.parseOLine=function(t){const s=e.matchPrefix(t,"o=")[0].substr(2).split(" ");return{username:s[0],sessionId:s[1],sessionVersion:parseInt(s[2],10),netType:s[3],addressType:s[4],address:s[5]}},e.isValidSDP=function(t){if(typeof t!="string"||t.length===0)return!1;const r=e.splitLines(t);for(let s=0;s<r.length;s++)if(r[s].length<2||r[s].charAt(1)!=="=")return!1;return!0},n.exports=e})(nu);const Ts=nu.exports,yV=Oh({__proto__:null,default:Ts},[nu.exports]);function vo(n){if(!n.RTCIceCandidate||n.RTCIceCandidate&&"foundation"in n.RTCIceCandidate.prototype)return;const e=n.RTCIceCandidate;n.RTCIceCandidate=function(r){if(typeof r=="object"&&r.candidate&&r.candidate.indexOf("a=")===0&&(r=JSON.parse(JSON.stringify(r)),r.candidate=r.candidate.substr(2)),r.candidate&&r.candidate.length){const s=new e(r),o=Ts.parseCandidate(r.candidate),i=Object.assign(s,o);return i.toJSON=function(){return{candidate:i.candidate,sdpMid:i.sdpMid,sdpMLineIndex:i.sdpMLineIndex,usernameFragment:i.usernameFragment}},i}return new e(r)},n.RTCIceCandidate.prototype=e.prototype,ss(n,"icecandidate",t=>(t.candidate&&Object.defineProperty(t,"candidate",{value:new n.RTCIceCandidate(t.candidate),writable:"false"}),t))}function wo(n,e){if(!n.RTCPeerConnection)return;"sctp"in n.RTCPeerConnection.prototype||Object.defineProperty(n.RTCPeerConnection.prototype,"sctp",{get(){return typeof this._sctp>"u"?null:this._sctp}});const t=function(a){if(!a||!a.sdp)return!1;const c=Ts.splitSections(a.sdp);return c.shift(),c.some(u=>{const l=Ts.parseMLine(u);return l&&l.kind==="application"&&l.protocol.indexOf("SCTP")!==-1})},r=function(a){const c=a.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);if(c===null||c.length<2)return-1;const u=parseInt(c[1],10);return u!==u?-1:u},s=function(a){let c=65536;return e.browser==="firefox"&&(e.version<57?a===-1?c=16384:c=2147483637:e.version<60?c=e.version===57?65535:65536:c=2147483637),c},o=function(a,c){let u=65536;e.browser==="firefox"&&e.version===57&&(u=65535);const l=Ts.matchPrefix(a.sdp,"a=max-message-size:");return l.length>0?u=parseInt(l[0].substr(19),10):e.browser==="firefox"&&c!==-1&&(u=2147483637),u},i=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,e.browser==="chrome"&&e.version>=76){const{sdpSemantics:c}=this.getConfiguration();c==="plan-b"&&Object.defineProperty(this,"sctp",{get(){return typeof this._sctp>"u"?null:this._sctp},enumerable:!0,configurable:!0})}if(t(arguments[0])){const c=r(arguments[0]),u=s(c),l=o(arguments[0],c);let h;u===0&&l===0?h=Number.POSITIVE_INFINITY:u===0||l===0?h=Math.max(u,l):h=Math.min(u,l);const p={};Object.defineProperty(p,"maxMessageSize",{get(){return h}}),this._sctp=p}return i.apply(this,arguments)}}function Co(n){if(!(n.RTCPeerConnection&&"createDataChannel"in n.RTCPeerConnection.prototype))return;function e(r,s){const o=r.send;r.send=function(){const a=arguments[0],c=a.length||a.size||a.byteLength;if(r.readyState==="open"&&s.sctp&&c>s.sctp.maxMessageSize)throw new TypeError("Message too large (can send a maximum of "+s.sctp.maxMessageSize+" bytes)");return o.apply(r,arguments)}}const t=n.RTCPeerConnection.prototype.createDataChannel;n.RTCPeerConnection.prototype.createDataChannel=function(){const s=t.apply(this,arguments);return e(s,this),s},ss(n,"datachannel",r=>(e(r.channel,r.target),r))}function Ja(n){if(!n.RTCPeerConnection||"connectionState"in n.RTCPeerConnection.prototype)return;const e=n.RTCPeerConnection.prototype;Object.defineProperty(e,"connectionState",{get(){return{completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(e,"onconnectionstatechange",{get(){return this._onconnectionstatechange||null},set(t){this._onconnectionstatechange&&(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),t&&this.addEventListener("connectionstatechange",this._onconnectionstatechange=t)},enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach(t=>{const r=e[t];e[t]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=s=>{const o=s.target;if(o._lastConnectionState!==o.connectionState){o._lastConnectionState=o.connectionState;const i=new Event("connectionstatechange",s);o.dispatchEvent(i)}return s},this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),r.apply(this,arguments)}})}function ec(n,e){if(!n.RTCPeerConnection||e.browser==="chrome"&&e.version>=71||e.browser==="safari"&&e.version>=605)return;const t=n.RTCPeerConnection.prototype.setRemoteDescription;n.RTCPeerConnection.prototype.setRemoteDescription=function(s){if(s&&s.sdp&&s.sdp.indexOf(`
a=extmap-allow-mixed`)!==-1){const o=s.sdp.split(`
`).filter(i=>i.trim()!=="a=extmap-allow-mixed").join(`
`);n.RTCSessionDescription&&s instanceof n.RTCSessionDescription?arguments[0]=new n.RTCSessionDescription({type:s.type,sdp:o}):s.sdp=o}return t.apply(this,arguments)}}function So(n,e){if(!(n.RTCPeerConnection&&n.RTCPeerConnection.prototype))return;const t=n.RTCPeerConnection.prototype.addIceCandidate;!t||t.length===0||(n.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?(e.browser==="chrome"&&e.version<78||e.browser==="firefox"&&e.version<68||e.browser==="safari")&&arguments[0]&&arguments[0].candidate===""?Promise.resolve():t.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())})}function To(n,e){if(!(n.RTCPeerConnection&&n.RTCPeerConnection.prototype))return;const t=n.RTCPeerConnection.prototype.setLocalDescription;!t||t.length===0||(n.RTCPeerConnection.prototype.setLocalDescription=function(){let s=arguments[0]||{};if(typeof s!="object"||s.type&&s.sdp)return t.apply(this,arguments);if(s={type:s.type,sdp:s.sdp},!s.type)switch(this.signalingState){case"stable":case"have-local-offer":case"have-remote-pranswer":s.type="offer";break;default:s.type="answer";break}return s.sdp||s.type!=="offer"&&s.type!=="answer"?t.apply(this,[s]):(s.type==="offer"?this.createOffer:this.createAnswer).apply(this).then(i=>t.apply(this,[i]))})}const xV=Object.freeze(Object.defineProperty({__proto__:null,shimRTCIceCandidate:vo,shimMaxMessageSize:wo,shimSendThrowTypeError:Co,shimConnectionState:Ja,removeExtmapAllowMixed:ec,shimAddIceCandidateNullOrEmpty:So,shimParameterlessSetLocalDescription:To},Symbol.toStringTag,{value:"Module"}));function bV({window:n}={},e={shimChrome:!0,shimFirefox:!0,shimSafari:!0}){const t=bx,r=fV(n),s={browserDetails:r,commonShim:xV,extractVersion:bo,disableLog:pV,disableWarnings:dV,sdp:yV};switch(r.browser){case"chrome":if(!kh||!Qa||!e.shimChrome)return t("Chrome shim is not included in this adapter release."),s;if(r.version===null)return t("Chrome shim can not determine version, not shimming."),s;t("adapter.js shimming chrome."),s.browserShim=kh,So(n,r),To(n),Cx(n,r),Sx(n),Qa(n,r),Tx(n),Ix(n,r),$x(n),Ex(n),kx(n),_x(n,r),vo(n),Ja(n),wo(n,r),Co(n),ec(n,r);break;case"firefox":if(!Nh||!Za||!e.shimFirefox)return t("Firefox shim is not included in this adapter release."),s;t("adapter.js shimming firefox."),s.browserShim=Nh,So(n,r),To(n),Rx(n,r),Za(n,r),Ox(n),Px(n),Ax(n),Dx(n),Fx(n),Lx(n),Mx(n),Bx(n),Vx(n),vo(n),Ja(n),wo(n,r),Co(n);break;case"safari":if(!Ih||!e.shimSafari)return t("Safari shim is not included in this adapter release."),s;t("adapter.js shimming safari."),s.browserShim=Ih,So(n,r),To(n),Hx(n),qx(n),Wx(n),Ux(n),zx(n),Kx(n),Gx(n),Xx(n),vo(n),wo(n,r),Co(n),ec(n,r);break;default:t("Unsupported browser!");break}return s}bV({window:typeof window>"u"?void 0:window});const vV={"720p":{width:1280,height:720},"480p":{width:640,height:480},"480 X 640":{width:480,height:640},"640 X 360":{width:640,height:360},"360 X 270":{width:360,height:270}};class wV{constructor(e,t,r,s="environment"){ue(this,"video");ue(this,"canvas");ue(this,"stream");ue(this,"ctx");ue(this,"deviceSelect");ue(this,"facingMode");ue(this,"targetFPS",30);ue(this,"videoSize",vV["480p"]);ue(this,"flip",!0);ue(this,"canvasSize");ue(this,"constraints");this.canvas=t,this.video=e,this.deviceSelect=r,this.facingMode=s;const o=this.canvas.getContext("2d");if(!o)throw new Error("Can't get canvas context");this.ctx=o,this.constraints={audio:!1,video:{facingMode:this.facingMode,width:{ideal:this.videoSize.width},height:{ideal:this.videoSize.height},frameRate:{ideal:this.targetFPS}}}}dispose(){console.log("[TPCamera] dispose"),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}async setupCamera(){if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("Browser API navigator.mediaDevices.getUserMedia not available");await this.listDevices();const[e,t]=await cn(this.setupStream());if(!t)throw new Error(`[${this.constructor.name}}] setupStream failed: ${e}`);this.stream=t}async listDevices(){if(!navigator.mediaDevices||!navigator.mediaDevices.enumerateDevices)throw new Error(`[${this.constructor.name}}] enumerateDevices failed`);const[e,t]=await cn(navigator.mediaDevices.enumerateDevices());if(t===void 0)throw new Error(`[${this.constructor.name}}] No available devices: ${e}`);return t==null||t.forEach(r=>{r.kind==="videoinput"&&this.deviceSelect.appendChild(new Option(r.label,r.deviceId))}),t}async setupStream(){const[e,t]=await cn(navigator.mediaDevices.getUserMedia(this.constraints));if(t===void 0)throw new Error(`[${this.constructor.name}}] Unable to find an available stream.`);Array.from(this.deviceSelect.options).forEach(s=>{s.text===(t==null?void 0:t.getTracks()[0].label)&&(this.deviceSelect.value=s.value)});const r=t.getTracks()[0].label;return console.log(`Camera device <${r}> selected.`),this.flip=!(r.includes("\u540E\u7F6E")||r.toLowerCase().includes("back")),this.video.srcObject=t,this.video.play(),await new Promise(s=>{this.video.onloadedmetadata=()=>{this.videoSize.width=this.video.videoWidth,this.videoSize.height=this.video.videoHeight,console.log(`Got stream of size ${this.video.videoWidth} x ${this.video.videoHeight}`),s()}}),this.video.width=this.videoSize.width,this.video.height=this.videoSize.height,t}setupCanvas(e){return this.canvas.width=e.width,this.canvas.height=e.height,this.canvasSize=e,this.canvasSize}drawCtx(){if(this.canvasSize){this.ctx.clearRect(0,0,this.canvasSize.width,this.canvasSize.height);const[e,t,r,s]=SI(this.videoSize,this.canvasSize);this.ctx.save(),this.flip&&(this.ctx.translate(this.canvasSize.width,0),this.ctx.scale(-1,1)),this.ctx.drawImage(this.video,e,t,r,s,0,0,this.canvasSize.width,this.canvasSize.height),this.ctx.restore()}}async changeDevice(){var o,i,a;const e=(o=this.deviceSelect)!=null&&o.value?{exact:this.deviceSelect.value}:void 0;((i=this.constraints)==null?void 0:i.video)!==void 0&&typeof((a=this.constraints)==null?void 0:a.video)!="boolean"&&(this.constraints.video.deviceId=e);const[t,r]=await cn(this.setupStream());if(!r)throw new Error(`[${this.constructor.name}}] setupStream failed: ${t}`);this.stream=r;const[s]=Array.from(this.deviceSelect.options).filter(c=>c.value===this.deviceSelect.value);console.log(this.deviceSelect.options),console.log(s),this.canvasSize&&this.setupCanvas(this.canvasSize)}async waitForFrame(){if(this.video.readyState<2)return new Promise(e=>{this.video.onloadeddata=()=>{e()}})}switchCameras(){if(this.stream){this.facingMode=this.facingMode==="user"?"environment":"user";const[e]=this.stream.getVideoTracks();e==null||e.applyConstraints({facingMode:this.facingMode})}}setFacingMode(e){if(this.stream){this.facingMode=e;const[t]=this.stream.getVideoTracks();t==null||t.applyConstraints({facingMode:this.facingMode})}}requestCameraSize(e){if(this.stream){const[t]=this.stream.getVideoTracks();t==null||t.applyConstraints(e)}}}function CV(n){let e,t,r,s,o,i,a,c,u,l,h,p,d;return c=new U0({props:{data:W0}}),{c(){e=wt("div"),t=wt("video"),r=vs(),s=wt("canvas"),i=vs(),a=wt("btn"),O0(c.$$.fragment),u=vs(),l=wt("select"),this.h()},l(m){e=Ct(m,"DIV",{class:!0});var g=Qe(e);t=Ct(g,"VIDEO",{class:!0}),Qe(t).forEach($e),r=ws(g),s=Ct(g,"CANVAS",{}),Qe(s).forEach($e),g.forEach($e),i=ws(m),a=Ct(m,"BTN",{class:!0});var y=Qe(a);A0(c.$$.fragment,y),y.forEach($e),u=ws(m),l=Ct(m,"SELECT",{class:!0}),Qe(l).forEach($e),this.h()},h(){t.autoplay=!0,t.muted=!0,t.playsInline=!0,Pe(t,"class","hidden"),Pe(e,"class",o=`${n[1]||""} z-10`),Pe(a,"class","btn btn-primary fixed bottom-16 right-8 z-50"),Pe(l,"class","select select-sm fixed bottom-24 left-8 z-50")},m(m,g){an(m,e,g),rt(e,t),n[10](t),rt(e,r),rt(e,s),n[11](s),an(m,i,g),an(m,a,g),D0(c,a,null),n[12](a),an(m,u,g),an(m,l,g),n[13](l),h=!0,p||(d=[Qi(a,"click",n[6]),Qi(l,"change",n[14])],p=!0)},p(m,[g]){(!h||g&2&&o!==(o=`${m[1]||""} z-10`))&&Pe(e,"class",o)},i(m){h||(P0(c.$$.fragment,m),h=!0)},o(m){F0(c.$$.fragment,m),h=!1},d(m){m&&$e(e),n[10](null),n[11](null),m&&$e(i),m&&$e(a),L0(c),n[12](null),m&&$e(u),m&&$e(l),n[13](null),p=!1,M0(d)}}}function SV(n,e,t){const r=B0();let{tpCamera:s}=e,{width:o,height:i}=e,{facingMode:a="environment"}=e,c,u,l,h,{class:p}=e;function d(){let S=u.toDataURL("image/png");t(5,h.href=S,h),t(5,h.download="download.png",h)}_h(async()=>{t(0,s=new wV(c,u,l,a)),await s.setupCamera();const S=s.setupCanvas({width:o,height:i});r("canvas-ready",{size:S})}),V0(()=>{s&&s.dispose()});function m(S){ms[S?"unshift":"push"](()=>{c=S,t(2,c)})}function g(S){ms[S?"unshift":"push"](()=>{u=S,t(3,u)})}function y(S){ms[S?"unshift":"push"](()=>{h=S,t(5,h)})}function x(S){ms[S?"unshift":"push"](()=>{l=S,t(4,l)})}const w=()=>{s.deviceSelect&&s.changeDevice()};return n.$$set=S=>{"tpCamera"in S&&t(0,s=S.tpCamera),"width"in S&&t(7,o=S.width),"height"in S&&t(8,i=S.height),"facingMode"in S&&t(9,a=S.facingMode),"class"in S&&t(1,p=S.class)},[s,p,c,u,l,h,d,o,i,a,m,g,y,x,w]}class FV extends tc{constructor(e){super(),nc(this,e,SV,CV,rc,{tpCamera:0,width:7,height:8,facingMode:9,class:1})}}class LV{constructor(e=60){this.time={stopped:!1,previous:0,current:0,elapsed:0,interval:1e3/e}}start(e){this.time.stopped=!1,this.time.previous=Date.now(),this.func=e,this.func&&typeof this.func=="function"&&this.update()}stop(){this.time.stopped=!0}update(){this.time.stopped||(this.rafID=window.requestAnimationFrame(()=>this.update()),this.time.current=Date.now(),this.time.elapsed=this.time.current-this.time.previous,this.time.elapsed>=this.time.interval&&(this.time.previous=this.time.current-this.time.elapsed%this.time.interval,this.func()))}destroy(){this.stop(),this.rafID&&window.cancelAnimationFrame(this.rafID),console.log(this.rafID,"animator destroyed")}}const TV=new URL(Rh+"/models/detector/model.json",import.meta.url).href,$V=new URL(Rh+"/models/landmark/model.json",import.meta.url).href,EV=[{detectorModelUrl:TV,landmarkModelUrl:$V},{detectorModelUrl:"https://alg.halftime.fit/model/detecter/model.json",landmarkModelUrl:"https://alg.halftime.fit/model/landmark/model.json"},{detectorModelUrl:"https://raw.githubusercontent.com/TensorHealth/Assets/main/blazepose-models/tfjs-model_blazepose_3d_detector_1/model.json",landmarkModelUrl:"https://raw.githubusercontent.com/TensorHealth/Assets/main/blazepose-models/tfjs-model_blazepose_3d_landmark_full_2/model.json"},{detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},{detectorModelUrl:"https://www.gstaticcnapps.cn/tfhub-tfjs-modules/mediapipe/tfjs-model/blazepose_3d/detector/1/model.json",landmarkModelUrl:"https://www.gstaticcnapps.cn/tfhub-tfjs-modules/mediapipe/tfjs-model/blazepose_3d/landmark/full/2/model.json"},{detectorModelUrl:"https://hub.tensorflow.google.cn/mediapipe/tfjs-model/blazepose_3d/detector/1/model.json?tfjs-format=file",landmarkModelUrl:"https://hub.tensorflow.google.cn/mediapipe/tfjs-model/blazepose_3d/landmark/full/2/model.json?tfjs-format=file"}];async function MV(n,e,t){console.log("dev",z0);const r=EV[0];console.log(r);const[s,o]=await cn(lV("webgl"));if(!o)throw new Error(`TF backend initiation failed ${s}`);const i=new _I(t,!1),a=new hV(e.canvas,t,n),[c,u]=await cn(i.load(n,r));if(!u)throw new Error(`Model not ready ${c}`);return console.log("Model ready"),[i,a]}export{FV as C,At as D,RV as L,_V as M,Ir as S,LV as T,AV as W,OV as a,un as b,NI as c,DV as g,Dr as h,MV as i,Bu as m,PV as o,cn as t};
